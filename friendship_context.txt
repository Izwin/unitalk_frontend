import 'package:json_annotation/json_annotation.dart';
import 'package:unitalk/features/block/data/model/block_model.dart';
import 'package:unitalk/features/faculty/data/models/faculty_model.dart';
import 'package:unitalk/features/university/data/models/university_model.dart';
import 'verification_model.dart';

part 'user_model.g.dart';

enum Sector {
  @JsonValue('en')
  english,
  @JsonValue('ru')
  russian,
  @JsonValue('az')
  azerbaijani;

  String get code {
    switch (this) {
      case Sector.english:
        return 'en';
      case Sector.russian:
        return 'ru';
      case Sector.azerbaijani:
        return 'az';
    }
  }

  String get displayName {
    switch (this) {
      case Sector.english:
        return 'English';
      case Sector.russian:
        return 'Russian';
      case Sector.azerbaijani:
        return 'Azerbaijani';
    }
  }

  String get flagEmoji {
    switch (this) {
      case Sector.english:
        return 'üá¨üáß';
      case Sector.russian:
        return 'üá∑üá∫';
      case Sector.azerbaijani:
        return 'üá¶üáø';
    }
  }

  static Sector? fromCode(String? code) {
    if (code == null) return null;
    switch (code) {
      case 'en':
        return Sector.english;
      case 'ru':
        return Sector.russian;
      case 'az':
        return Sector.azerbaijani;
      default:
        return null;
    }
  }
}

@JsonSerializable()
class UserModel {
  @JsonKey(name: '_id')
  final String? id;
  final String? email;
  final String? photoUrl;
  final String? firstName;
  final String? lastName;
  @JsonKey(name: 'universityId')
  final UniversityModel? university;
  @JsonKey(name: 'facultyId')
  final FacultyModel? faculty;
  final Sector? sector;
  final bool? isVerified;
  @JsonKey(name: 'verificationId')
  final VerificationModel? verification;
  final BlockStatusModel? blockStatus;

  // –ù–û–í–û–ï: –Ø–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —Å–µ—Ä–≤–µ—Ä–∞
  final String? language;

  UserModel({
    required this.id,
    this.email,
    this.photoUrl,
    this.firstName,
    this.lastName,
    this.university,
    this.faculty,
    this.sector,
    this.isVerified,
    this.verification,
    this.blockStatus,
    this.language, // –ù–û–í–û–ï
  });

  factory UserModel.fromJson(Map<String, dynamic> json) =>
      _$UserModelFromJson(json);

  Map<String, dynamic> toJson() => _$UserModelToJson(this);

  bool get isProfileComplete =>
      firstName != null &&
          lastName != null &&
          university != null &&
          faculty != null &&
          sector != null;

  bool get canInteract => blockStatus?.canInteract ?? true;
  bool get isBlocked => blockStatus?.isBlocked ?? false;
  bool get isBlockedBy => blockStatus?.isBlockedBy ?? false;
}// lib/features/friendship/data/models/friendship_model.dart
import 'package:json_annotation/json_annotation.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

part 'friendship_model.g.dart';

enum FriendshipStatus {
  @JsonValue('none')
  none,
  @JsonValue('pending')
  pending,
  @JsonValue('accepted')
  accepted,
  @JsonValue('rejected')
  rejected,
}

@JsonSerializable()
class FriendshipModel {
  @JsonKey(name: '_id')
  final String? id;
  final FriendshipStatus status;
  final String? friendshipId;
  final bool? isRequester;
  final DateTime? createdAt;
  final DateTime? acceptedAt;

  FriendshipModel({
    this.id,
    required this.status,
    this.friendshipId,
    this.isRequester,
    this.createdAt,
    this.acceptedAt,
  });

  factory FriendshipModel.fromJson(Map<String, dynamic> json) =>
      _$FriendshipModelFromJson(json);

  Map<String, dynamic> toJson() => _$FriendshipModelToJson(this);

  bool get isPending => status == FriendshipStatus.pending;
  bool get isAccepted => status == FriendshipStatus.accepted;
  bool get isNone => status == FriendshipStatus.none;
}

@JsonSerializable()
class FriendshipStatusResponse {
  final FriendshipStatus status;
  final bool isFriend;
  final String? friendshipId;
  final bool? isRequester;
  final DateTime? createdAt;
  final DateTime? acceptedAt;

  FriendshipStatusResponse({
    required this.status,
    required this.isFriend,
    this.friendshipId,
    this.isRequester,
    this.createdAt,
    this.acceptedAt,
  });

  factory FriendshipStatusResponse.fromJson(Map<String, dynamic> json) =>
      _$FriendshipStatusResponseFromJson(json);

  Map<String, dynamic> toJson() => _$FriendshipStatusResponseToJson(this);
}

@JsonSerializable()
class FriendRequestModel {
  final String friendshipId;
  final UserModel user;
  final DateTime requestedAt;

  FriendRequestModel({
    required this.friendshipId,
    required this.user,
    required this.requestedAt,
  });

  factory FriendRequestModel.fromJson(Map<String, dynamic> json) =>
      _$FriendRequestModelFromJson(json);

  Map<String, dynamic> toJson() => _$FriendRequestModelToJson(this);
}// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'friendship_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

FriendshipModel _$FriendshipModelFromJson(Map<String, dynamic> json) =>
    FriendshipModel(
      id: json['_id'] as String?,
      status: $enumDecode(_$FriendshipStatusEnumMap, json['status']),
      friendshipId: json['friendshipId'] as String?,
      isRequester: json['isRequester'] as bool?,
      createdAt: json['createdAt'] == null
          ? null
          : DateTime.parse(json['createdAt'] as String),
      acceptedAt: json['acceptedAt'] == null
          ? null
          : DateTime.parse(json['acceptedAt'] as String),
    );

Map<String, dynamic> _$FriendshipModelToJson(FriendshipModel instance) =>
    <String, dynamic>{
      '_id': instance.id,
      'status': _$FriendshipStatusEnumMap[instance.status]!,
      'friendshipId': instance.friendshipId,
      'isRequester': instance.isRequester,
      'createdAt': instance.createdAt?.toIso8601String(),
      'acceptedAt': instance.acceptedAt?.toIso8601String(),
    };

const _$FriendshipStatusEnumMap = {
  FriendshipStatus.none: 'none',
  FriendshipStatus.pending: 'pending',
  FriendshipStatus.accepted: 'accepted',
  FriendshipStatus.rejected: 'rejected',
};

FriendshipStatusResponse _$FriendshipStatusResponseFromJson(
  Map<String, dynamic> json,
) => FriendshipStatusResponse(
  status: $enumDecode(_$FriendshipStatusEnumMap, json['status']),
  isFriend: json['isFriend'] as bool,
  friendshipId: json['friendshipId'] as String?,
  isRequester: json['isRequester'] as bool?,
  createdAt: json['createdAt'] == null
      ? null
      : DateTime.parse(json['createdAt'] as String),
  acceptedAt: json['acceptedAt'] == null
      ? null
      : DateTime.parse(json['acceptedAt'] as String),
);

Map<String, dynamic> _$FriendshipStatusResponseToJson(
  FriendshipStatusResponse instance,
) => <String, dynamic>{
  'status': _$FriendshipStatusEnumMap[instance.status]!,
  'isFriend': instance.isFriend,
  'friendshipId': instance.friendshipId,
  'isRequester': instance.isRequester,
  'createdAt': instance.createdAt?.toIso8601String(),
  'acceptedAt': instance.acceptedAt?.toIso8601String(),
};

FriendRequestModel _$FriendRequestModelFromJson(Map<String, dynamic> json) =>
    FriendRequestModel(
      friendshipId: json['friendshipId'] as String,
      user: UserModel.fromJson(json['user'] as Map<String, dynamic>),
      requestedAt: DateTime.parse(json['requestedAt'] as String),
    );

Map<String, dynamic> _$FriendRequestModelToJson(FriendRequestModel instance) =>
    <String, dynamic>{
      'friendshipId': instance.friendshipId,
      'user': instance.user,
      'requestedAt': instance.requestedAt.toIso8601String(),
    };
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

class UserRemoteDataSource {
  final Dio dio;

  UserRemoteDataSource({required this.dio});

  Future<UserModel> getCurrentUser() async {
    try {
      final response = await dio.get('/auth/me');
      return UserModel.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Future<UserModel> getUserById(String userId) async {
    try {
      final response = await dio.get('/auth/$userId');
      return UserModel.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Future<UserModel> updateProfile({
    required String firstName,
    required String lastName,
    required String universityId,
    required String facultyId,
    required String sector,
    String? language,
  }) async {
    try {
      final data = {
        'firstName': firstName,
        'lastName': lastName,
        'universityId': universityId,
        'facultyId': facultyId,
        'sector': sector,
      };

      if (language != null) {
        data['language'] = language;
      }

      final response = await dio.put('/auth/profile', data: data);
      return UserModel.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Future<UserModel> updateLanguage(String language) async {
    try {
      final response = await dio.put(
        '/auth/profile',
        data: {'language': language},
      );
      return UserModel.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Future<String> updateAvatar({required File file}) async {
    try {
      final formData = FormData.fromMap({
        'avatar': await MultipartFile.fromFile(file.path, filename: 'avatar.jpg'),
      });

      final response = await dio.post('/auth/avatar', data: formData);
      return response.data['photoUrl'] as String;
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  Future<void> deleteProfile() async {
    try {
      await dio.delete('/auth/profile');
    } on DioException catch (e) {
      throw _handleDioError(e);
    }
  }

  String _handleDioError(DioException error) {
    switch (error.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        return 'Connection timeout. Please check your internet connection.';

      case DioExceptionType.connectionError:
        if (error.error is SocketException) {
          return 'No internet connection. Please check your network.';
        }
        return 'Connection error. Please check your internet connection.';

      case DioExceptionType.badResponse:
        final statusCode = error.response?.statusCode;
        if (statusCode == 401) {
          return 'Session expired. Please login again.';
        } else if (statusCode == 403) {
          return 'Access denied.';
        } else if (statusCode == 404) {
          return 'Resource not found.';
        } else if (statusCode != null && statusCode >= 500) {
          return 'Server error. Please try again later.';
        }
        return error.response?.data?['message'] ?? 'Request failed.';

      case DioExceptionType.cancel:
        return 'Request cancelled.';

      case DioExceptionType.unknown:
        if (error.error is SocketException) {
          return 'No internet connection. Please check your network.';
        }
        return 'An unexpected error occurred.';

      default:
        return 'An error occurred. Please try again.';
    }
  }
}import 'dart:io';
import 'package:dartz/dartz.dart';
import 'package:unitalk/core/failure/failure.dart';
import 'package:unitalk/features/auth/data/datasource/user_remote_datasource.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';
import 'package:unitalk/features/auth/domain/repository/user_repository.dart';

class UserRepositoryImpl implements UserRepository {
  final UserRemoteDataSource remoteDataSource;

  UserRepositoryImpl(this.remoteDataSource);

  @override
  Future<Either<Failure, UserModel>> getCurrentUser() async {
    try {
      final user = await remoteDataSource.getCurrentUser();
      return Right(user);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, UserModel>> getUserById(String userId) async {
    try {
      final user = await remoteDataSource.getUserById(userId);
      return Right(user);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, UserModel>> updateProfile({
    required String firstName,
    required String lastName,
    required String universityId,
    required String facultyId,
    required Sector sector,
    String? language,
  }) async {
    try {
      final user = await remoteDataSource.updateProfile(
        firstName: firstName,
        lastName: lastName,
        universityId: universityId,
        facultyId: facultyId,
        sector: sector.code,
        language: language,
      );
      return Right(user);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, String>> updateAvatar(File file) async {
    try {
      final photoUrl = await remoteDataSource.updateAvatar(file: file);
      return Right(photoUrl);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> deleteProfile() async {
    try {
      await remoteDataSource.deleteProfile();
      return const Right(null);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }
}import 'dart:io';
import 'package:dartz/dartz.dart';
import 'package:unitalk/core/failure/failure.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

abstract class UserRepository {
  Future<Either<Failure, UserModel>> getCurrentUser();

  Future<Either<Failure, UserModel>> getUserById(String userId);

  Future<Either<Failure, UserModel>> updateProfile({
    required String firstName,
    required String lastName,
    required String universityId,
    required String facultyId,
    required Sector sector,
    String? language,
  });

  Future<Either<Failure, String>> updateAvatar(File file);

  Future<Either<Failure, void>> deleteProfile();
}import 'package:dio/dio.dart';
import 'package:unitalk/features/feed/data/model/post_model.dart';
import 'dart:io';

class PostRemoteDataSource {
  final Dio dio;

  PostRemoteDataSource({required this.dio});

  Future<PostModel> createPost({
    required String content,
    required bool isAnonymous,
    File? mediaFile, // –ò–∑–º–µ–Ω–µ–Ω–æ —Å imageFile –Ω–∞ mediaFile
  }) async {
    FormData formData = FormData.fromMap({
      'content': content,
      'isAnonymous': isAnonymous,
      if (mediaFile != null)
        'media': await MultipartFile.fromFile(
          mediaFile.path,
          filename: _getMediaFileName(mediaFile),
        ),
    });

    final response = await dio.post(
      '/posts',
      data: formData,
    );

    return PostModel.fromJson(response.data);
  }

  // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
  String _getMediaFileName(File file) {
    final path = file.path.toLowerCase();
    if (path.endsWith('.mp4') || path.endsWith('.mov')) {
      return 'post_video.mp4';
    }
    return 'post_image.jpg';
  }

  Future<Map<String, dynamic>> getPosts({
    String? universityId,
    String? authorId,
    String sortBy = 'new',
    String? sector,
    String? facultyId,
    int page = 1,
    int limit = 20,
  }) async {
    final response = await dio.get(
      '/posts',
      queryParameters: {
        if (universityId != null) 'universityId': universityId,
        if (authorId != null) 'authorId': authorId,
        if (sector != null) 'sector': sector,
        if (facultyId != null) 'facultyId': facultyId,
        'sortBy': sortBy,
        'page': page,
        'limit': limit,
      },
    );
    return response.data as Map<String, dynamic>;
  }

  Future<PostModel> getPost(String postId) async {
    final response = await dio.get('/posts/$postId');
    return PostModel.fromJson(response.data);
  }

  Future<void> deletePost(String postId) async {
    await dio.delete('/posts/$postId');
  }
}import 'dart:io';
import 'package:dartz/dartz.dart';
import 'package:unitalk/core/failure/failure.dart';
import 'package:unitalk/features/feed/data/datasource/post_remote_datasource.dart';
import 'package:unitalk/features/feed/data/model/post_model.dart';
import 'package:unitalk/features/feed/domain/repository/posts_repository.dart';

class PostRepositoryImpl implements PostRepository {
  final PostRemoteDataSource remoteDataSource;

  PostRepositoryImpl(this.remoteDataSource);

  @override
  Future<Either<Failure, PostModel>> createPost({
    required String content,
    required bool isAnonymous,
    File? mediaFile, // –ò–∑–º–µ–Ω–µ–Ω–æ —Å imageFile –Ω–∞ mediaFile
  }) async {
    try {
      final post = await remoteDataSource.createPost(
        content: content,
        isAnonymous: isAnonymous,
        mediaFile: mediaFile,
      );
      return Right(post);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<PostModel>>> getPosts({
    String? universityId,
    String? authorId,
    String sortBy = 'new',
    String? sector,
    String? facultyId,
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final data = await remoteDataSource.getPosts(
        universityId: universityId,
        authorId: authorId,
        sortBy: sortBy,
        sector: sector,
        facultyId: facultyId,
        page: page,
        limit: limit,
      );
      final posts = (data['posts'] as List)
          .map((p) => PostModel.fromJson(p as Map<String, dynamic>))
          .toList();
      return Right(posts);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, PostModel>> getPost(String postId) async {
    try {
      final post = await remoteDataSource.getPost(postId);
      return Right(post);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> deletePost(String postId) async {
    try {
      await remoteDataSource.deletePost(postId);
      return const Right(null);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }
}import 'dart:io';
import 'package:dartz/dartz.dart';
import 'package:unitalk/core/failure/failure.dart';
import 'package:unitalk/features/feed/data/model/post_model.dart';

abstract class PostRepository {
  Future<Either<Failure, PostModel>> createPost({
    required String content,
    required bool isAnonymous,
    File? mediaFile, // –ò–∑–º–µ–Ω–µ–Ω–æ —Å imageFile –Ω–∞ mediaFile
  });

  Future<Either<Failure, List<PostModel>>> getPosts({
    String? universityId,
    String? authorId,
    String sortBy = 'new',
    String? sector,
    String? facultyId,
    int page = 1,
    int limit = 20,
  });

  Future<Either<Failure, PostModel>> getPost(String postId);

  Future<Either<Failure, void>> deletePost(String postId);
}// features/feed/presentation/bloc/post/post_bloc.dart
import 'dart:async';
import 'dart:io';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/core/services/post_syns_service.dart';
import 'package:unitalk/features/feed/data/model/post_model.dart';
import 'package:unitalk/features/feed/domain/repository/like_repository.dart';
import 'package:unitalk/features/feed/domain/repository/posts_repository.dart';

import 'post_event.dart';
import 'post_state.dart';

class PostBloc extends Bloc<PostEvent, PostState> {
  final PostRepository postRepository;
  final LikeRepository likeRepository;
  final PostSyncService postSyncService;
  StreamSubscription? _syncSubscription;

  PostBloc({
    required this.postRepository,
    required this.likeRepository,
    required this.postSyncService,
  }) : super(PostState.initial()) {
    on<CreatePostEvent>(_onCreatePost);
    on<GetPostsEvent>(_onGetPosts);
    on<GetPostEvent>(_onGetPost);
    on<DeletePostEvent>(_onDeletePost);
    on<ToggleLikeEvent>(_onToggleLike);
    on<SyncPostUpdateEvent>(_onSyncPostUpdate);

    // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–∑ PostSyncService
    _syncSubscription = postSyncService.updates.listen((update) {
      print(
        'PostBloc: Received sync update - type: ${update.type}, postId: ${update.postId}',
      );
      add(SyncPostUpdateEvent(update));
    });
  }

  // === –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ—Å—Ç–∞ ===
  Future<void> _onCreatePost(
      CreatePostEvent event,
      Emitter<PostState> emit,
      ) async {
    emit(state.copyWith(status: PostStatus.loading, errorMessage: null));

    final result = await postRepository.createPost(
      content: event.content,
      isAnonymous: event.isAnonymous,
      mediaFile: event.mediaFile,
    );

    result.fold(
          (failure) => emit(state.copyWith(
        status: PostStatus.failure,
        errorMessage: failure.message,
      )),
          (post) {
        final updatedPosts = [post, ...state.posts];
        emit(state.copyWith(
          status: PostStatus.success,
          posts: updatedPosts,
          currentPost: post,
        ));

        postSyncService.notifyPostUpdated(
          PostUpdate(
            postId: post.id,
            type: PostUpdateType.create,
            updatedPost: post,
          ),
        );
      },
    );
  }

  // === –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø–æ—Å—Ç–æ–≤ ===
  Future<void> _onGetPosts(
      GetPostsEvent event,
      Emitter<PostState> emit,
      ) async {
    emit(state.copyWith(status: PostStatus.loading, errorMessage: null));

    final result = await postRepository.getPosts(
      universityId: event.universityId,
      authorId: event.authorId,
      sortBy: event.sortBy,
      sector: event.sector,
      facultyId: event.facultyId,
      page: event.page,
      limit: event.limit,
    );

    result.fold(
          (failure) => emit(state.copyWith(
        status: PostStatus.failure,
        errorMessage: failure.message,
      )),
          (data) {
        final posts = data;
        final updatedPosts = event.page == 1 ? posts : [...state.posts, ...posts];

        // –ü—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫
        final newPage = event.page == 1 ? 2 : state.postsPage + 1;

        emit(state.copyWith(
          status: PostStatus.success,
          posts: updatedPosts,
          postsPage: newPage,
          postsLastPage: data.length < event.limit,
        ));
      },
    );
  }

  // === –ü–æ–ª—É—á–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –ø–æ—Å—Ç–∞ ===
  Future<void> _onGetPost(
      GetPostEvent event,
      Emitter<PostState> emit,
      ) async {
    emit(state.copyWith(status: PostStatus.loading, errorMessage: null));

    final result = await postRepository.getPost(event.postId);

    result.fold(
          (failure) => emit(state.copyWith(
        status: PostStatus.failure,
        errorMessage: failure.message,
      )),
          (post) => emit(state.copyWith(
        status: PostStatus.success,
        currentPost: post,
      )),
    );
  }

  // === –£–¥–∞–ª–µ–Ω–∏–µ –ø–æ—Å—Ç–∞ ===
  Future<void> _onDeletePost(
      DeletePostEvent event,
      Emitter<PostState> emit,
      ) async {
    emit(state.copyWith(status: PostStatus.loading, errorMessage: null));

    final result = await postRepository.deletePost(event.postId);

    result.fold(
          (failure) => emit(state.copyWith(
        status: PostStatus.failure,
        errorMessage: failure.message,
      )),
          (_) {
        final updatedPosts =
        state.posts.where((post) => post.id != event.postId).toList();

        emit(state.copyWith(
          status: PostStatus.deleted,
          posts: updatedPosts,
          currentPost:
          state.currentPost?.id == event.postId ? null : state.currentPost,
        ));
        postSyncService.notifyPostUpdated(
          PostUpdate(
            postId: event.postId,
            type: PostUpdateType.delete,
          ),
        );
      },
    );
  }

  // === –õ–∞–π–∫ –ø–æ—Å—Ç–∞ ===
  Future<void> _onToggleLike(
      ToggleLikeEvent event,
      Emitter<PostState> emit,
      ) async {
    final postIndex = state.posts.indexWhere((p) => p.id == event.postId);

    List<PostModel>? updatedPosts;
    PostModel? optimisticPost;

    if (postIndex != -1) {
      final post = state.posts[postIndex];
      final newIsLiked = !post.isLikedByCurrentUser;
      final newLikesCount =
      newIsLiked ? post.likesCount + 1 : post.likesCount - 1;

      optimisticPost = post.copyWith(
        isLikedByCurrentUser: newIsLiked,
        likesCount: newLikesCount,
      );

      updatedPosts = List<PostModel>.from(state.posts);
      updatedPosts[postIndex] = optimisticPost;
    }

    PostModel? updatedCurrentPost = state.currentPost;
    if (state.currentPost?.id == event.postId) {
      final newIsLiked = !state.currentPost!.isLikedByCurrentUser;
      final newLikesCount = newIsLiked
          ? state.currentPost!.likesCount + 1
          : state.currentPost!.likesCount - 1;

      updatedCurrentPost = state.currentPost!.copyWith(
        isLikedByCurrentUser: newIsLiked,
        likesCount: newLikesCount,
      );
      optimisticPost ??= updatedCurrentPost;
    }

    emit(state.copyWith(
      posts: updatedPosts ?? state.posts,
      currentPost: updatedCurrentPost,
    ));

    final result = await likeRepository.toggleLike(event.postId);

    result.fold(
          (failure) {
        // –û—Ç–∫–∞—Ç
        List<PostModel>? revertedPosts;
        if (postIndex != -1) {
          final post = state.posts[postIndex];
          final revertedPost = post.copyWith(
            isLikedByCurrentUser: !post.isLikedByCurrentUser,
            likesCount: post.isLikedByCurrentUser
                ? post.likesCount - 1
                : post.likesCount + 1,
          );

          revertedPosts = List<PostModel>.from(state.posts);
          revertedPosts[postIndex] = revertedPost;
        }

        PostModel? revertedCurrentPost = state.currentPost;
        if (state.currentPost?.id == event.postId) {
          revertedCurrentPost = state.currentPost!.copyWith(
            isLikedByCurrentUser: !state.currentPost!.isLikedByCurrentUser,
            likesCount: state.currentPost!.isLikedByCurrentUser
                ? state.currentPost!.likesCount - 1
                : state.currentPost!.likesCount + 1,
          );
        }

        emit(state.copyWith(
          posts: revertedPosts ?? state.posts,
          currentPost: revertedCurrentPost,
        ));
      },
          (response) {
        List<PostModel>? syncedPosts;
        PostModel? syncedPost;

        if (postIndex != -1) {
          final post = state.posts[postIndex];
          syncedPost = post.copyWith(
            likesCount: response.likesCount,
            isLikedByCurrentUser: response.isLiked,
          );

          syncedPosts = List<PostModel>.from(state.posts);
          syncedPosts[postIndex] = syncedPost;
        }

        PostModel? syncedCurrentPost = state.currentPost;
        if (state.currentPost?.id == event.postId) {
          syncedCurrentPost = state.currentPost!.copyWith(
            likesCount: response.likesCount,
            isLikedByCurrentUser: response.isLiked,
          );
          syncedPost ??= syncedCurrentPost;
        }

        emit(state.copyWith(
          posts: syncedPosts ?? state.posts,
          currentPost: syncedCurrentPost,
        ));

        if (syncedPost != null) {
          postSyncService.notifyPostLiked(event.postId, syncedPost);
        }
      },
    );
  }

  // === –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ ===
  void _onSyncPostUpdate(
      SyncPostUpdateEvent event,
      Emitter<PostState> emit,
      ) {
    final update = event.update;
    print(
      'PostBloc: Processing sync update - type: ${update.type}, postId: ${update.postId}',
    );

    switch (update.type) {
      case PostUpdateType.create:
        if (update.updatedPost != null) {
          final exists = state.posts.any((p) => p.id == update.postId);
          if (!exists) {
            final updatedPosts = [update.updatedPost!, ...state.posts];
            emit(state.copyWith(posts: updatedPosts));
          }
        }
        break;

      case PostUpdateType.delete:
        final updatedPosts =
        state.posts.where((post) => post.id != update.postId).toList();
        emit(state.copyWith(
          posts: updatedPosts,
          currentPost:
          state.currentPost?.id == update.postId ? null : state.currentPost,
        ));
        break;

      case PostUpdateType.like:
        if (update.updatedPost != null) {
          _updatePostInLists(emit, update.postId, update.updatedPost!);
        }
        break;

      case PostUpdateType.comment:
        final postIndex = state.posts.indexWhere((p) => p.id == update.postId);
        PostModel? updatedPost;

        if (postIndex != -1) {
          final post = state.posts[postIndex];
          int newCount = post.commentsCount;

          // ‚úÖ –ù–æ–≤—ã–π —Å–ø–æ—Å–æ–±: commentDelta
          if (update.commentDelta != null) {
            newCount += update.commentDelta!;
          }
          // ‚úÖ –°—Ç–∞—Ä—ã–π —Å–ø–æ—Å–æ–±: newCommentsCount (–∞–±—Å–æ–ª—é—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ)
          else if (update.newCommentsCount != null) {
            newCount = update.newCommentsCount!;
          }

          // –ë–µ–∑ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª
          newCount = newCount < 0 ? 0 : newCount;

          updatedPost = post.copyWith(commentsCount: newCount);

          final updatedPosts = List<PostModel>.from(state.posts);
          updatedPosts[postIndex] = updatedPost;

          emit(state.copyWith(
            posts: updatedPosts,
            currentPost: state.currentPost?.id == update.postId
                ? updatedPost
                : state.currentPost,
          ));
        } else if (state.currentPost?.id == update.postId) {
          int newCount = state.currentPost!.commentsCount;

          if (update.commentDelta != null) {
            newCount += update.commentDelta!;
          } else if (update.newCommentsCount != null) {
            newCount = update.newCommentsCount!;
          }

          newCount = newCount < 0 ? 0 : newCount;

          final updatedCurrentPost =
          state.currentPost!.copyWith(commentsCount: newCount);
          emit(state.copyWith(currentPost: updatedCurrentPost));
        }
        break;

      case PostUpdateType.edit:
        if (update.updatedPost != null) {
          _updatePostInLists(emit, update.postId, update.updatedPost!);
        }
        break;
    }
  }

  void _updatePostInLists(
      Emitter<PostState> emit,
      String postId,
      PostModel updatedPost,
      ) {
    final index = state.posts.indexWhere((p) => p.id == postId);

    List<PostModel>? updatedPosts;
    if (index != -1) {
      updatedPosts = List<PostModel>.from(state.posts);
      updatedPosts[index] = updatedPost;
    }

    final updatedCurrentPost =
    state.currentPost?.id == postId ? updatedPost : state.currentPost;

    emit(state.copyWith(
      posts: updatedPosts ?? state.posts,
      currentPost: updatedCurrentPost,
    ));
  }

  @override
  Future<void> close() {
    _syncSubscription?.cancel();
    return super.close();
  }
}
import 'dart:io';
import 'package:unitalk/core/services/post_syns_service.dart';
import 'package:unitalk/features/university/data/models/university_model.dart';

abstract class PostEvent {
  const PostEvent();
}

class InitializeFeedEvent extends PostEvent {
  final UniversityModel university;

  const InitializeFeedEvent(this.university);
}

class ChangeUniversityEvent extends PostEvent {
  final UniversityModel university;

  const ChangeUniversityEvent(this.university);
}

class RefreshFeedEvent extends PostEvent {
  const RefreshFeedEvent();
}

class CreatePostEvent extends PostEvent {
  final String content;
  final bool isAnonymous;
  final File? mediaFile; // –ò–∑–º–µ–Ω–µ–Ω–æ —Å imageFile –Ω–∞ mediaFile

  const CreatePostEvent({
    required this.content,
    required this.isAnonymous,
    this.mediaFile,
  });
}

class GetPostsEvent extends PostEvent {
  final String? universityId;
  final String? authorId;
  final String sortBy;
  final String? sector;
  final String? facultyId;
  final int page;
  final int limit;

  const GetPostsEvent({
    this.universityId,
    this.authorId,
    this.sortBy = 'new',
    this.sector,
    this.facultyId,
    this.page = 1,
    this.limit = 20,
  });

  @override
  List<Object?> get props => [
    universityId,
    authorId,
    sortBy,
    sector,
    facultyId,
    page,
    limit
  ];
}

class GetPostEvent extends PostEvent {
  final String postId;

  const GetPostEvent(this.postId);
}

class DeletePostEvent extends PostEvent {
  final String postId;

  const DeletePostEvent(this.postId);
}

class ToggleLikeEvent extends PostEvent {
  final String postId;

  const ToggleLikeEvent(this.postId);
}

class SyncPostUpdateEvent extends PostEvent {
  final PostUpdate update;

  const SyncPostUpdateEvent(this.update);
}import 'package:equatable/equatable.dart';
import 'package:unitalk/features/feed/data/model/post_model.dart';
import 'package:unitalk/features/university/data/models/university_model.dart';

enum PostStatus { initial, loading, success, failure, deleted }

class PostState extends Equatable {
  final PostStatus status;
  final List<PostModel> posts;
  final int postsPage;
  final bool postsLastPage;
  final PostModel? currentPost;
  final String? errorMessage;
  final String? uploadUrl;

  // –ù–æ–≤—ã–µ –ø–æ–ª—è –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ª–µ–Ω—Ç–æ–π
  final UniversityModel? selectedUniversity;
  final bool isLoadingMore;
  final bool isRefreshing;

  const PostState._({
    required this.status,
    this.posts = const [],
    required this.postsPage,
    required this.postsLastPage,
    this.currentPost,
    this.errorMessage,
    this.uploadUrl,
    this.selectedUniversity,
    this.isLoadingMore = false,
    this.isRefreshing = false,
  });

  factory PostState.initial() => const PostState._(
    status: PostStatus.initial,
    posts: [],
    postsLastPage: false,
    postsPage: 1,
    isLoadingMore: false,
    isRefreshing: false,
  );

  PostState copyWith({
    PostStatus? status,
    List<PostModel>? posts,
    int? postsPage,
    bool? postsLastPage,
    PostModel? currentPost,
    String? errorMessage,
    String? uploadUrl,
    UniversityModel? selectedUniversity,
    bool? isLoadingMore,
    bool? isRefreshing,
  }) {
    return PostState._(
      status: status ?? this.status,
      posts: posts ?? this.posts,
      postsPage: postsPage ?? this.postsPage,
      postsLastPage: postsLastPage ?? this.postsLastPage,
      currentPost: currentPost ?? this.currentPost,
      errorMessage: errorMessage ?? this.errorMessage,
      uploadUrl: uploadUrl ?? this.uploadUrl,
      selectedUniversity: selectedUniversity ?? this.selectedUniversity,
      isLoadingMore: isLoadingMore ?? this.isLoadingMore,
      isRefreshing: isRefreshing ?? this.isRefreshing,
    );
  }

  // –ì–µ—Ç—Ç–µ—Ä—ã –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
  bool get hasSelectedUniversity => selectedUniversity != null;
  bool get isEmpty => posts.isEmpty;
  bool get isLoading => status == PostStatus.loading && !isLoadingMore && !isRefreshing;
  bool get hasError => status == PostStatus.failure;

  @override
  List<Object?> get props => [
    status,
    posts,
    postsPage,
    postsLastPage,
    currentPost,
    errorMessage,
    uploadUrl,
    selectedUniversity,
    isLoadingMore,
    isRefreshing,
  ];
}import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/features/search/domain/repository/user_search_repository.dart';

import 'user_search_event.dart';
import 'user_search_state.dart';

class UserSearchBloc extends Bloc<UserSearchEvent, UserSearchState> {
  final UserSearchRepository repository;

  UserSearchBloc({required this.repository}) : super(UserSearchState.initial()) {
    on<SearchUsersEvent>(_onSearchUsers);
    on<ClearSearchEvent>(_onClearSearch);
  }

  Future<void> _onSearchUsers(
      SearchUsersEvent event,
      Emitter<UserSearchState> emit,
      ) async {
    // –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–∞
    if (event.query.trim().length < 2) {
      emit(state.copyWith(
        status: UserSearchStatus.failure,
        errorMessage: 'Search query must be at least 2 characters',
      ));
      return;
    }

    // –ï—Å–ª–∏ –∑–∞–≥—Ä—É–∂–∞–µ–º –±–æ–ª—å—à–µ –¥–∞–Ω–Ω—ã—Ö
    if (event.loadMore) {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É–∂–µ –µ—Å—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏ –µ—Å—Ç—å –µ—â–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏
      if (state.users.isEmpty || !state.hasMore) {
        return;
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É–∂–µ –Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
      if (state.status == UserSearchStatus.loadingMore) {
        return;
      }

      emit(state.copyWith(status: UserSearchStatus.loadingMore));
    } else {
      // –ù–æ–≤—ã–π –ø–æ–∏—Å–∫ - —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      emit(state.copyWith(
        status: UserSearchStatus.loading,
        users: [],
        offset: 0,
        total: 0,
        hasMore: false,
        errorMessage: null,
      ));
    }

    // –í—ã—á–∏—Å–ª—è–µ–º offset - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    final offset = event.loadMore ? state.users.length : 0;

    try {
      // –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å
      final result = await repository.searchUsers(
        query: event.query,
        facultyId: event.facultyId,
        universityId: event.universityId,
        sector: event.sector,
        limit: state.limit,
        offset: offset,
      );

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
      result.fold(
            (failure) {
          emit(state.copyWith(
            status: UserSearchStatus.failure,
            errorMessage: failure.message,
          ));
        },
            (response) {
              print(response.total.toString()
                  + 'fsdfds');
          // –û–±—ä–µ–¥–∏–Ω—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –µ—Å–ª–∏ —ç—Ç–æ loadMore
          final updatedUsers = event.loadMore
              ? [...state.users, ...response.users]
              : response.users;

          // –í—ã—á–∏—Å–ª—è–µ–º hasMore –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞
          final hasMore = updatedUsers.length < response.total;

          emit(state.copyWith(
            status: UserSearchStatus.success,
            users: updatedUsers,
            query: event.query,
            total: response.total,
            offset: updatedUsers.length, // –û–±–Ω–æ–≤–ª—è–µ–º offset –Ω–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö
            limit: response.limit,
            hasMore: hasMore,
            errorMessage: null,
          ));
        },
      );
    } catch (e) {
      emit(state.copyWith(
        status: UserSearchStatus.failure,
        errorMessage: 'An unexpected error occurred: ${e.toString()}',
      ));
    }
  }

  void _onClearSearch(
      ClearSearchEvent event,
      Emitter<UserSearchState> emit,
      ) {
    emit(UserSearchState.initial());
  }
}abstract class UserSearchEvent {}

class SearchUsersEvent extends UserSearchEvent {
  final String query;
  final String? facultyId;
  final String? universityId;
  final String? sector;
  final bool loadMore;

  SearchUsersEvent({
    required this.query,
    this.facultyId,
    this.universityId,
    this.sector,
    this.loadMore = false,
  });
}

class ClearSearchEvent extends UserSearchEvent {}import 'package:unitalk/features/auth/data/model/user_model.dart';

enum UserSearchStatus { initial, loading, success, failure, loadingMore }

class UserSearchState {
  final UserSearchStatus status;
  final List<UserModel> users;
  final String? query;
  final int total;
  final int offset;
  final int limit;
  final bool hasMore;
  final String? errorMessage;

  UserSearchState({
    required this.status,
    required this.users,
    this.query,
    required this.total,
    required this.offset,
    required this.limit,
    required this.hasMore,
    this.errorMessage,
  });

  factory UserSearchState.initial() {
    return UserSearchState(
      status: UserSearchStatus.initial,
      users: [],
      total: 0,
      offset: 0,
      limit: 20,
      hasMore: false,
    );
  }

  UserSearchState copyWith({
    UserSearchStatus? status,
    List<UserModel>? users,
    String? query,
    int? total,
    int? offset,
    int? limit,
    bool? hasMore,
    String? errorMessage,
  }) {
    return UserSearchState(
      status: status ?? this.status,
      users: users ?? this.users,
      query: query ?? this.query,
      total: total ?? this.total,
      offset: offset ?? this.offset,
      limit: limit ?? this.limit,
      hasMore: hasMore ?? this.hasMore,
      errorMessage: errorMessage,
    );
  }
}import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:unitalk/core/ui/common/empty_state_widget.dart';
import 'package:unitalk/core/ui/common/user_avatar.dart';
import 'package:unitalk/core/ui/common/user_meta_info.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';
import 'package:unitalk/features/search/presentation/bloc/user_search_bloc.dart';
import 'package:unitalk/features/search/presentation/bloc/user_search_event.dart';
import 'package:unitalk/features/search/presentation/bloc/user_search_state.dart';
import 'package:unitalk/l10n/app_localizations.dart';

class UserSearchPage extends StatefulWidget {
  const UserSearchPage({Key? key}) : super(key: key);

  @override
  State<UserSearchPage> createState() => _UserSearchPageState();
}

class _UserSearchPageState extends State<UserSearchPage> {
  final TextEditingController _searchController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  final FocusNode _searchFocus = FocusNode();

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _searchFocus.requestFocus();
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    _scrollController.dispose();
    _searchFocus.dispose();
    super.dispose();
  }

  // –ó–∞–º–µ–Ω–∏—Ç–µ –º–µ—Ç–æ–¥ _onScroll –≤ UserSearchPage –Ω–∞ —ç—Ç–æ—Ç:

  void _onScroll() {
    if (_isBottom) {
      final state = context.read<UserSearchBloc>().state;

      // –î–æ–±–∞–≤–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
      if (state.hasMore &&
          state.status != UserSearchStatus.loadingMore &&
          state.status != UserSearchStatus.loading) {

        // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        print('Loading more users. Current count: ${state.users.length}, Total: ${state.total}');

        context.read<UserSearchBloc>().add(SearchUsersEvent(
          query: _searchController.text,
          loadMore: true,
        ));
      }
    }
  }

  bool get _isBottom {
    if (!_scrollController.hasClients) return false;
    final maxScroll = _scrollController.position.maxScrollExtent;
    final currentScroll = _scrollController.offset;
    // –ú–æ–∂–µ—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –ø–æ—Ä–æ–≥ —Å 0.9 –Ω–∞ 0.8 –¥–ª—è –±–æ–ª–µ–µ —Ä–∞–Ω–Ω–µ–π –∑–∞–≥—Ä—É–∑–∫–∏
    return currentScroll >= (maxScroll * 0.85);
  }


  void _onSearchChanged(String value) {
    if (value.trim().length >= 2) {
      context.read<UserSearchBloc>().add(SearchUsersEvent(query: value));
    } else if (value.trim().isEmpty) {
      context.read<UserSearchBloc>().add(ClearSearchEvent());
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: theme.scaffoldBackgroundColor,
        surfaceTintColor: theme.scaffoldBackgroundColor,
        title: Text(
          l10n.searchUsers,
          style: TextStyle(
            color: theme.textTheme.titleLarge?.color,
            fontSize: 20,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      body: Column(
        children: [
          _buildSearchBar(l10n),
          Expanded(child: _buildBody(l10n)),
        ],
      ),
    );
  }

  Widget _buildSearchBar(AppLocalizations l10n) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Container(
      padding: const EdgeInsets.fromLTRB(16, 8, 16, 16),
      decoration: BoxDecoration(
        color: theme.scaffoldBackgroundColor,
        border: Border(
          bottom: BorderSide(
            color: theme.dividerColor.withOpacity(0.1),
          ),
        ),
      ),
      child: TextField(
        controller: _searchController,
        focusNode: _searchFocus,
        onChanged: _onSearchChanged,
        style: TextStyle(color: theme.textTheme.bodyLarge?.color),
        decoration: InputDecoration(
          hintText: l10n.searchUsersByName,
          hintStyle: TextStyle(
            color: theme.textTheme.bodySmall?.color?.withOpacity(0.4),
            fontSize: 15,
          ),
          prefixIcon: Icon(
            Icons.search,
            color: theme.textTheme.bodySmall?.color?.withOpacity(0.4),
          ),
          suffixIcon: _searchController.text.isNotEmpty
              ? IconButton(
            icon: Icon(
              Icons.clear,
              color: theme.textTheme.bodySmall?.color?.withOpacity(0.4),
            ),
            onPressed: () {
              _searchController.clear();
              _onSearchChanged('');
            },
          )
              : null,
          filled: true,
          fillColor: isDark
              ? theme.cardColor.withOpacity(0.3)
              : theme.textTheme.bodySmall?.color?.withOpacity(0.05),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide.none,
          ),
          contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        ),
      ),
    );
  }

  Widget _buildBody(AppLocalizations l10n) {
    final theme = Theme.of(context);

    return BlocBuilder<UserSearchBloc, UserSearchState>(
      builder: (context, state) {
        if (state.status == UserSearchStatus.initial) {
          return EmptyStateWidget(
            icon: Icons.search,
            title: l10n.searchForUsers,
            subtitle: l10n.typeToStartSearching,
          );
        }

        if (state.status == UserSearchStatus.loading) {
          return Center(
            child: CircularProgressIndicator(
              strokeWidth: 2,
              color: theme.primaryColor,
            ),
          );
        }

        if (state.status == UserSearchStatus.failure) {
          return EmptyStateWidget(
            icon: Icons.error_outline,
            title: state.errorMessage ?? l10n.anErrorOccurred,
            subtitle: null,
          );
        }

        if (state.users.isEmpty) {
          return EmptyStateWidget(
            icon: Icons.person_off_outlined,
            title: l10n.noUsersFound,
            subtitle: l10n.tryDifferentName,
          );
        }

        print( 'afasdas ${state.total}');
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
              child: Text(
                l10n.usersFound(state.total),
                style: TextStyle(
                  fontSize: 13,
                  color: theme.textTheme.bodySmall?.color?.withOpacity(0.6),
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
            Expanded(
              child: ListView.separated(
                controller: _scrollController,
                padding: const EdgeInsets.only(bottom: 16),
                itemCount: state.users.length + (state.hasMore ? 1 : 0),
                separatorBuilder: (context, index) => Divider(
                  height: 1,
                  color: theme.dividerColor.withOpacity(0.1),
                  indent: 76,
                ),
                itemBuilder: (context, index) {
                  if (index >= state.users.length) {
                    return Padding(
                      padding: const EdgeInsets.all(16),
                      child: Center(
                        child: SizedBox(
                          width: 24,
                          height: 24,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: theme.primaryColor,
                          ),
                        ),
                      ),
                    );
                  }

                  final user = state.users[index];
                  return _buildUserTile(user);
                },
              ),
            ),
          ],
        );
      },
    );
  }

  Widget _buildUserTile(UserModel user) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: () {
        context.push('/user/${user.id}');
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            UserAvatar(
              photoUrl: user.photoUrl,
              firstName: user.firstName,
              lastName: user.lastName,
              size: 48,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Flexible(
                        child: Text(
                          '${user.firstName ?? ''} ${user.lastName ?? ''}'.trim(),
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w600,
                            color: theme.textTheme.titleLarge?.color,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                      if (user.isVerified == true) ...[
                        const SizedBox(width: 4),
                        Icon(
                          Icons.verified,
                          size: 16,
                          color: theme.primaryColor,
                        ),
                      ],
                    ],
                  ),
                  if (user.university != null || user.faculty != null) ...[
                    const SizedBox(height: 4),
                    UserMetaInfo(
                      faculty: user.faculty?.getLocalizedName(
                        Localizations.localeOf(context).languageCode,
                      ),
                      sector: user.sector,
                      fontSize: 13,
                    ),
                  ],
                ],
              ),
            ),
            Icon(
              Icons.chevron_right,
              color: theme.textTheme.bodySmall?.color?.withOpacity(0.4),
              size: 20,
            ),
          ],
        ),
      ),
    );
  }
}import 'package:dio/dio.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:pretty_dio_logger/pretty_dio_logger.dart';

class DioClient {
  static const String baseUrl = 'http://127.0.0.1:5003/api';

  static Dio createDio({bool withAuthInterceptor = false, FirebaseAuth? firebaseAuth}) {
    final dio = Dio(
      BaseOptions(
        baseUrl: baseUrl,
        connectTimeout: const Duration(seconds: 30),
        receiveTimeout: const Duration(seconds: 30),
        headers: {
          'Content-Type': 'application/json',
        },
      ),
    );

    dio.interceptors.add(PrettyDioLogger(
      requestBody: true,
      error: true,
      request: true,
      requestHeader: true,
      responseHeader: true,
      responseBody: true,
    ));

    if (withAuthInterceptor && firebaseAuth != null) {
      dio.interceptors.add(AuthInterceptor(firebaseAuth));
    }

    return dio;
  }
}

class AuthInterceptor extends Interceptor {
  final FirebaseAuth firebaseAuth;

  AuthInterceptor(this.firebaseAuth);

  @override
  Future<void> onRequest(
      RequestOptions options,
      RequestInterceptorHandler handler,
      ) async {
    try {
      final user = firebaseAuth.currentUser;
      if (user != null) {
        final token = await user.getIdToken();
        if (token != null) {
          options.headers['Authorization'] = 'Bearer $token';
        }
      }
      handler.next(options);
    } catch (e) {
      handler.reject(
        DioException(
          requestOptions: options,
          error: 'Failed to get auth token: $e',
        ),
      );
    }
  }

}import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:dio/dio.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:unitalk/core/api/api_client.dart';
import 'package:unitalk/core/services/activity_log_service.dart';
import 'package:unitalk/core/services/chat_socker_service.dart';
import 'package:unitalk/core/services/post_syns_service.dart';
import 'package:unitalk/core/theme/bloc/theme_bloc.dart';
import 'package:unitalk/core/theme/data/repository/theme_repository_impl.dart';
import 'package:unitalk/core/theme/domain/repository/theme_repository.dart';
import 'package:unitalk/features/auth/data/datasource/auth_remote_data_source.dart';
import 'package:unitalk/features/auth/data/datasource/user_remote_datasource.dart';
import 'package:unitalk/features/auth/data/datasource/verefication_remote_datasource.dart';
import 'package:unitalk/features/auth/data/repository/auth_repository_impl.dart';
import 'package:unitalk/features/auth/data/repository/user_repository_impl.dart';
import 'package:unitalk/features/auth/data/repository/verification_repository_impl.dart';
import 'package:unitalk/features/auth/domain/repository/auth_repository.dart';
import 'package:unitalk/features/auth/domain/repository/user_repository.dart';
import 'package:unitalk/features/auth/domain/repository/verification_repository.dart';
import 'package:unitalk/features/auth/presentation/bloc/auth_bloc.dart';
import 'package:unitalk/features/block/data/datasource/block_remote_datasource.dart';
import 'package:unitalk/features/block/data/repository/block_repository_impl.dart';
import 'package:unitalk/features/block/domain/repository/block_repository.dart';
import 'package:unitalk/features/block/presentation/bloc/block_bloc.dart';
import 'package:unitalk/features/chat/data/datasource/chat_remote_datasource.dart';
import 'package:unitalk/features/chat/data/repository/chat_repository_impl.dart';
import 'package:unitalk/features/chat/domain/repository/chat_repository.dart';
import 'package:unitalk/features/chat/presentation/bloc/chat_bloc.dart';
import 'package:unitalk/features/feed/data/datasource/announcement_remote_datasource.dart';
import 'package:unitalk/features/feed/data/datasource/comment_remote_datasource.dart';
import 'package:unitalk/features/feed/data/datasource/like_remote_datasource.dart';
import 'package:unitalk/features/feed/data/datasource/post_remote_datasource.dart';
import 'package:unitalk/features/feed/data/repository/announcement_repository_impl.dart';
import 'package:unitalk/features/feed/data/repository/comment_repository_impl.dart';
import 'package:unitalk/features/feed/data/repository/like_repository_impl.dart';
import 'package:unitalk/features/feed/data/repository/post_repository_impl.dart';
import 'package:unitalk/features/feed/domain/repository/announcement_repository.dart';
import 'package:unitalk/features/feed/domain/repository/comment_repository.dart';
import 'package:unitalk/features/feed/domain/repository/like_repository.dart';
import 'package:unitalk/features/feed/domain/repository/posts_repository.dart';
import 'package:unitalk/features/feed/presentation/bloc/announcement/announcement_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/comment/comment_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/comment_likers/comment_likers_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/like/like_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/post/post_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/post_likers/post_likers_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/replies/replies_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/user_profile/user_profile_bloc.dart';
import 'package:unitalk/features/notifications/data/notifcation_remote_datasource.dart';
import 'package:unitalk/features/notifications/data/notifcation_repository_impl.dart';
import 'package:unitalk/features/notifications/domain/notifcation_repository.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_bloc.dart';
import 'package:unitalk/features/report/data/repository/report_repository_impl.dart';
import 'package:unitalk/features/report/domain/repository/report_repository.dart';
import 'package:unitalk/features/report/presentation/bloc/report_bloc.dart';
import 'package:unitalk/features/search/data/datasource/user_search_remote_datasource.dart';
import 'package:unitalk/features/search/data/repository/user_search_repository_impl.dart';
import 'package:unitalk/features/search/domain/repository/user_search_repository.dart';
import 'package:unitalk/features/search/presentation/bloc/user_search_bloc.dart';
import 'package:unitalk/features/support/data/datasource/support_remote_datasource.dart';
import 'package:unitalk/features/support/data/repository/support_repository_impl.dart';
import 'package:unitalk/features/support/domain/repository/support_repository.dart';
import 'package:unitalk/features/support/presentation/bloc/support_bloc.dart';
import 'package:unitalk/features/university/data/data_sources/university_remote_datasource.dart';
import 'package:unitalk/features/university/data/repositories/university_repository_impl.dart';
import 'package:unitalk/features/university/domain/repositories/university_repository.dart';
import 'package:unitalk/features/university/presentation/manager/university_bloc.dart';
import 'package:unitalk/l10n/bloc/locale_cubit.dart';
import 'package:unitalk/l10n/data/repository/local_repository_impl.dart';
import 'package:unitalk/l10n/domain/repository/locale_repository.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:get_it/get_it.dart';
import 'package:google_sign_in/google_sign_in.dart';

import '../../features/report/data/datasource/report_remote_datasource.dart' show ReportRemoteDataSource;

final sl = GetIt.instance;

Future<void> initDependencies() async {
  // Firebase Services


  sl.registerLazySingleton(() => FirebaseAuth.instance);
  sl.registerLazySingleton(() => GoogleSignIn.instance);
  sl.registerLazySingleton(() => FirebaseFirestore.instance);
  sl.registerLazySingleton(() => FirebaseStorage.instance);


  sl.registerLazySingleton(() => PostSyncService());
  sl.registerLazySingleton<ActivityLoggerService>(
        () => ActivityLoggerService( sl(instanceName: 'dioAuth')),
  );

  sl.registerLazySingleton(() => ChatSocketService(baseUrl: 'http://35.198.109.53'));

  // Dio clients
  sl.registerLazySingleton<Dio>(
        () => DioClient.createDio(withAuthInterceptor: false),
    instanceName: 'dioPublic',
  );

  sl.registerLazySingleton<Dio>(
        () => DioClient.createDio(
      withAuthInterceptor: true,
      firebaseAuth: sl<FirebaseAuth>(),
    ),
    instanceName: 'dioAuth',
  );

  // DataSources - Auth (–±–µ–∑ —Ç–æ–∫–µ–Ω–∞)
  sl.registerLazySingleton<AuthRemoteDataSource>(
        () => AuthRemoteDataSource(
      firebaseAuth: sl(),
      googleSignIn: sl(),
      dio: sl(instanceName: 'dioPublic'),
    ),
  );

  // DataSources - User (—Å —Ç–æ–∫–µ–Ω–æ–º)
  sl.registerLazySingleton<UserRemoteDataSource>(
        () => UserRemoteDataSource(
      dio: sl(instanceName: 'dioAuth'),
    ),
  );

  sl.registerLazySingleton<UniversityRemoteDataSource>(
        () => UniversityRemoteDataSource(
      dio: sl(instanceName: 'dioAuth'),
      firebaseAuth: sl(),
    ),
  );

  sl.registerLazySingleton<ChatRemoteDataSource>(
        () => ChatRemoteDataSource(
     dio: sl(instanceName: 'dioAuth'))
  );

  sl.registerLazySingleton<PostRemoteDataSource>(
        () => PostRemoteDataSource(dio:  sl(instanceName: 'dioAuth'),
    ),
  );

  sl.registerLazySingleton<LikeRemoteDataSource>(
        () => LikeRemoteDataSource(dio:  sl(instanceName: 'dioAuth'),
    ),
  );

  sl.registerLazySingleton<CommentRemoteDataSource>(
        () => CommentRemoteDataSource(dio:  sl(instanceName: 'dioAuth'),
    ),
  );

  sl.registerLazySingleton<VerificationRemoteDataSource>(
        () => VerificationRemoteDataSource(dio:  sl(instanceName: 'dioAuth',)
    ),
  );

  sl.registerLazySingleton<NotificationRemoteDataSource>(
        () => NotificationRemoteDataSource(dio:  sl(instanceName: 'dioAuth',)
    ),
  );

  sl.registerLazySingleton<UserSearchRemoteDataSource>(
        () => UserSearchRemoteDataSource(dio:  sl(instanceName: 'dioAuth',)
    ),
  );

  sl.registerLazySingleton<SupportRemoteDataSource>(
        () => SupportRemoteDataSource(dio:  sl(instanceName: 'dioAuth',)
    ),
  );

  sl.registerLazySingleton<AnnouncementRemoteDataSource>(
        () => AnnouncementRemoteDataSource(dio:  sl(instanceName: 'dioAuth',)
    ),
  );
  // Moderation - Block
  sl.registerFactory(() => BlockRemoteDataSource(dio:  sl(instanceName: 'dioAuth',)));
  sl.registerFactory<BlockRepository>(() => BlockRepositoryImpl(sl()));
  sl.registerFactory(() => BlockBloc(blockRepository: sl()));

// Moderation - Report
  sl.registerFactory(() => ReportRemoteDataSource(dio:  sl(instanceName: 'dioAuth',)));
  sl.registerFactory<ReportRepository>(() => ReportRepositoryImpl(sl()));
  sl.registerFactory(() => ReportBloc(reportRepository: sl()));

  // Repositories - Auth
  sl.registerLazySingleton<AuthRepository>(
        () => AuthRepositoryImpl(sl()),
  );

  // Repositories - User
  sl.registerLazySingleton<UserRepository>(
        () => UserRepositoryImpl(sl()),
  );

  // Repositories - Others
  sl.registerLazySingleton<ThemeRepository>(
        () => ThemeRepositoryImpl(),
  );
  sl.registerLazySingleton<ChatRepository>(
        () => ChatRepositoryImpl(sl()),
  );

  sl.registerLazySingleton<LocaleRepository>(
        () => LocaleRepositoryImpl(),
  );

  sl.registerLazySingleton<UniversityRepository>(
        () => UniversityRepositoryImpl(sl()),
  );

  sl.registerLazySingleton<PostRepository>(
        () => PostRepositoryImpl(sl()),
  );


  sl.registerLazySingleton<LikeRepository>(
        () => LikeRepositoryImpl(sl())
  );

  sl.registerLazySingleton<CommentRepository>(
          () => CommentRepositoryImpl(sl())
  );
  sl.registerLazySingleton<VerificationRepository>(
          () => VerificationRepositoryImpl(sl())
  );

  sl.registerLazySingleton<NotificationRepository>(
          () => NotificationRepositoryImpl(sl())
  );


  sl.registerLazySingleton<UserSearchRepository>(
          () => UserSearchRepositoryImpl(sl())
  );

  sl.registerLazySingleton<SupportRepository>(
          () => SupportRepositoryImpl(sl())
  );


  sl.registerLazySingleton<AnnouncementRepository>(
          () => AnnouncementRepositoryImpl(sl())
  );



  // Blocs / Cubits
  sl.registerSingleton( AuthBloc(
    authRepository: sl(),
    userRepository: sl(),
    verificationRepository: sl()
  ));
  sl.registerFactory(() => ThemeBloc(sl()));
  sl.registerFactory(() => LocaleCubit(sl(),sl()));
  sl.registerFactory(() => UniversityBloc(sl()));
  sl.registerFactory(() => SupportBloc(supportRepository: sl()));
  sl.registerFactory(() => LikeBloc(likeRepository: sl()));
  sl.registerFactory(() => PostLikersBloc(repository: sl()));
  sl.registerFactory(() => CommentLikersBloc(repository: sl()));
  sl.registerFactory<ChatBloc>(
        () => ChatBloc( chatRepository: sl<ChatRepository>(),socketService: sl()),
  );
  sl.registerFactory<PostBloc>(
        () => PostBloc(postRepository: sl(),likeRepository: sl(),postSyncService: sl()),
  );

  sl.registerFactory<CommentBloc>(
        () => CommentBloc(commentRepository: sl(), postSyncService: sl(),commentLikeRepository: sl()),
  );

  sl.registerFactory<UserProfileBloc>(
        () => UserProfileBloc(userRepository: sl()),
  );

  sl.registerFactory<NotificationBloc>(
        () => NotificationBloc(notificationRepository: sl()),
  );

  sl.registerFactory<UserSearchBloc>(
        () => UserSearchBloc(repository: sl()),
  );

  sl.registerFactory<RepliesBloc>(
        () => RepliesBloc(commentRepository: sl(),postSyncService: sl(),commentLikeRepository: sl()),
  );

  sl.registerFactory<AnnouncementBloc>(
        () => AnnouncementBloc(announcementRepository: sl()),
  );

}abstract class Failure {
  final String message;

  Failure({required this.message});
}

class AuthFailure extends Failure{
  AuthFailure({required super.message});
}

class ServerFailure extends Failure{
  ServerFailure({required super.message});

}
class NetworkFailure extends Failure{
  NetworkFailure({required super.message});

}import 'package:flutter/material.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

import 'user_avatar.dart';

class UserListTile extends StatelessWidget {
  final UserModel user;
  final String locale;
  final VoidCallback? onTap;
  final Widget? trailing;

  const UserListTile({
    super.key,
    required this.user,
    required this.locale,
    this.onTap,
    this.trailing,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            UserAvatar(
              photoUrl: user.photoUrl,
              firstName: user.firstName,
              lastName: user.lastName,
              size: 48,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Flexible(
                        child: Text(
                          '${user.firstName ?? ''} ${user.lastName ?? ''}'.trim(),
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w600,
                            color: theme.textTheme.titleLarge?.color,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                      if (user.isVerified == true) ...[
                        const SizedBox(width: 4),
                        Icon(
                          Icons.verified,
                          size: 16,
                          color: theme.primaryColor,
                        ),
                      ],
                    ],
                  ),
                  if (user.university != null || user.faculty != null) ...[
                    const SizedBox(height: 4),
                    Text(
                      _buildUserInfo(user, locale),
                      style: TextStyle(
                        fontSize: 13,
                        color: theme.textTheme.bodySmall?.color?.withOpacity(0.6),
                      ),
                      overflow: TextOverflow.ellipsis,
                      maxLines: 2,
                    ),
                  ],
                ],
              ),
            ),
            trailing ??
                Icon(
                  Icons.chevron_right,
                  color: theme.textTheme.bodySmall?.color?.withOpacity(0.4),
                  size: 20,
                ),
          ],
        ),
      ),
    );
  }

  String _buildUserInfo(UserModel user, String locale) {
    final parts = <String>[];

    if (user.faculty != null) {
      parts.add(user.faculty!.getLocalizedName(locale));
    }

    if (user.university != null) {
      parts.add(user.university!.getLocalizedName(locale));
    }

    if (user.sector != null) {
      parts.add(user.sector!.displayName);
    }

    return parts.join(' ‚Ä¢ ');
  }
}