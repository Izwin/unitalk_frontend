import 'package:json_annotation/json_annotation.dart';
part 'notification_settings_model.g.dart';
@JsonSerializable()
class NotificationSettingsModel {
  @JsonKey(name: '_id')
  final String id;
  final String userId;
  final bool enabled;
  final String? fcmToken;
  final bool newPosts;
  final bool newComments;
  final bool newLikes;
  final bool commentReplies;
  final bool mentions;
  final bool chatMessages;
  final bool chatMentions;
  final DateTime createdAt;
  final DateTime updatedAt;

  NotificationSettingsModel({
    required this.id,
    required this.userId,
    required this.enabled,
    this.fcmToken,
    required this.newPosts,
    required this.newComments,
    required this.newLikes,
    required this.commentReplies,
    required this.mentions,
    required this.chatMessages,
    required this.chatMentions,
    required this.createdAt,
    required this.updatedAt,
  });

  factory NotificationSettingsModel.fromJson(Map<String, dynamic> json) =>
      _$NotificationSettingsModelFromJson(json);

  Map<String, dynamic> toJson() => _$NotificationSettingsModelToJson(this);

  NotificationSettingsModel copyWith({
    String? id,
    String? userId,
    bool? enabled,
    String? fcmToken,
    bool? newPosts,
    bool? newComments,
    bool? newLikes,
    bool? commentReplies,
    bool? mentions,
    bool? chatMessages,
    bool? chatMentions,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return NotificationSettingsModel(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      enabled: enabled ?? this.enabled,
      fcmToken: fcmToken ?? this.fcmToken,
      newPosts: newPosts ?? this.newPosts,
      newComments: newComments ?? this.newComments,
      newLikes: newLikes ?? this.newLikes,
      commentReplies: commentReplies ?? this.commentReplies,
      mentions: mentions ?? this.mentions,
      chatMessages: chatMessages ?? this.chatMessages,
      chatMentions: chatMentions ?? this.chatMentions,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/core/ui/common/error_state_widget.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_bloc.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_event.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_state.dart';
import 'package:unitalk/l10n/app_localizations.dart';

class NotificationSettingsPage extends StatelessWidget {
  const NotificationSettingsPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      appBar: AppBar(
        backgroundColor: theme.scaffoldBackgroundColor,
        elevation: 0,
        centerTitle: false,
        title: Text(
          l10n.notificationSettings,
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.w600,
            letterSpacing: -0.5,
          ),
        ),
      ),
      body: Column(
        children: [
          Container(
            height: 1,
            color: theme.colorScheme.onSurface.withOpacity(0.08),
          ),
          Expanded(
            child: BlocBuilder<NotificationBloc, NotificationState>(
              builder: (context, state) {
                if (state.status == NotificationStatus.loading) {
                  return const Center(child: CircularProgressIndicator());
                }

                if (state.settings == null) {
                  return ErrorStateWidget(
                    message: l10n.errorLoadingSettings,
                    onRetry: () {
                      context
                          .read<NotificationBloc>()
                          .add(GetNotificationSettingsEvent());
                    },
                    retryButtonText: l10n.retry,
                  );
                }

                final settings = state.settings!;

                return ListView(
                  padding: const EdgeInsets.symmetric(vertical: 8),
                  children: [
                    // Master switch
                    Container(
                      margin: const EdgeInsets.fromLTRB(20, 16, 20, 8),
                      padding: const EdgeInsets.all(20),
                      decoration: BoxDecoration(
                        color: settings.enabled
                            ? theme.colorScheme.primary.withOpacity(0.08)
                            : theme.colorScheme.onSurface.withOpacity(0.04),
                        borderRadius: BorderRadius.circular(16),
                        border: Border.all(
                          color: settings.enabled
                              ? theme.colorScheme.primary.withOpacity(0.2)
                              : theme.colorScheme.onSurface.withOpacity(0.08),
                          width: 1,
                        ),
                      ),
                      child: Row(
                        children: [
                          Container(
                            width: 44,
                            height: 44,
                            decoration: BoxDecoration(
                              color: settings.enabled
                                  ? theme.colorScheme.primary
                                  : theme.colorScheme.onSurface.withOpacity(0.1),
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: Icon(
                              settings.enabled
                                  ? Icons.notifications_active
                                  : Icons.notifications_off_outlined,
                              color: settings.enabled
                                  ? Colors.white
                                  : theme.colorScheme.onSurface.withOpacity(0.4),
                              size: 22,
                            ),
                          ),
                          const SizedBox(width: 16),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  l10n.enableNotifications,
                                  style: theme.textTheme.bodyLarge?.copyWith(
                                    fontWeight: FontWeight.w600,
                                    letterSpacing: 0,
                                  ),
                                ),
                                const SizedBox(height: 4),
                                Text(
                                  l10n.enableNotificationsDescription,
                                  style: theme.textTheme.bodySmall?.copyWith(
                                    color: theme.colorScheme.onSurface.withOpacity(0.6),
                                    letterSpacing: 0.1,
                                    height: 1.4,
                                  ),
                                ),
                              ],
                            ),
                          ),
                          const SizedBox(width: 12),
                          Switch(
                            value: settings.enabled,
                            onChanged: (value) {
                              context
                                  .read<NotificationBloc>()
                                  .add(UpdateNotificationSettingsEvent(enabled: value));
                            },
                            activeColor: theme.colorScheme.primary,
                          ),
                        ],
                      ),
                    ),

                    const SizedBox(height: 24),

                    // Posts section
                    _buildSectionHeader(context, l10n.posts, Icons.post_add_rounded),
                    _buildSettingsGroup(
                      context,
                      settings,
                      [
                        _SettingData(
                          title: l10n.newPosts,
                          subtitle: l10n.newPostsDescription,
                          value: settings.newPosts,
                          onChanged: (value) {
                            context
                                .read<NotificationBloc>()
                                .add(UpdateNotificationSettingsEvent(newPosts: value));
                          },
                        ),
                        _SettingData(
                          title: l10n.newComments,
                          subtitle: l10n.newCommentsDescription,
                          value: settings.newComments,
                          onChanged: (value) {
                            context
                                .read<NotificationBloc>()
                                .add(UpdateNotificationSettingsEvent(newComments: value));
                          },
                        ),
                        _SettingData(
                          title: l10n.newLikes,
                          subtitle: l10n.newLikesDescription,
                          value: settings.newLikes,
                          onChanged: (value) {
                            context
                                .read<NotificationBloc>()
                                .add(UpdateNotificationSettingsEvent(newLikes: value));
                          },
                        ),
                      ],
                    ),

                    const SizedBox(height: 32),

                    // Comments section
                    _buildSectionHeader(context, l10n.comments, Icons.chat_bubble_outline),
                    _buildSettingsGroup(
                      context,
                      settings,
                      [
                        _SettingData(
                          title: l10n.commentReplies,
                          subtitle: l10n.commentRepliesDescription,
                          value: settings.commentReplies,
                          onChanged: (value) {
                            context.read<NotificationBloc>().add(
                                UpdateNotificationSettingsEvent(commentReplies: value));
                          },
                        ),
                        _SettingData(
                          title: l10n.mentions,
                          subtitle: l10n.mentionsDescription,
                          value: settings.mentions,
                          onChanged: (value) {
                            context
                                .read<NotificationBloc>()
                                .add(UpdateNotificationSettingsEvent(mentions: value));
                          },
                        ),
                      ],
                    ),

                    const SizedBox(height: 32),

                    // Chat section
                    _buildSectionHeader(context, l10n.chat, Icons.forum_outlined),
                    _buildSettingsGroup(
                      context,
                      settings,
                      [
                        _SettingData(
                          title: l10n.chatMessages,
                          subtitle: l10n.chatMessagesDescription,
                          value: settings.chatMessages,
                          onChanged: (value) {
                            context
                                .read<NotificationBloc>()
                                .add(UpdateNotificationSettingsEvent(chatMessages: value));
                          },
                        ),
                        _SettingData(
                          title: l10n.chatMentions,
                          subtitle: l10n.chatMentionsDescription,
                          value: settings.chatMentions,
                          onChanged: (value) {
                            context
                                .read<NotificationBloc>()
                                .add(UpdateNotificationSettingsEvent(chatMentions: value));
                          },
                        ),
                      ],
                    ),

                    const SizedBox(height: 40),
                  ],
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionHeader(BuildContext context, String title, IconData icon) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.fromLTRB(20, 0, 20, 12),
      child: Row(
        children: [
          Icon(
            icon,
            size: 18,
            color: theme.colorScheme.onSurface.withOpacity(0.5),
          ),
          const SizedBox(width: 8),
          Text(
            title.toUpperCase(),
            style: theme.textTheme.labelSmall?.copyWith(
              color: theme.colorScheme.onSurface.withOpacity(0.5),
              fontWeight: FontWeight.w600,
              letterSpacing: 1.2,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSettingsGroup(
      BuildContext context,
      dynamic settings,
      List<_SettingData> items,
      ) {
    final theme = Theme.of(context);
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 20),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(
          color: theme.colorScheme.onSurface.withOpacity(0.08),
          width: 1,
        ),
      ),
      child: Column(
        children: [
          for (int i = 0; i < items.length; i++) ...[
            _buildSettingTile(
              context: context,
              data: items[i],
              enabled: settings.enabled,
            ),
            if (i < items.length - 1)
              Container(
                height: 1,
                margin: const EdgeInsets.symmetric(horizontal: 20),
                color: theme.colorScheme.onSurface.withOpacity(0.06),
              ),
          ],
        ],
      ),
    );
  }

  Widget _buildSettingTile({
    required BuildContext context,
    required _SettingData data,
    required bool enabled,
  }) {
    final theme = Theme.of(context);
    return InkWell(
      onTap: enabled ? () => data.onChanged(!data.value) : null,
      borderRadius: BorderRadius.circular(16),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
        child: Row(
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    data.title,
                    style: theme.textTheme.bodyLarge?.copyWith(
                      fontWeight: FontWeight.w500,
                      letterSpacing: 0,
                      color: enabled
                          ? theme.colorScheme.onSurface
                          : theme.colorScheme.onSurface.withOpacity(0.4),
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    data.subtitle,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: enabled
                          ? theme.colorScheme.onSurface.withOpacity(0.6)
                          : theme.colorScheme.onSurface.withOpacity(0.3),
                      letterSpacing: 0.1,
                      height: 1.4,
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(width: 16),
            Switch(
              value: data.value,
              onChanged: enabled ? data.onChanged : null,
              activeColor: theme.colorScheme.primary,
            ),
          ],
        ),
      ),
    );
  }
}

class _SettingData {
  final String title;
  final String subtitle;
  final bool value;
  final ValueChanged<bool> onChanged;

  _SettingData({
    required this.title,
    required this.subtitle,
    required this.value,
    required this.onChanged,
  });
}import 'dart:math';

import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/features/notifications/domain/notifcation_repository.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_event.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_state.dart';


class NotificationBloc extends Bloc<NotificationEvent, NotificationState> {
  final NotificationRepository notificationRepository;

  NotificationBloc({required this.notificationRepository})
      : super(NotificationState.initial()) {
    on<GetNotificationSettingsEvent>(_onGetSettings);
    on<UpdateNotificationSettingsEvent>(_onUpdateSettings);
    on<SaveFcmTokenEvent>(_onSaveFcmToken);
    on<RemoveFcmTokenEvent>(_onRemoveFcmToken);
    on<GetNotificationsEvent>(_onGetNotifications);
    on<MarkNotificationAsReadEvent>(_onMarkAsRead);
    on<MarkAllNotificationsAsReadEvent>(_onMarkAllAsRead);
    on<DeleteNotificationEvent>(_onDeleteNotification);
    on<DeleteAllNotificationsEvent>(_onDeleteAllNotifications);
    on<RefreshNotificationsEvent>(_onRefreshNotifications);
    on<GetUnreadCountEvent>(_onGetUnreadCount);
    on<HandleIncomingNotificationEvent>(_onHandleIncomingNotification);
  }

  Future<void> _onGetSettings(
      GetNotificationSettingsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    emit(state.copyWith(status: NotificationStatus.loading));

    final result = await notificationRepository.getSettings();

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (settings) => emit(state.copyWith(
        status: NotificationStatus.success,
        settings: settings,
      )),
    );
  }

  Future<void> _onUpdateSettings(
      UpdateNotificationSettingsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    emit(state.copyWith(status: NotificationStatus.loading));

    final result = await notificationRepository.updateSettings(
      enabled: event.enabled,
      newPosts: event.newPosts,
      newComments: event.newComments,
      newLikes: event.newLikes,
      commentReplies: event.commentReplies,
      mentions: event.mentions,
      chatMessages: event.chatMessages,
      chatMentions: event.chatMentions,
    );

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (settings) => emit(state.copyWith(
        status: NotificationStatus.success,
        settings: settings,
      )),
    );
  }

  Future<void> _onSaveFcmToken(
      SaveFcmTokenEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result = await notificationRepository.saveFcmToken(event.fcmToken);

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) => null,
    );
  }

  Future<void> _onRemoveFcmToken(
      RemoveFcmTokenEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result = await notificationRepository.removeFcmToken();

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) => null,
    );
  }

  Future<void> _onGetNotifications(
      GetNotificationsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    if (event.loadMore) {
      if (!state.hasMore) return;
      emit(state.copyWith(status: NotificationStatus.loadingMore));
    } else {
      emit(state.copyWith(status: NotificationStatus.loading));
    }

    final result = await notificationRepository.getNotifications(
      page: event.page,
      limit: 20,
      unreadOnly: event.unreadOnly,
    );

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (response) {
        final newNotifications = event.loadMore
            ? [...state.notifications, ...response.notifications]
            : response.notifications;

        emit(state.copyWith(
          status: NotificationStatus.success,
          notifications: newNotifications,
          unreadCount: response.unreadCount,
          currentPage: state.currentPage + 1,
          hasMore: response.notifications.length >= 20
        ));
      },
    );
  }

  Future<void> _onMarkAsRead(
      MarkNotificationAsReadEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result =
    await notificationRepository.markAsRead(event.notificationId);

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (updatedNotification) {
        final updatedList = state.notifications.map((n) {
          if (n.id == updatedNotification.id) {
            return updatedNotification;
          }
          return n;
        }).toList();

        final newUnreadCount = state.unreadCount > 0 ? state.unreadCount - 1 : 0;

        emit(state.copyWith(
          notifications: updatedList,
          unreadCount: newUnreadCount,
        ));
      },
    );
  }

  Future<void> _onMarkAllAsRead(
      MarkAllNotificationsAsReadEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result = await notificationRepository.markAllAsRead();

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) {
        final updatedList = state.notifications
            .map((n) => n.copyWith(isRead: true))
            .toList();

        emit(state.copyWith(
          notifications: updatedList,
          unreadCount: 0,
        ));
      },
    );
  }

  Future<void> _onDeleteNotification(
      DeleteNotificationEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result =
    await notificationRepository.deleteNotification(event.notificationId);

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) {
        final notification = state.notifications
            .firstWhere((n) => n.id == event.notificationId);

        final updatedList = state.notifications
            .where((n) => n.id != event.notificationId)
            .toList();

        final newUnreadCount = !notification.isRead && state.unreadCount > 0
            ? state.unreadCount - 1
            : state.unreadCount;

        emit(state.copyWith(
          notifications: updatedList,
          unreadCount: newUnreadCount,
        ));
      },
    );
  }

  Future<void> _onDeleteAllNotifications(
      DeleteAllNotificationsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    emit(state.copyWith(status: NotificationStatus.loading));

    final result = await notificationRepository.deleteAllNotifications();

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) => emit(state.copyWith(
        status: NotificationStatus.success,
        notifications: [],
        unreadCount: 0,
      )),
    );
  }

  Future<void> _onRefreshNotifications(
      RefreshNotificationsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    print('sdfasfasf');
    final result = await notificationRepository.getNotifications(
      page: 1,
      unreadOnly: false,
    );

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (response) {
        emit(state.copyWith(
          status: NotificationStatus.success,
          notifications: response.notifications,
          unreadCount: response.unreadCount,
          currentPage: 1,
          hasMore: response.notifications.length < 20,
        ));
      },
    );
  }

  Future<void> _onGetUnreadCount(
      GetUnreadCountEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result = await notificationRepository.getUnreadCount();

    result.fold(
          (failure) => null,
          (count) => emit(state.copyWith(unreadCount: count)),
    );
  }

  Future<void> _onHandleIncomingNotification(
      HandleIncomingNotificationEvent event,
      Emitter<NotificationState> emit,
      ) async {
    // Increment unread count when new notification arrives
    emit(state.copyWith(unreadCount: state.unreadCount + 1));

    // Optionally refresh notifications list
    add(RefreshNotificationsEvent());
  }
}abstract class NotificationEvent {}

// Settings Events
class GetNotificationSettingsEvent extends NotificationEvent {}

class UpdateNotificationSettingsEvent extends NotificationEvent {
  final bool? enabled;
  final bool? newPosts;
  final bool? newComments;
  final bool? newLikes;
  final bool? commentReplies;
  final bool? mentions;
  final bool? chatMessages;
  final bool? chatMentions;

  UpdateNotificationSettingsEvent({
    this.enabled,
    this.newPosts,
    this.newComments,
    this.newLikes,
    this.commentReplies,
    this.mentions,
    this.chatMessages,
    this.chatMentions,
  });
}

class SaveFcmTokenEvent extends NotificationEvent {
  final String fcmToken;

  SaveFcmTokenEvent(this.fcmToken);
}

class RemoveFcmTokenEvent extends NotificationEvent {}

// Notification List Events
class GetNotificationsEvent extends NotificationEvent {
  final int page;
  final bool unreadOnly;
  final bool loadMore;

  GetNotificationsEvent({
    this.page = 1,
    this.unreadOnly = false,
    this.loadMore = false,
  });
}

class MarkNotificationAsReadEvent extends NotificationEvent {
  final String notificationId;

  MarkNotificationAsReadEvent(this.notificationId);
}

class MarkAllNotificationsAsReadEvent extends NotificationEvent {}

class DeleteNotificationEvent extends NotificationEvent {
  final String notificationId;

  DeleteNotificationEvent(this.notificationId);
}

class DeleteAllNotificationsEvent extends NotificationEvent {}

class RefreshNotificationsEvent extends NotificationEvent {}

class GetUnreadCountEvent extends NotificationEvent {}

// Handle incoming notification from FCM
class HandleIncomingNotificationEvent extends NotificationEvent {
  final Map<String, dynamic> data;

  HandleIncomingNotificationEvent(this.data);
}import 'package:unitalk/features/notifications/model/notification_model.dart';
import 'package:unitalk/features/notifications/model/notification_settings_model.dart';

enum NotificationStatus {
  initial,
  loading,
  loadingMore,
  success,
  failure,
}

class NotificationState {
  final NotificationStatus status;
  final List<NotificationModel> notifications;
  final NotificationSettingsModel? settings;
  final int unreadCount;
  final int currentPage;
  final bool hasMore;
  final String? errorMessage;

  NotificationState({
    required this.status,
    required this.notifications,
    this.settings,
    required this.unreadCount,
    required this.currentPage,
    required this.hasMore,
    this.errorMessage,
  });

  factory NotificationState.initial() {
    return NotificationState(
      status: NotificationStatus.initial,
      notifications: [],
      settings: null,
      unreadCount: 0,
      currentPage: 1,
      hasMore: true,
      errorMessage: null,
    );
  }

  NotificationState copyWith({
    NotificationStatus? status,
    List<NotificationModel>? notifications,
    NotificationSettingsModel? settings,
    int? unreadCount,
    int? currentPage,
    bool? hasMore,
    String? errorMessage,
  }) {
    return NotificationState(
      status: status ?? this.status,
      notifications: notifications ?? this.notifications,
      settings: settings ?? this.settings,
      unreadCount: unreadCount ?? this.unreadCount,
      currentPage: currentPage ?? this.currentPage,
      hasMore: hasMore ?? this.hasMore,
      errorMessage: errorMessage,
    );
  }
}
import 'package:dartz/dartz.dart';
import 'package:unitalk/core/failure/failure.dart';
import 'package:unitalk/features/notifications/model/notification_model.dart';
import 'package:unitalk/features/notifications/model/notification_response_model.dart';
import 'package:unitalk/features/notifications/model/notification_settings_model.dart';

abstract class NotificationRepository {
  // Settings
  Future<Either<Failure, NotificationSettingsModel>> getSettings();

  Future<Either<Failure, NotificationSettingsModel>> updateSettings({
    bool? enabled,
    bool? newPosts,
    bool? newComments,
    bool? newLikes,
    bool? commentReplies,
    bool? mentions,
    bool? chatMessages,
    bool? chatMentions,
  });

  Future<Either<Failure, void>> saveFcmToken(String fcmToken);

  Future<Either<Failure, void>> removeFcmToken();

  // Notifications
  Future<Either<Failure, NotificationsResponseModel>> getNotifications({
    int page = 1,
    int limit = 20,
    bool unreadOnly = false,
  });

  Future<Either<Failure, NotificationModel>> markAsRead(String notificationId);

  Future<Either<Failure, void>> markAllAsRead();

  Future<Either<Failure, void>> deleteNotification(String notificationId);

  Future<Either<Failure, void>> deleteAllNotifications();

  Future<Either<Failure, int>> getUnreadCount();
}import 'package:dartz/dartz.dart';
import 'package:unitalk/core/failure/failure.dart';
import 'package:unitalk/features/notifications/data/notifcation_remote_datasource.dart';
import 'package:unitalk/features/notifications/domain/notifcation_repository.dart';
import 'package:unitalk/features/notifications/model/notification_model.dart';
import 'package:unitalk/features/notifications/model/notification_response_model.dart';
import 'package:unitalk/features/notifications/model/notification_settings_model.dart';

class NotificationRepositoryImpl implements NotificationRepository {
  final NotificationRemoteDataSource remoteDataSource;

  NotificationRepositoryImpl(this.remoteDataSource);

  @override
  Future<Either<Failure, NotificationSettingsModel>> getSettings() async {
    try {
      final settings = await remoteDataSource.getSettings();
      return Right(settings);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, NotificationSettingsModel>> updateSettings({
    bool? enabled,
    bool? newPosts,
    bool? newComments,
    bool? newLikes,
    bool? commentReplies,
    bool? mentions,
    bool? chatMessages,
    bool? chatMentions,
  }) async {
    try {
      final settings = await remoteDataSource.updateSettings(
        enabled: enabled,
        newPosts: newPosts,
        newComments: newComments,
        newLikes: newLikes,
        commentReplies: commentReplies,
        mentions: mentions,
        chatMessages: chatMessages,
        chatMentions: chatMentions,
      );
      return Right(settings);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> saveFcmToken(String fcmToken) async {
    try {
      await remoteDataSource.saveFcmToken(fcmToken);
      return const Right(null);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> removeFcmToken() async {
    try {
      await remoteDataSource.removeFcmToken();
      return const Right(null);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, NotificationsResponseModel>> getNotifications({
    int page = 1,
    int limit = 20,
    bool unreadOnly = false,
  }) async {
    try {
      final response = await remoteDataSource.getNotifications(
        page: page,
        limit: limit,
        unreadOnly: unreadOnly,
      );
      return Right(response);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, NotificationModel>> markAsRead(
      String notificationId) async {
    try {
      final notification = await remoteDataSource.markAsRead(notificationId);
      return Right(notification);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> markAllAsRead() async {
    try {
      await remoteDataSource.markAllAsRead();
      return const Right(null);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> deleteNotification(
      String notificationId) async {
    try {
      await remoteDataSource.deleteNotification(notificationId);
      return const Right(null);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> deleteAllNotifications() async {
    try {
      await remoteDataSource.deleteAllNotifications();
      return const Right(null);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, int>> getUnreadCount() async {
    try {
      final count = await remoteDataSource.getUnreadCount();
      return Right(count);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }
}import 'package:dio/dio.dart';
import 'package:unitalk/features/notifications/model/notification_model.dart';
import 'package:unitalk/features/notifications/model/notification_response_model.dart';
import 'package:unitalk/features/notifications/model/notification_settings_model.dart';

class NotificationRemoteDataSource {
  final Dio dio;

  NotificationRemoteDataSource({required this.dio});

  // ============== SETTINGS ==============

  Future<NotificationSettingsModel> getSettings() async {
    final response = await dio.get('/notifications/settings');
    return NotificationSettingsModel.fromJson(response.data);
  }

  Future<NotificationSettingsModel> updateSettings({
    bool? enabled,
    bool? newPosts,
    bool? newComments,
    bool? newLikes,
    bool? commentReplies,
    bool? mentions,
    bool? chatMessages,
    bool? chatMentions,
  }) async {
    final data = <String, dynamic>{};

    if (enabled != null) data['enabled'] = enabled;
    if (newPosts != null) data['newPosts'] = newPosts;
    if (newComments != null) data['newComments'] = newComments;
    if (newLikes != null) data['newLikes'] = newLikes;
    if (commentReplies != null) data['commentReplies'] = commentReplies;
    if (mentions != null) data['mentions'] = mentions;
    if (chatMessages != null) data['chatMessages'] = chatMessages;
    if (chatMentions != null) data['chatMentions'] = chatMentions;

    final response = await dio.put('/notifications/settings', data: data);
    return NotificationSettingsModel.fromJson(response.data);
  }

  Future<void> saveFcmToken(String fcmToken) async {
    await dio.post('/notifications/fcm-token', data: {'fcmToken': fcmToken});
  }

  Future<void> removeFcmToken() async {
    await dio.delete('/notifications/fcm-token');
  }

  // ============== NOTIFICATIONS ==============

  Future<NotificationsResponseModel> getNotifications({
    int page = 1,
    int limit = 20,
    bool unreadOnly = false,
  }) async {
    final response = await dio.get(
      '/notifications',
      queryParameters: {
        'page': page,
        'limit': limit,
        'unreadOnly': unreadOnly,
      },
    );
    return NotificationsResponseModel.fromJson(response.data);
  }

  Future<NotificationModel> markAsRead(String notificationId) async {
    final response = await dio.put('/notifications/$notificationId/read');
    return NotificationModel.fromJson(response.data);
  }

  Future<void> markAllAsRead() async {
    await dio.put('/notifications/read-all');
  }

  Future<void> deleteNotification(String notificationId) async {
    await dio.delete('/notifications/$notificationId');
  }

  Future<void> deleteAllNotifications() async {
    await dio.delete('/notifications');
  }

  Future<int> getUnreadCount() async {
    final response = await dio.get('/notifications/unread-count');
    return response.data['unreadCount'] as int;
  }
}// lib/features/friendship/data/models/friendship_model.dart
import 'package:json_annotation/json_annotation.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

part 'friendship_model.g.dart';

enum FriendshipStatus {
  @JsonValue('none')
  none,
  @JsonValue('pending')
  pending,
  @JsonValue('accepted')
  accepted,
  @JsonValue('rejected')
  rejected,
}

@JsonSerializable()
class FriendshipModel {
  @JsonKey(name: '_id')
  final String? id;
  final FriendshipStatus status;
  final String? friendshipId;
  final bool? isRequester;
  final DateTime? createdAt;
  final DateTime? acceptedAt;

  FriendshipModel({
    this.id,
    required this.status,
    this.friendshipId,
    this.isRequester,
    this.createdAt,
    this.acceptedAt,
  });

  factory FriendshipModel.fromJson(Map<String, dynamic> json) =>
      _$FriendshipModelFromJson(json);

  Map<String, dynamic> toJson() => _$FriendshipModelToJson(this);

  bool get isPending => status == FriendshipStatus.pending;
  bool get isAccepted => status == FriendshipStatus.accepted;
  bool get isNone => status == FriendshipStatus.none;
}

@JsonSerializable()
class FriendshipStatusResponse {
  final FriendshipStatus status;
  final bool isFriend;
  final String? friendshipId;
  final bool? isRequester;
  final DateTime? createdAt;
  final DateTime? acceptedAt;

  FriendshipStatusResponse({
    required this.status,
    required this.isFriend,
    this.friendshipId,
    this.isRequester,
    this.createdAt,
    this.acceptedAt,
  });

  factory FriendshipStatusResponse.fromJson(Map<String, dynamic> json) =>
      _$FriendshipStatusResponseFromJson(json);

  Map<String, dynamic> toJson() => _$FriendshipStatusResponseToJson(this);
}

@JsonSerializable()
class FriendRequestModel {
  final String friendshipId;
  final UserModel user;
  final DateTime requestedAt;

  FriendRequestModel({
    required this.friendshipId,
    required this.user,
    required this.requestedAt,
  });

  factory FriendRequestModel.fromJson(Map<String, dynamic> json) =>
      _$FriendRequestModelFromJson(json);

  Map<String, dynamic> toJson() => _$FriendRequestModelToJson(this);
}import 'package:json_annotation/json_annotation.dart';
import 'package:unitalk/features/block/data/model/block_model.dart';
import 'package:unitalk/features/faculty/data/models/faculty_model.dart';
import 'package:unitalk/features/university/data/models/university_model.dart';
import 'verification_model.dart';

part 'user_model.g.dart';

enum Sector {
  @JsonValue('en')
  english,
  @JsonValue('ru')
  russian,
  @JsonValue('az')
  azerbaijani;

  String get code {
    switch (this) {
      case Sector.english:
        return 'en';
      case Sector.russian:
        return 'ru';
      case Sector.azerbaijani:
        return 'az';
    }
  }

  String get displayName {
    switch (this) {
      case Sector.english:
        return 'English';
      case Sector.russian:
        return 'Russian';
      case Sector.azerbaijani:
        return 'Azerbaijani';
    }
  }

  String get flagEmoji {
    switch (this) {
      case Sector.english:
        return 'üá¨üáß';
      case Sector.russian:
        return 'üá∑üá∫';
      case Sector.azerbaijani:
        return 'üá¶üáø';
    }
  }

  static Sector? fromCode(String? code) {
    if (code == null) return null;
    switch (code) {
      case 'en':
        return Sector.english;
      case 'ru':
        return Sector.russian;
      case 'az':
        return Sector.azerbaijani;
      default:
        return null;
    }
  }
}

@JsonSerializable()
class UserModel {
  @JsonKey(name: '_id')
  final String? id;
  final String? email;
  final String? photoUrl;
  final String? firstName;
  final String? lastName;
  @JsonKey(name: 'universityId')
  final UniversityModel? university;
  @JsonKey(name: 'facultyId')
  final FacultyModel? faculty;
  final Sector? sector;
  final bool? isVerified;
  @JsonKey(name: 'verificationId')
  final VerificationModel? verification;
  final BlockStatusModel? blockStatus;
  final int? friendsCount;
  final int? pendingRequestsCount;

  // –ù–û–í–û–ï: –Ø–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —Å–µ—Ä–≤–µ—Ä–∞
  final String? language;

  UserModel({
    required this.id,
    this.email,
    this.photoUrl,
    this.firstName,
    this.lastName,
    this.university,
    this.faculty,
    this.sector,
    this.isVerified,
    this.verification,
    this.blockStatus,
    this.friendsCount,
    this.pendingRequestsCount,
    this.language, // –ù–û–í–û–ï
  });

  factory UserModel.fromJson(Map<String, dynamic> json) =>
      _$UserModelFromJson(json);

  Map<String, dynamic> toJson() => _$UserModelToJson(this);

  bool get isProfileComplete =>
      firstName != null &&
          lastName != null &&
          university != null &&
          faculty != null &&
          sector != null;

  bool get canInteract => blockStatus?.canInteract ?? true;
  bool get isBlocked => blockStatus?.isBlocked ?? false;
  bool get isBlockedBy => blockStatus?.isBlockedBy ?? false;
}class UniversityModel{
  final String id;
  final Map<String, String> name;
  final String? logoUrl;

  UniversityModel({
    required this.id,
    required this.name,
    this.logoUrl,
  });

  String getLocalizedName(String locale) {
    return name[locale] ?? name['en'] ?? name.values.first;
  }

  factory UniversityModel.fromJson(Map<String, dynamic> json) {
    final Map<String, String> nameMap = {};

    if (json['translations'] != null) {
      for (var translation in json['translations']) {
        nameMap[translation['lang']] = translation['name'];
      }
    }

    // Fallback –Ω–∞ —Å—Ç–∞—Ä—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –µ—Å–ª–∏ –µ—Å—Ç—å
    if (nameMap.isEmpty && json['name'] != null) {
      nameMap.addAll(Map<String, String>.from(json['name'] as Map));
    }

    return UniversityModel(
      id: json['_id'] as String? ?? json['id'] as String,
      name: nameMap,
      logoUrl: json['logoUrl'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –æ–±—Ä–∞—Ç–Ω–æ –≤ –º–∞—Å—Å–∏–≤ translations
    final translations = name.entries.map((entry) {
      return {
        'lang': entry.key,
        'name': entry.value,
      };
    }).toList();

    return {
      'id': id,
      'translations': translations,
      'logoUrl': logoUrl,
    };
  }

}