// ============================================
// FILE: features/friendship/presentation/bloc/friendship_bloc.dart
// ============================================
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/features/friendship/data/model/friendship_model.dart'
    show FriendshipStatusResponse, FriendshipStatus;
import 'package:unitalk/features/friendship/domain/repository/friendship_repository.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_state.dart'
    show FriendshipState, FriendshipStateStatus;
import 'friendship_event.dart';

class FriendshipBloc extends Bloc<FriendshipEvent, FriendshipState> {
  final FriendshipRepository repository;

  FriendshipBloc({required this.repository})
    : super(FriendshipState.initial()) {
    on<SendFriendRequestEvent>(_onSendFriendRequest);
    on<AcceptFriendRequestEvent>(_onAcceptFriendRequest);
    on<RejectFriendRequestEvent>(_onRejectFriendRequest);
    on<RemoveFriendshipEvent>(_onRemoveFriendship);
    on<LoadFriendsListEvent>(_onLoadFriendsList);
    on<LoadIncomingRequestsEvent>(_onLoadIncomingRequests);
    on<LoadOutgoingRequestsEvent>(_onLoadOutgoingRequests);
    on<LoadFriendshipStatusEvent>(_onLoadFriendshipStatus);
    on<ClearFriendshipStateEvent>(_onClearState);
  }

  Future<void> _onLoadFriendsList(
    LoadFriendsListEvent event,
    Emitter<FriendshipState> emit,
  ) async {
    if (event.loadMore) {
      if (!state.friendsHasMore || state.isLoadingMore) return;
      emit(state.copyWith(status: FriendshipStateStatus.loadingMore));
    } else {
      emit(
        state.copyWith(
          status: FriendshipStateStatus.loading,
          friends: [],
          friendsPage: 1,
        ),
      );
    }

    final page = event.loadMore ? state.friendsPage : 1;

    final result = await repository.getFriendsList(page: page, limit: 20,userId: event.userId);

    result.fold(
      (failure) {
        emit(
          state.copyWith(
            status: FriendshipStateStatus.failure,
            errorMessage: failure.message,
          ),
        );
      },
      (newFriends) {
        final updatedFriends = event.loadMore
            ? [...state.friends, ...newFriends]
            : newFriends;

        emit(
          state.copyWith(
            status: FriendshipStateStatus.success,
            friends: updatedFriends,
            friendsPage: page + 1,
            friendsHasMore: newFriends.length >= 20,
          ),
        );
      },
    );
  }

  // Загрузить входящие запросы
  Future<void> _onLoadIncomingRequests(
    LoadIncomingRequestsEvent event,
    Emitter<FriendshipState> emit,
  ) async {
    if (event.loadMore) {
      if (!state.incomingHasMore || state.isLoadingMore) return;
      emit(state.copyWith(status: FriendshipStateStatus.loadingMore));
    } else {
      emit(
        state.copyWith(
          status: FriendshipStateStatus.loading,
          incomingRequests: [],
          incomingPage: 1,
        ),
      );
    }

    final page = event.loadMore ? state.incomingPage : 1;

    final result = await repository.getIncomingRequests(page: page, limit: 20);

    result.fold(
      (failure) {
        emit(
          state.copyWith(
            status: FriendshipStateStatus.failure,
            errorMessage: failure.message,
          ),
        );
      },
      (newRequests) {
        final updatedRequests = event.loadMore
            ? [...state.incomingRequests, ...newRequests]
            : newRequests;

        emit(
          state.copyWith(
            status: FriendshipStateStatus.success,
            incomingRequests: updatedRequests,
            incomingPage: page + 1,
            incomingHasMore: newRequests.length >= 20,
          ),
        );
      },
    );
  }

  // Загрузить исходящие запросы
  Future<void> _onLoadOutgoingRequests(
    LoadOutgoingRequestsEvent event,
    Emitter<FriendshipState> emit,
  ) async {
    if (event.loadMore) {
      if (!state.outgoingHasMore || state.isLoadingMore) return;
      emit(state.copyWith(status: FriendshipStateStatus.loadingMore));
    } else {
      emit(
        state.copyWith(
          status: FriendshipStateStatus.loading,
          outgoingRequests: [],
          outgoingPage: 1,
        ),
      );
    }

    final page = event.loadMore ? state.outgoingPage : 1;

    final result = await repository.getOutgoingRequests(page: page, limit: 20);

    result.fold(
      (failure) {
        emit(
          state.copyWith(
            status: FriendshipStateStatus.failure,
            errorMessage: failure.message,
          ),
        );
      },
      (newRequests) {
        final updatedRequests = event.loadMore
            ? [...state.outgoingRequests, ...newRequests]
            : newRequests;

        emit(
          state.copyWith(
            status: FriendshipStateStatus.success,
            outgoingRequests: updatedRequests,
            outgoingPage: page + 1,
            outgoingHasMore: newRequests.length >= 20,
          ),
        );
      },
    );
  }

  // Загрузить статус дружбы с пользователем
  Future<void> _onLoadFriendshipStatus(
    LoadFriendshipStatusEvent event,
    Emitter<FriendshipState> emit,
  ) async {
    final result = await repository.getFriendshipStatus(event.userId);

    result.fold(
      (failure) {
        emit(
          state.copyWith(
            status: FriendshipStateStatus.failure,
            errorMessage: failure.message,
          ),
        );
      },
      (status) {
        final updatedStatuses = Map<String, FriendshipStatusResponse>.from(
          state.friendshipStatuses,
        );
        updatedStatuses[event.userId] = status;

        emit(
          state.copyWith(
            status: FriendshipStateStatus.success,
            friendshipStatuses: updatedStatuses,
          ),
        );
      },
    );
  }

  // Очистить состояние
  void _onClearState(
    ClearFriendshipStateEvent event,
    Emitter<FriendshipState> emit,
  ) {
    emit(FriendshipState.initial());
  }

  // Отправить запрос в друзья
  Future<void> _onSendFriendRequest(
    SendFriendRequestEvent event,
    Emitter<FriendshipState> emit,
  ) async {
    final result = await repository.sendFriendRequest(event.userId);

    result.fold(
      (failure) {
        emit(
          state.copyWith(
            status: FriendshipStateStatus.failure,
            errorMessage: failure.message,
          ),
        );
      },
      (friendship) {
        // ✅ ИСПРАВЛЕНО: Используем правильный тип
        final updatedStatuses = Map<String, FriendshipStatusResponse>.from(
          state.friendshipStatuses,
        );

        updatedStatuses[event.userId] = FriendshipStatusResponse(
          status: FriendshipStatus.pending,
          isFriend: false,
          friendshipId: friendship.id ?? friendship.friendshipId,
          isRequester: true,
          createdAt: friendship.createdAt ?? DateTime.now(),
        );

        emit(
          state.copyWith(
            status: FriendshipStateStatus.success,
            friendshipStatuses: updatedStatuses,
          ),
        );
      },
    );
  }

  // Удалить дружбу
  Future<void> _onRemoveFriendship(
    RemoveFriendshipEvent event,
    Emitter<FriendshipState> emit,
  ) async {
    final result = await repository.removeFriendship(event.friendshipId);

    result.fold(
      (failure) {
        emit(
          state.copyWith(
            status: FriendshipStateStatus.failure,
            errorMessage: failure.message,
          ),
        );
      },
      (_) {
        // ✅ ИСПРАВЛЕНО: Приоритет event.userId
        String? targetUserId = event.userId;

        // Если userId не передан, ищем в списках
        if (targetUserId == null) {
          // Ищем в исходящих запросах
          for (final request in state.outgoingRequests) {
            if (request.friendshipId == event.friendshipId) {
              targetUserId = request.user.id;
              break;
            }
          }

          // Ищем в друзьях
          if (targetUserId == null) {
            for (final friend in state.friends) {
              // Можно добавить поле friendshipId в модель или искать по другому
              // Пока пропускаем, так как в списке друзей нет friendshipId
            }
          }

          // ✅ НОВОЕ: Ищем в friendshipStatuses по friendshipId
          if (targetUserId == null) {
            for (final entry in state.friendshipStatuses.entries) {
              if (entry.value.friendshipId == event.friendshipId) {
                targetUserId = entry.key;
                break;
              }
            }
          }
        }

        // Обновляем списки
        final updatedFriends = state.friends
            .where((friend) => friend.id != targetUserId)
            .toList();

        final updatedOutgoing = state.outgoingRequests
            .where((req) => req.friendshipId != event.friendshipId)
            .toList();

        // Обновляем статусы
        final updatedStatuses = Map<String, FriendshipStatusResponse>.from(
          state.friendshipStatuses,
        );

        if (targetUserId != null) {
          updatedStatuses[targetUserId] = FriendshipStatusResponse(
            status: FriendshipStatus.none,
            isFriend: false,
          );
        }

        emit(
          state.copyWith(
            status: FriendshipStateStatus.success,
            friends: updatedFriends,
            outgoingRequests: updatedOutgoing,
            friendshipStatuses: updatedStatuses,
          ),
        );
      },
    );
  }

  // ✅ ИЗМЕНИТЬ методы _onAcceptFriendRequest и _onRejectFriendRequest

  // Принять запрос в друзья
  Future _onAcceptFriendRequest(
    AcceptFriendRequestEvent event,
    Emitter emit,
  ) async {
    final result = await repository.acceptFriendRequest(event.friendshipId);

    result.fold(
      (failure) {
        emit(
          state.copyWith(
            status: FriendshipStateStatus.failure,
            errorMessage: failure.message,
          ),
        );
      },
      (friendship) {
        String? targetUserId;

        for (final request in state.incomingRequests) {
          if (request.friendshipId == event.friendshipId) {
            targetUserId = request.user.id;
            break;
          }
        }

        final updatedIncoming = state.incomingRequests
            .where((req) => req.friendshipId != event.friendshipId)
            .toList();

        final updatedStatuses = Map<String,FriendshipStatusResponse>.from(state.friendshipStatuses);

        if (targetUserId != null) {
          updatedStatuses[targetUserId] = FriendshipStatusResponse(
            status: FriendshipStatus.accepted,
            isFriend: true,
            friendshipId: event.friendshipId,
            acceptedAt: DateTime.now(),
          );
        }

        emit(
          state.copyWith(
            status: FriendshipStateStatus.success,
            incomingRequests: updatedIncoming,
            friendshipStatuses: updatedStatuses,
          ),
        );

        // ✅ ДОБАВИТЬ: Перезагрузить статус дружбы
        if (targetUserId != null) {
          add(LoadFriendshipStatusEvent(targetUserId));
        }

        // Перезагружаем список друзей
        add(LoadFriendsListEvent());
      },
    );
  }

  // Отклонить запрос в друзья
  Future _onRejectFriendRequest(
    RejectFriendRequestEvent event,
    Emitter emit,
  ) async {
    final result = await repository.rejectFriendRequest(event.friendshipId);

    result.fold(
      (failure) {
        emit(
          state.copyWith(
            status: FriendshipStateStatus.failure,
            errorMessage: failure.message,
          ),
        );
      },
      (_) {
        String? targetUserId;

        for (final request in state.incomingRequests) {
          if (request.friendshipId == event.friendshipId) {
            targetUserId = request.user.id;
            break;
          }
        }

        final updatedIncoming = state.incomingRequests
            .where((req) => req.friendshipId != event.friendshipId)
            .toList();

        final updatedStatuses =  Map<String,FriendshipStatusResponse>.from(state.friendshipStatuses);

        if (targetUserId != null) {
          updatedStatuses[targetUserId] = FriendshipStatusResponse(
            status: FriendshipStatus.rejected,
            isFriend: false,
          );
        }

        emit(
          state.copyWith(
            status: FriendshipStateStatus.success,
            incomingRequests: updatedIncoming,
            friendshipStatuses: updatedStatuses,
          ),
        );

        // ✅ ДОБАВИТЬ: Перезагрузить статус дружбы
        if (targetUserId != null) {
          add(LoadFriendshipStatusEvent(targetUserId));
        }
      },
    );
  }
}



// ============================================
// FILE: features/friendship/presentation/bloc/friendship_event.dart
// ============================================
abstract class FriendshipEvent {}

// Управление дружбой
class SendFriendRequestEvent extends FriendshipEvent {
  final String userId;

  SendFriendRequestEvent(this.userId);
}

class AcceptFriendRequestEvent extends FriendshipEvent {
  final String friendshipId;

  AcceptFriendRequestEvent(this.friendshipId);
}

class RejectFriendRequestEvent extends FriendshipEvent {
  final String friendshipId;

  RejectFriendRequestEvent(this.friendshipId);
}

class RemoveFriendshipEvent extends FriendshipEvent {
  final String friendshipId;
  final String? userId; // ✅ ДОБАВИТЬ

  RemoveFriendshipEvent(this.friendshipId, {this.userId}); // ✅ ИЗМЕНИТЬ
}

// ✅ ИЗМЕНИТЬ LoadFriendsListEvent

class LoadFriendsListEvent extends FriendshipEvent {
  final bool loadMore;
  final String? userId; // ✅ ДОБАВИТЬ: для загрузки друзей другого пользователя

  LoadFriendsListEvent({
    this.loadMore = false,
    this.userId, // ✅ ДОБАВИТЬ
  });
}

class LoadIncomingRequestsEvent extends FriendshipEvent {
  final bool loadMore;

  LoadIncomingRequestsEvent({this.loadMore = false});
}

class LoadOutgoingRequestsEvent extends FriendshipEvent {
  final bool loadMore;

  LoadOutgoingRequestsEvent({this.loadMore = false});
}

class LoadFriendshipStatusEvent extends FriendshipEvent {
  final String userId;

  LoadFriendshipStatusEvent(this.userId);
}

// Очистка
class ClearFriendshipStateEvent extends FriendshipEvent {}



// ============================================
// FILE: features/friendship/presentation/bloc/friendship_state.dart
// ============================================
import 'package:unitalk/features/auth/data/model/user_model.dart';
import 'package:unitalk/features/friendship/data/model/friendship_model.dart';

enum FriendshipStateStatus { initial, loading, success, failure, loadingMore }

class FriendshipState {
  final FriendshipStateStatus status;

  // Списки
  final List<UserModel> friends;
  final List<FriendRequestModel> incomingRequests;
  final List<FriendRequestModel> outgoingRequests;

  // Пагинация
  final int friendsPage;
  final int incomingPage;
  final int outgoingPage;
  final bool friendsHasMore;
  final bool incomingHasMore;
  final bool outgoingHasMore;

  // Статус дружбы с конкретным пользователем
  final Map<String, FriendshipStatusResponse> friendshipStatuses;

  // Ошибки
  final String? errorMessage;

  FriendshipState({
    required this.status,
    this.friends = const [],
    this.incomingRequests = const [],
    this.outgoingRequests = const [],
    this.friendsPage = 1,
    this.incomingPage = 1,
    this.outgoingPage = 1,
    this.friendsHasMore = true,
    this.incomingHasMore = true,
    this.outgoingHasMore = true,
    this.friendshipStatuses = const {},
    this.errorMessage,
  });

  factory FriendshipState.initial() => FriendshipState(
    status: FriendshipStateStatus.initial,
  );

  FriendshipState copyWith({
    FriendshipStateStatus? status,
    List<UserModel>? friends,
    List<FriendRequestModel>? incomingRequests,
    List<FriendRequestModel>? outgoingRequests,
    int? friendsPage,
    int? incomingPage,
    int? outgoingPage,
    bool? friendsHasMore,
    bool? incomingHasMore,
    bool? outgoingHasMore,
    Map<String, FriendshipStatusResponse>? friendshipStatuses,
    String? errorMessage,
  }) {
    return FriendshipState(
      status: status ?? this.status,
      friends: friends ?? this.friends,
      incomingRequests: incomingRequests ?? this.incomingRequests,
      outgoingRequests: outgoingRequests ?? this.outgoingRequests,
      friendsPage: friendsPage ?? this.friendsPage,
      incomingPage: incomingPage ?? this.incomingPage,
      outgoingPage: outgoingPage ?? this.outgoingPage,
      friendsHasMore: friendsHasMore ?? this.friendsHasMore,
      incomingHasMore: incomingHasMore ?? this.incomingHasMore,
      outgoingHasMore: outgoingHasMore ?? this.outgoingHasMore,
      friendshipStatuses: friendshipStatuses ?? this.friendshipStatuses,
      errorMessage: errorMessage,
    );
  }

  // Геттеры для удобства
  FriendshipStatusResponse? getFriendshipStatus(String userId) {
    return friendshipStatuses[userId];
  }

  bool get isLoading => status == FriendshipStateStatus.loading;
  bool get isLoadingMore => status == FriendshipStateStatus.loadingMore;
  bool get hasError => status == FriendshipStateStatus.failure;
}


// ============================================
// FILE: features/friendship/presentation/pages/friend_requests_page.dart
// ============================================
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/core/ui/common/empty_state_widget.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_bloc.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_event.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_state.dart';
import 'package:unitalk/features/friendship/presentation/widgets/friend_list_tile.dart';
import 'package:unitalk/l10n/app_localizations.dart';
import 'package:timeago/timeago.dart' as timeago;

class FriendRequestsPage extends StatefulWidget {
  const FriendRequestsPage({Key? key}) : super(key: key);

  @override
  State<FriendRequestsPage> createState() => _FriendRequestsPageState();
}

class _FriendRequestsPageState extends State<FriendRequestsPage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final ScrollController _incomingScrollController = ScrollController();
  final ScrollController _outgoingScrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _incomingScrollController.addListener(_onIncomingScroll);
    _outgoingScrollController.addListener(_onOutgoingScroll);

    // Загружаем входящие запросы при открытии
    context.read<FriendshipBloc>().add(LoadIncomingRequestsEvent());
  }

  @override
  void dispose() {
    _tabController.dispose();
    _incomingScrollController.dispose();
    _outgoingScrollController.dispose();
    super.dispose();
  }

  void _onIncomingScroll() {
    if (_isBottomIncoming) {
      final state = context.read<FriendshipBloc>().state;
      if (state.incomingHasMore && !state.isLoadingMore) {
        context.read<FriendshipBloc>().add(LoadIncomingRequestsEvent(loadMore: true));
      }
    }
  }

  void _onOutgoingScroll() {
    if (_isBottomOutgoing) {
      final state = context.read<FriendshipBloc>().state;
      if (state.outgoingHasMore && !state.isLoadingMore) {
        context.read<FriendshipBloc>().add(LoadOutgoingRequestsEvent(loadMore: true));
      }
    }
  }

  bool get _isBottomIncoming {
    if (!_incomingScrollController.hasClients) return false;
    final maxScroll = _incomingScrollController.position.maxScrollExtent;
    final currentScroll = _incomingScrollController.offset;
    return currentScroll >= (maxScroll * 0.85);
  }

  bool get _isBottomOutgoing {
    if (!_outgoingScrollController.hasClients) return false;
    final maxScroll = _outgoingScrollController.position.maxScrollExtent;
    final currentScroll = _outgoingScrollController.offset;
    return currentScroll >= (maxScroll * 0.85);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: theme.scaffoldBackgroundColor,
        surfaceTintColor: theme.scaffoldBackgroundColor,
        title: Text(
          l10n.friendRequests,
          style: TextStyle(
            color: theme.textTheme.titleLarge?.color,
            fontSize: 20,
            fontWeight: FontWeight.w600,
          ),
        ),
        bottom: TabBar(
          controller: _tabController,
          labelColor: theme.primaryColor,
          unselectedLabelColor: theme.textTheme.bodySmall?.color?.withOpacity(0.6),
          indicatorColor: theme.primaryColor,
          onTap: (index) {
            if (index == 0) {
              context.read<FriendshipBloc>().add(LoadIncomingRequestsEvent());
            } else {
              context.read<FriendshipBloc>().add(LoadOutgoingRequestsEvent());
            }
          },
          tabs: [
            Tab(text: l10n.incoming),
            Tab(text: l10n.outgoing),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildIncomingTab(l10n, theme),
          _buildOutgoingTab(l10n, theme),
        ],
      ),
    );
  }

  Widget _buildIncomingTab(AppLocalizations l10n, ThemeData theme) {
    return BlocBuilder<FriendshipBloc, FriendshipState>(
      builder: (context, state) {
        if (state.status == FriendshipStateStatus.loading && state.incomingRequests.isEmpty) {
          return Center(
            child: CircularProgressIndicator(
              strokeWidth: 2,
              color: theme.primaryColor,
            ),
          );
        }

        if (state.hasError) {
          return EmptyStateWidget(
            icon: Icons.error_outline,
            title: state.errorMessage ?? l10n.anErrorOccurred,
            subtitle: null,
          );
        }

        if (state.incomingRequests.isEmpty) {
          return EmptyStateWidget(
            icon: Icons.inbox_outlined,
            title: l10n.noIncomingRequests,
            subtitle: l10n.noIncomingRequestsSubtitle,
          );
        }

        return RefreshIndicator(
          onRefresh: () async {
            context.read<FriendshipBloc>().add(LoadIncomingRequestsEvent());
          },
          child: ListView.separated(
            controller: _incomingScrollController,
            padding: const EdgeInsets.symmetric(vertical: 8),
            itemCount: state.incomingRequests.length + (state.incomingHasMore ? 1 : 0),
            separatorBuilder: (context, index) => Divider(
              height: 1,
              color: theme.dividerColor.withOpacity(0.1),
              indent: 76,
            ),
            itemBuilder: (context, index) {
              if (index >= state.incomingRequests.length) {
                return Padding(
                  padding: const EdgeInsets.all(16),
                  child: Center(
                    child: SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: theme.primaryColor,
                      ),
                    ),
                  ),
                );
              }

              final request = state.incomingRequests[index];
              return FriendListTile(
                user: request.user,
                subtitle: timeago.format(request.requestedAt),
                trailing: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    IconButton(
                      icon: const Icon(Icons.check, size: 20),
                      onPressed: () {
                        context.read<FriendshipBloc>().add(
                          AcceptFriendRequestEvent(request.friendshipId),
                        );
                      },
                      style: IconButton.styleFrom(
                        backgroundColor: theme.primaryColor,
                        foregroundColor: Colors.white,
                      ),
                    ),
                    const SizedBox(width: 8),
                    IconButton(
                      icon: const Icon(Icons.close, size: 20),
                      onPressed: () {
                        context.read<FriendshipBloc>().add(
                          RejectFriendRequestEvent(request.friendshipId),
                        );
                      },
                      style: IconButton.styleFrom(
                        backgroundColor: theme.cardColor,
                        foregroundColor: theme.textTheme.bodyMedium?.color,
                        side: BorderSide(color: theme.dividerColor),
                      ),
                    ),
                  ],
                ),
              );
            },
          ),
        );
      },
    );
  }

  Widget _buildOutgoingTab(AppLocalizations l10n, ThemeData theme) {
    return BlocBuilder<FriendshipBloc, FriendshipState>(
      builder: (context, state) {
        if (state.status == FriendshipStateStatus.loading && state.outgoingRequests.isEmpty) {
          return Center(
            child: CircularProgressIndicator(
              strokeWidth: 2,
              color: theme.primaryColor,
            ),
          );
        }

        if (state.hasError) {
          return EmptyStateWidget(
            icon: Icons.error_outline,
            title: state.errorMessage ?? l10n.anErrorOccurred,
            subtitle: null,
          );
        }

        if (state.outgoingRequests.isEmpty) {
          return EmptyStateWidget(
            icon: Icons.send_outlined,
            title: l10n.noOutgoingRequests,
            subtitle: l10n.noOutgoingRequestsSubtitle,
          );
        }

        return RefreshIndicator(
          onRefresh: () async {
            context.read<FriendshipBloc>().add(LoadOutgoingRequestsEvent());
          },
          child: ListView.separated(
            controller: _outgoingScrollController,
            padding: const EdgeInsets.symmetric(vertical: 8),
            itemCount: state.outgoingRequests.length + (state.outgoingHasMore ? 1 : 0),
            separatorBuilder: (context, index) => Divider(
              height: 1,
              color: theme.dividerColor.withOpacity(0.1),
              indent: 76,
            ),
            itemBuilder: (context, index) {
              if (index >= state.outgoingRequests.length) {
                return Padding(
                  padding: const EdgeInsets.all(16),
                  child: Center(
                    child: SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: theme.primaryColor,
                      ),
                    ),
                  ),
                );
              }

              final request = state.outgoingRequests[index];
              return FriendListTile(
                user: request.user,
                subtitle: '${l10n.sentAt} ${timeago.format(request.requestedAt)}',
                trailing: IconButton(
                  icon: const Icon(Icons.close, size: 20),
                  onPressed: () {
                    context.read<FriendshipBloc>().add(
                      RemoveFriendshipEvent(request.friendshipId),
                    );
                  },
                  style: IconButton.styleFrom(
                    backgroundColor: theme.cardColor,
                    foregroundColor: theme.textTheme.bodyMedium?.color,
                    side: BorderSide(color: theme.dividerColor),
                  ),
                ),
              );
            },
          ),
        );
      },
    );
  }
}


// ============================================
// FILE: features/friendship/presentation/pages/friends_list_page.dart
// ============================================
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/core/ui/common/empty_state_widget.dart';
import 'package:unitalk/features/auth/presentation/bloc/auth_bloc.dart';
import 'package:unitalk/features/auth/presentation/bloc/auth_state.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_bloc.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_event.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_state.dart';
import 'package:unitalk/features/friendship/presentation/widgets/friend_list_tile.dart';
import 'package:unitalk/l10n/app_localizations.dart';

class FriendsListPage extends StatefulWidget {
  final String? userId;

  const FriendsListPage({
    Key? key,
    this.userId,
  }) : super(key: key);

  @override
  State createState() => _FriendsListPageState();
}

class _FriendsListPageState extends State<FriendsListPage> {
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);

    print('sadf');
    context.read<FriendshipBloc>().add(LoadFriendsListEvent(userId: widget.userId));
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_isBottom) {
      final state = context.read().state;
      if (state.friendsHasMore && !state.isLoadingMore) {
        // ✅ ИЗМЕНЕНО: передаем userId
        context.read().add(
          LoadFriendsListEvent(loadMore: true, userId: widget.userId),
        );
      }
    }
  }

  bool get _isBottom {
    if (!_scrollController.hasClients) return false;
    final maxScroll = _scrollController.position.maxScrollExtent;
    final currentScroll = _scrollController.offset;
    return currentScroll >= (maxScroll * 0.85);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = AppLocalizations.of(context)!;


    final isOwnProfile =
        widget.userId == null || context.read<AuthBloc>().state.user?.id == widget.userId;

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: theme.scaffoldBackgroundColor,
        surfaceTintColor: theme.scaffoldBackgroundColor,
        title: Text(
          l10n.friends,
          style: TextStyle(
            color: theme.textTheme.titleLarge?.color,
            fontSize: 20,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      body: BlocBuilder<FriendshipBloc,FriendshipState>(
        builder: (context, state) {
          if (state.status == FriendshipStateStatus.loading &&
              state.friends.isEmpty) {
            return Center(
              child: CircularProgressIndicator(
                strokeWidth: 2,
                color: theme.primaryColor,
              ),
            );
          }

          if (state.hasError) {
            return EmptyStateWidget(
              icon: Icons.error_outline,
              title: state.errorMessage ?? l10n.anErrorOccurred,
              subtitle: null,
            );
          }

          if (state.friends.isEmpty) {
            return EmptyStateWidget(
              icon: Icons.people_outline,
              title: l10n.noFriendsYet,
              subtitle: isOwnProfile ? l10n.startAddingFriends : null,
            );
          }

          return RefreshIndicator(
            onRefresh: () async {
              // ✅ ИЗМЕНЕНО: передаем userId
              context.read().add(LoadFriendsListEvent(userId: widget.userId));
            },
            child: ListView.separated(
              controller: _scrollController,
              padding: const EdgeInsets.symmetric(vertical: 8),
              itemCount: state.friends.length + (state.friendsHasMore ? 1 : 0),
              separatorBuilder: (context, index) => Divider(
                height: 1,
                color: theme.dividerColor.withOpacity(0.1),
                indent: 76,
              ),
              itemBuilder: (context, index) {
                if (index >= state.friends.length) {
                  return Padding(
                    padding: const EdgeInsets.all(16),
                    child: Center(
                      child: SizedBox(
                        width: 24,
                        height: 24,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          color: theme.primaryColor,
                        ),
                      ),
                    ),
                  );
                }

                final friend = state.friends[index];
                return FriendListTile(user: friend);
              },
            ),
          );
        },
      ),
    );
  }
}



// ============================================
// FILE: features/friendship/presentation/widgets/friend_list_tile.dart
// ============================================
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:unitalk/core/ui/common/user_avatar.dart';
import 'package:unitalk/core/ui/common/user_meta_info.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

class FriendListTile extends StatelessWidget {
  final UserModel user;
  final String? subtitle;
  final Widget? trailing;
  final VoidCallback? onTap;

  const FriendListTile({
    Key? key,
    required this.user,
    this.subtitle,
    this.trailing,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final locale = Localizations.localeOf(context).languageCode;

    return InkWell(
      onTap: onTap ?? () => context.push('/user/${user.id}'),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            UserAvatar(
              photoUrl: user.photoUrl,
              firstName: user.firstName,
              lastName: user.lastName,
              size: 48,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Flexible(
                        child: Text(
                          '${user.firstName ?? ''} ${user.lastName ?? ''}'.trim(),
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w600,
                            color: theme.textTheme.titleLarge?.color,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                      if (user.isVerified == true) ...[
                        const SizedBox(width: 4),
                        Icon(
                          Icons.verified,
                          size: 16,
                          color: theme.primaryColor,
                        ),
                      ],
                    ],
                  ),
                  const SizedBox(height: 4),
                  if (subtitle != null)
                    Text(
                      subtitle!,
                      style: TextStyle(
                        fontSize: 13,
                        color: theme.textTheme.bodySmall?.color?.withOpacity(0.6),
                      ),
                    )
                  else if (user.faculty != null || user.sector != null)
                    UserMetaInfo(
                      faculty: user.faculty?.getLocalizedName(locale),
                      sector: user.sector,
                      fontSize: 13,
                    ),
                ],
              ),
            ),
            if (trailing != null) ...[
              const SizedBox(width: 8),
              trailing!,
            ],
          ],
        ),
      ),
    );
  }
}


// ============================================
// FILE: features/friendship/presentation/widgets/friends_count_button.dart
// ============================================
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:unitalk/l10n/app_localizations.dart';

class FriendsCountButton extends StatelessWidget {
  final int friendsCount;
  final String? userId;
  final bool isDark;

  const FriendsCountButton({
    Key? key,
    required this.friendsCount,
    this.userId,
    this.isDark = false,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return InkWell(
      onTap: () {
        // Открываем список друзей
        context.push('/friends');
      },
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: isDark
              ? Colors.white.withOpacity(0.1)
              : Colors.white.withOpacity(0.2),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: Colors.white.withOpacity(0.2),
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.people_outline,
              size: 20,
              color: isDark ? Colors.white : Colors.white,
            ),
            const SizedBox(width: 8),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  '$friendsCount',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: isDark ? Colors.white : Colors.white,
                    height: 1.2,
                  ),
                ),
                Text(
                  l10n.friends,
                  style: TextStyle(
                    fontSize: 11,
                    color: (isDark ? Colors.white : Colors.white).withOpacity(0.8),
                    height: 1,
                  ),
                ),
              ],
            ),
            const SizedBox(width: 4),
            Icon(
              Icons.chevron_right,
              size: 16,
              color: (isDark ? Colors.white : Colors.white).withOpacity(0.6),
            ),
          ],
        ),
      ),
    );
  }
}


// ============================================
// FILE: features/friendship/presentation/widgets/friendship_button.dart
// ============================================
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_bloc.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_event.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_state.dart'
    show FriendshipState;
import 'package:unitalk/l10n/app_localizations.dart';

import '../../data/model/friendship_model.dart' show FriendshipStatus;

class FriendshipButton extends StatelessWidget {
  final String userId;
  final bool compact;

  const FriendshipButton({Key? key, required this.userId, this.compact = false})
    : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = AppLocalizations.of(context)!;

    return BlocBuilder<FriendshipBloc, FriendshipState>(
      builder: (context, state) {
        final friendshipStatus = state.getFriendshipStatus(userId);

        if (friendshipStatus == null) {
          // Если статус еще не загружен, загружаем его
          context.read<FriendshipBloc>().add(LoadFriendshipStatusEvent(userId));
          return const SizedBox.shrink();
        }

        final status = friendshipStatus.status;
        final isRequester = friendshipStatus.isRequester ?? false;
        final friendshipId = friendshipStatus.friendshipId;

        // Уже друзья
        if (status == FriendshipStatus.accepted) {
          return _buildButton(
            context: context,
            label: compact ? l10n.friends : l10n.removeFriend,
            icon: compact ? Icons.people : Icons.person_remove,
            backgroundColor: theme.cardColor,
            foregroundColor: theme.textTheme.bodyMedium?.color,
            borderColor: theme.dividerColor,
            onPressed: () {
              _showRemoveFriendDialog(context, friendshipId!);
            },
          );
        }

        // Ожидает ответа (текущий пользователь отправил запрос)
        if (status == FriendshipStatus.pending && isRequester) {
          return _buildButton(
            context: context,
            label: compact ? l10n.pending : l10n.cancelRequest,
            icon: compact ? Icons.schedule : Icons.close,
            backgroundColor: theme.cardColor,
            foregroundColor: theme.textTheme.bodyMedium?.color?.withOpacity(
              0.6,
            ),
            borderColor: theme.dividerColor,
            onPressed: () {
              context.read<FriendshipBloc>().add(
                RemoveFriendshipEvent(
                  friendshipId!,
                  userId: userId,
                ), // ✅ ИЗМЕНЕНО
              );
            },
          );
        }

        // Входящий запрос (другой пользователь отправил запрос)
        if (status == FriendshipStatus.pending && !isRequester) {
          return Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildButton(
                context: context,
                label: l10n.accept,
                icon: Icons.check,
                backgroundColor: theme.primaryColor,
                foregroundColor: Colors.white,
                onPressed: () {
                  context.read<FriendshipBloc>().add(
                    AcceptFriendRequestEvent(friendshipId!),
                  );
                },
              ),
              const SizedBox(width: 8),
              _buildButton(
                context: context,
                label: l10n.reject,
                icon: Icons.close,
                backgroundColor: theme.cardColor,
                foregroundColor: theme.textTheme.bodyMedium?.color,
                borderColor: theme.dividerColor,
                onPressed: () {
                  context.read<FriendshipBloc>().add(
                    RejectFriendRequestEvent(friendshipId!),
                  );
                },
              ),
            ],
          );
        }

        // Нет дружбы
        return _buildButton(
          context: context,
          label: compact ? l10n.add : l10n.addFriend,
          icon: compact ? Icons.person_add : Icons.person_add_outlined,
          backgroundColor: theme.primaryColor,
          foregroundColor: Colors.white,
          onPressed: () {
            context.read<FriendshipBloc>().add(SendFriendRequestEvent(userId));
          },
        );
      },
    );
  }

  Widget _buildButton({
    required BuildContext context,
    required String label,
    required IconData icon,
    required Color backgroundColor,
    required Color? foregroundColor,
    Color? borderColor,
    required VoidCallback onPressed,
  }) {
    return compact
        ? IconButton.filled(
            onPressed: onPressed,
            icon: Icon(icon, size: 20),
            style: IconButton.styleFrom(
              backgroundColor: backgroundColor,
              foregroundColor: foregroundColor,
              side: borderColor != null ? BorderSide(color: borderColor) : null,
            ),
          )
        : ElevatedButton.icon(
            onPressed: onPressed,
            icon: Icon(icon, size: 18),
            label: Text(label),
            style: ElevatedButton.styleFrom(
              backgroundColor: backgroundColor,
              foregroundColor: foregroundColor,
              elevation: 0,
              side: borderColor != null ? BorderSide(color: borderColor) : null,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
            ),
          );
  }

  void _showRemoveFriendDialog(BuildContext context, String friendshipId) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text(l10n.removeFriend),
        content: Text(l10n.removeFriendConfirmation),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: Text(l10n.cancel),
          ),
          TextButton(
            onPressed: () {
              context.read<FriendshipBloc>().add(
                RemoveFriendshipEvent(
                  friendshipId,
                  userId: userId,
                ), // ✅ ИЗМЕНЕНО
              );
              Navigator.pop(dialogContext);
            },
            style: TextButton.styleFrom(
              foregroundColor: theme.colorScheme.error,
            ),
            child: Text(l10n.remove),
          ),
        ],
      ),
    );
  }
}



// ============================================
// FILE: features/friendship/data/datasource/friendship_remote_datasource.dart
// ============================================
import 'package:dio/dio.dart';
import 'package:unitalk/features/friendship/data/model/friendship_model.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

class FriendshipRemoteDataSource {
  final Dio dio;

  FriendshipRemoteDataSource({required this.dio});

  // Отправить запрос в друзья
  Future<FriendshipModel> sendFriendRequest(String userId) async {
    try {
      final response = await dio.post('/friends/request/$userId');
      return FriendshipModel.fromJson(response.data['friendship']);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Принять запрос
  Future<FriendshipModel> acceptFriendRequest(String friendshipId) async {
    try {
      final response = await dio.put('/friends/accept/$friendshipId');
      return FriendshipModel.fromJson(response.data['friendship']);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Отклонить запрос
  Future<FriendshipModel> rejectFriendRequest(String friendshipId) async {
    try {
      final response = await dio.put('/friends/reject/$friendshipId');
      return FriendshipModel.fromJson(response.data['friendship']);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Удалить дружбу или отменить запрос
  Future<void> removeFriendship(String friendshipId) async {
    try {
      await dio.delete('/friends/$friendshipId');
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Получить список друзей с пагинацией
  Future<Map<String, dynamic>> getFriendsList({
    int page = 1,
    int limit = 20,
    String? userId, // ✅ ДОБАВИТЬ
  }) async {
    try {
      final endpoint = userId != null
          ? '/friends/list/$userId' // Друзья другого пользователя
          : '/friends/list'; // Свои друзья

      final response = await dio.get(
        endpoint,
        queryParameters: {'page': page, 'limit': limit},
      );
      return response.data as Map<String,dynamic>;
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Получить входящие запросы
  Future<Map<String, dynamic>> getIncomingRequests({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await dio.get(
        '/friends/requests/incoming',
        queryParameters: {'page': page, 'limit': limit},
      );
      return response.data as Map<String, dynamic>;
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Получить исходящие запросы
  Future<Map<String, dynamic>> getOutgoingRequests({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await dio.get(
        '/friends/requests/outgoing',
        queryParameters: {'page': page, 'limit': limit},
      );
      return response.data as Map<String, dynamic>;
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Получить статус дружбы с конкретным пользователем
  Future<FriendshipStatusResponse> getFriendshipStatus(String userId) async {
    try {
      final response = await dio.get('/friends/status/$userId');
      return FriendshipStatusResponse.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  String _handleError(DioException error) {
    if (error.response?.data != null && error.response!.data['error'] != null) {
      return error.response!.data['error'] as String;
    }

    switch (error.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        return 'Connection timeout. Please try again.';

      case DioExceptionType.connectionError:
        return 'No internet connection.';

      case DioExceptionType.badResponse:
        final statusCode = error.response?.statusCode;
        if (statusCode == 404) return 'User not found.';
        if (statusCode == 403) return 'Access denied.';
        return 'Request failed. Please try again.';

      default:
        return 'An unexpected error occurred.';
    }
  }
}



// ============================================
// FILE: features/friendship/data/repository/friendship_repository_impl.dart
// ============================================
import 'package:dartz/dartz.dart';
import 'package:unitalk/core/failure/failure.dart';
import 'package:unitalk/features/friendship/data/datasource/friendship_remote_datasource.dart';
import 'package:unitalk/features/friendship/data/model/friendship_model.dart';
import 'package:unitalk/features/friendship/domain/repository/friendship_repository.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

class FriendshipRepositoryImpl implements FriendshipRepository {
  final FriendshipRemoteDataSource remoteDataSource;

  FriendshipRepositoryImpl(this.remoteDataSource);

  @override
  Future<Either<Failure, FriendshipModel>> sendFriendRequest(String userId) async {
    try {
      final result = await remoteDataSource.sendFriendRequest(userId);
      return Right(result);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, FriendshipModel>> acceptFriendRequest(String friendshipId) async {
    try {
      final result = await remoteDataSource.acceptFriendRequest(friendshipId);
      return Right(result);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, FriendshipModel>> rejectFriendRequest(String friendshipId) async {
    try {
      final result = await remoteDataSource.rejectFriendRequest(friendshipId);
      return Right(result);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> removeFriendship(String friendshipId) async {
    try {
      await remoteDataSource.removeFriendship(friendshipId);
      return const Right(null);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<UserModel>>> getFriendsList({
    int page = 1,
    int limit = 20,
    String? userId, // ✅ ДОБАВИТЬ

  }) async {
    try {
      final response = await remoteDataSource.getFriendsList(
        page: page,
        limit: limit,
        userId: userId,
      );

      final friends = (response['friends'] as List)
          .map((json) => UserModel.fromJson(json as Map<String, dynamic>))
          .toList();

      return Right(friends);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<FriendRequestModel>>> getIncomingRequests({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await remoteDataSource.getIncomingRequests(
        page: page,
        limit: limit,
      );

      final requests = (response['requests'] as List)
          .map((json) => FriendRequestModel.fromJson(json as Map<String, dynamic>))
          .toList();

      return Right(requests);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<FriendRequestModel>>> getOutgoingRequests({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await remoteDataSource.getOutgoingRequests(
        page: page,
        limit: limit,
      );

      final requests = (response['requests'] as List)
          .map((json) => FriendRequestModel.fromJson(json as Map<String, dynamic>))
          .toList();

      return Right(requests);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, FriendshipStatusResponse>> getFriendshipStatus(String userId) async {
    try {
      final result = await remoteDataSource.getFriendshipStatus(userId);
      return Right(result);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }
}


// ============================================
// FILE: features/friendship/data/model/friendship_model.dart
// ============================================
// lib/features/friendship/data/models/friendship_model.dart
import 'package:json_annotation/json_annotation.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

part 'friendship_model.g.dart';

enum FriendshipStatus {
  @JsonValue('none')
  none,
  @JsonValue('pending')
  pending,
  @JsonValue('accepted')
  accepted,
  @JsonValue('rejected')
  rejected,
}

@JsonSerializable()
class FriendshipModel {
  @JsonKey(name: '_id')
  final String? id;
  final FriendshipStatus status;
  final String? friendshipId;
  final bool? isRequester;
  final DateTime? createdAt;
  final DateTime? acceptedAt;

  FriendshipModel({
    this.id,
    required this.status,
    this.friendshipId,
    this.isRequester,
    this.createdAt,
    this.acceptedAt,
  });

  factory FriendshipModel.fromJson(Map<String, dynamic> json) =>
      _$FriendshipModelFromJson(json);

  Map<String, dynamic> toJson() => _$FriendshipModelToJson(this);

  bool get isPending => status == FriendshipStatus.pending;
  bool get isAccepted => status == FriendshipStatus.accepted;
  bool get isNone => status == FriendshipStatus.none;
}

@JsonSerializable()
class FriendshipStatusResponse {
  final FriendshipStatus status;
  final bool isFriend;
  final String? friendshipId;
  final bool? isRequester;
  final DateTime? createdAt;
  final DateTime? acceptedAt;

  FriendshipStatusResponse({
    required this.status,
    required this.isFriend,
    this.friendshipId,
    this.isRequester,
    this.createdAt,
    this.acceptedAt,
  });

  factory FriendshipStatusResponse.fromJson(Map<String, dynamic> json) =>
      _$FriendshipStatusResponseFromJson(json);

  Map<String, dynamic> toJson() => _$FriendshipStatusResponseToJson(this);
}

@JsonSerializable()
class FriendRequestModel {
  final String friendshipId;
  final UserModel user;
  final DateTime requestedAt;

  FriendRequestModel({
    required this.friendshipId,
    required this.user,
    required this.requestedAt,
  });

  factory FriendRequestModel.fromJson(Map<String, dynamic> json) =>
      _$FriendRequestModelFromJson(json);

  Map<String, dynamic> toJson() => _$FriendRequestModelToJson(this);
}


// ============================================
// FILE: features/friendship/domain/repository/friendship_repository.dart
// ============================================
import 'package:dartz/dartz.dart';
import 'package:unitalk/core/failure/failure.dart';
import 'package:unitalk/features/friendship/data/model/friendship_model.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

abstract class FriendshipRepository {
  // Управление дружбой
  Future<Either<Failure, FriendshipModel>> sendFriendRequest(String userId);
  Future<Either<Failure, FriendshipModel>> acceptFriendRequest(String friendshipId);
  Future<Either<Failure, FriendshipModel>> rejectFriendRequest(String friendshipId);
  Future<Either<Failure, void>> removeFriendship(String friendshipId);

  // Получение данных
  Future<Either<Failure, List<UserModel>>> getFriendsList({
    int page = 1,
    int limit = 20,
    String? userId,
  });

  Future<Either<Failure, List<FriendRequestModel>>> getIncomingRequests({
    int page = 1,
    int limit = 20,
  });

  Future<Either<Failure, List<FriendRequestModel>>> getOutgoingRequests({
    int page = 1,
    int limit = 20,
  });

  Future<Either<Failure, FriendshipStatusResponse>> getFriendshipStatus(String userId);
}


// ============================================
// FILE: features/notifications/presentation/bloc/notification_bloc.dart
// ============================================
import 'dart:math';

import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/features/notifications/domain/notifcation_repository.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_event.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_state.dart';


class NotificationBloc extends Bloc<NotificationEvent, NotificationState> {
  final NotificationRepository notificationRepository;

  NotificationBloc({required this.notificationRepository})
      : super(NotificationState.initial()) {
    on<GetNotificationSettingsEvent>(_onGetSettings);
    on<UpdateNotificationSettingsEvent>(_onUpdateSettings);
    on<SaveFcmTokenEvent>(_onSaveFcmToken);
    on<RemoveFcmTokenEvent>(_onRemoveFcmToken);
    on<GetNotificationsEvent>(_onGetNotifications);
    on<MarkNotificationAsReadEvent>(_onMarkAsRead);
    on<MarkAllNotificationsAsReadEvent>(_onMarkAllAsRead);
    on<DeleteNotificationEvent>(_onDeleteNotification);
    on<DeleteAllNotificationsEvent>(_onDeleteAllNotifications);
    on<RefreshNotificationsEvent>(_onRefreshNotifications);
    on<GetUnreadCountEvent>(_onGetUnreadCount);
    on<HandleIncomingNotificationEvent>(_onHandleIncomingNotification);
  }

  Future<void> _onGetSettings(
      GetNotificationSettingsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    emit(state.copyWith(status: NotificationStatus.loading));

    final result = await notificationRepository.getSettings();

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (settings) => emit(state.copyWith(
        status: NotificationStatus.success,
        settings: settings,
      )),
    );
  }

  Future<void> _onUpdateSettings(
      UpdateNotificationSettingsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    emit(state.copyWith(status: NotificationStatus.loading));

    final result = await notificationRepository.updateSettings(
      enabled: event.enabled,
      newPosts: event.newPosts,
      newComments: event.newComments,
      newLikes: event.newLikes,
      commentReplies: event.commentReplies,
      mentions: event.mentions,
      chatMessages: event.chatMessages,
      chatMentions: event.chatMentions,
    );

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (settings) => emit(state.copyWith(
        status: NotificationStatus.success,
        settings: settings,
      )),
    );
  }

  Future<void> _onSaveFcmToken(
      SaveFcmTokenEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result = await notificationRepository.saveFcmToken(event.fcmToken);

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) => null,
    );
  }

  Future<void> _onRemoveFcmToken(
      RemoveFcmTokenEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result = await notificationRepository.removeFcmToken();

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) => null,
    );
  }

  Future<void> _onGetNotifications(
      GetNotificationsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    if (event.loadMore) {
      if (!state.hasMore) return;
      emit(state.copyWith(status: NotificationStatus.loadingMore));
    } else {
      emit(state.copyWith(status: NotificationStatus.loading));
    }

    final result = await notificationRepository.getNotifications(
      page: event.page,
      limit: 20,
      unreadOnly: event.unreadOnly,
    );

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (response) {
        final newNotifications = event.loadMore
            ? [...state.notifications, ...response.notifications]
            : response.notifications;

        emit(state.copyWith(
          status: NotificationStatus.success,
          notifications: newNotifications,
          unreadCount: response.unreadCount,
          currentPage: state.currentPage + 1,
          hasMore: response.notifications.length >= 20
        ));
      },
    );
  }

  Future<void> _onMarkAsRead(
      MarkNotificationAsReadEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result =
    await notificationRepository.markAsRead(event.notificationId);

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (updatedNotification) {
        final updatedList = state.notifications.map((n) {
          if (n.id == updatedNotification.id) {
            return updatedNotification;
          }
          return n;
        }).toList();

        final newUnreadCount = state.unreadCount > 0 ? state.unreadCount - 1 : 0;

        emit(state.copyWith(
          notifications: updatedList,
          unreadCount: newUnreadCount,
        ));
      },
    );
  }

  Future<void> _onMarkAllAsRead(
      MarkAllNotificationsAsReadEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result = await notificationRepository.markAllAsRead();

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) {
        final updatedList = state.notifications
            .map((n) => n.copyWith(isRead: true))
            .toList();

        emit(state.copyWith(
          notifications: updatedList,
          unreadCount: 0,
        ));
      },
    );
  }

  Future<void> _onDeleteNotification(
      DeleteNotificationEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result =
    await notificationRepository.deleteNotification(event.notificationId);

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) {
        final notification = state.notifications
            .firstWhere((n) => n.id == event.notificationId);

        final updatedList = state.notifications
            .where((n) => n.id != event.notificationId)
            .toList();

        final newUnreadCount = !notification.isRead && state.unreadCount > 0
            ? state.unreadCount - 1
            : state.unreadCount;

        emit(state.copyWith(
          notifications: updatedList,
          unreadCount: newUnreadCount,
        ));
      },
    );
  }

  Future<void> _onDeleteAllNotifications(
      DeleteAllNotificationsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    emit(state.copyWith(status: NotificationStatus.loading));

    final result = await notificationRepository.deleteAllNotifications();

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) => emit(state.copyWith(
        status: NotificationStatus.success,
        notifications: [],
        unreadCount: 0,
      )),
    );
  }

  Future<void> _onRefreshNotifications(
      RefreshNotificationsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    print('sdfasfasf');
    final result = await notificationRepository.getNotifications(
      page: 1,
      unreadOnly: false,
    );

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (response) {
        emit(state.copyWith(
          status: NotificationStatus.success,
          notifications: response.notifications,
          unreadCount: response.unreadCount,
          currentPage: 1,
          hasMore: response.notifications.length < 20,
        ));
      },
    );
  }

  Future<void> _onGetUnreadCount(
      GetUnreadCountEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result = await notificationRepository.getUnreadCount();

    result.fold(
          (failure) => null,
          (count) => emit(state.copyWith(unreadCount: count)),
    );
  }

  Future<void> _onHandleIncomingNotification(
      HandleIncomingNotificationEvent event,
      Emitter<NotificationState> emit,
      ) async {
    // Increment unread count when new notification arrives
    emit(state.copyWith(unreadCount: state.unreadCount + 1));

    // Optionally refresh notifications list
    add(RefreshNotificationsEvent());
  }
}


// ============================================
// FILE: features/notifications/presentation/bloc/notification_event.dart
// ============================================
abstract class NotificationEvent {}

// Settings Events
class GetNotificationSettingsEvent extends NotificationEvent {}

class UpdateNotificationSettingsEvent extends NotificationEvent {
  final bool? enabled;
  final bool? newPosts;
  final bool? newComments;
  final bool? newLikes;
  final bool? commentReplies;
  final bool? mentions;
  final bool? chatMessages;
  final bool? chatMentions;

  UpdateNotificationSettingsEvent({
    this.enabled,
    this.newPosts,
    this.newComments,
    this.newLikes,
    this.commentReplies,
    this.mentions,
    this.chatMessages,
    this.chatMentions,
  });
}

class SaveFcmTokenEvent extends NotificationEvent {
  final String fcmToken;

  SaveFcmTokenEvent(this.fcmToken);
}

class RemoveFcmTokenEvent extends NotificationEvent {}

// Notification List Events
class GetNotificationsEvent extends NotificationEvent {
  final int page;
  final bool unreadOnly;
  final bool loadMore;

  GetNotificationsEvent({
    this.page = 1,
    this.unreadOnly = false,
    this.loadMore = false,
  });
}

class MarkNotificationAsReadEvent extends NotificationEvent {
  final String notificationId;

  MarkNotificationAsReadEvent(this.notificationId);
}

class MarkAllNotificationsAsReadEvent extends NotificationEvent {}

class DeleteNotificationEvent extends NotificationEvent {
  final String notificationId;

  DeleteNotificationEvent(this.notificationId);
}

class DeleteAllNotificationsEvent extends NotificationEvent {}

class RefreshNotificationsEvent extends NotificationEvent {}

class GetUnreadCountEvent extends NotificationEvent {}

// Handle incoming notification from FCM
class HandleIncomingNotificationEvent extends NotificationEvent {
  final Map<String, dynamic> data;

  HandleIncomingNotificationEvent(this.data);
}


// ============================================
// FILE: features/notifications/presentation/bloc/notification_state.dart
// ============================================
import 'package:unitalk/features/notifications/model/notification_model.dart';
import 'package:unitalk/features/notifications/model/notification_settings_model.dart';

enum NotificationStatus {
  initial,
  loading,
  loadingMore,
  success,
  failure,
}

class NotificationState {
  final NotificationStatus status;
  final List<NotificationModel> notifications;
  final NotificationSettingsModel? settings;
  final int unreadCount;
  final int currentPage;
  final bool hasMore;
  final String? errorMessage;

  NotificationState({
    required this.status,
    required this.notifications,
    this.settings,
    required this.unreadCount,
    required this.currentPage,
    required this.hasMore,
    this.errorMessage,
  });

  factory NotificationState.initial() {
    return NotificationState(
      status: NotificationStatus.initial,
      notifications: [],
      settings: null,
      unreadCount: 0,
      currentPage: 1,
      hasMore: true,
      errorMessage: null,
    );
  }

  NotificationState copyWith({
    NotificationStatus? status,
    List<NotificationModel>? notifications,
    NotificationSettingsModel? settings,
    int? unreadCount,
    int? currentPage,
    bool? hasMore,
    String? errorMessage,
  }) {
    return NotificationState(
      status: status ?? this.status,
      notifications: notifications ?? this.notifications,
      settings: settings ?? this.settings,
      unreadCount: unreadCount ?? this.unreadCount,
      currentPage: currentPage ?? this.currentPage,
      hasMore: hasMore ?? this.hasMore,
      errorMessage: errorMessage,
    );
  }
}


// ============================================
// FILE: features/notifications/presentation/page/notifications_page.dart
// ============================================
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:timeago/timeago.dart' as timeago;
import 'package:unitalk/core/ui/common/confirm_delete_dialog.dart';
import 'package:unitalk/core/ui/common/empty_state_widget.dart';
import 'package:unitalk/core/ui/common/error_state_widget.dart';
import 'package:unitalk/core/ui/common/user_avatar.dart';
import 'package:unitalk/features/notifications/model/notification_model.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_bloc.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_event.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_state.dart';
import 'package:unitalk/l10n/app_localizations.dart';

class NotificationsPage extends StatefulWidget {
  const NotificationsPage({Key? key}) : super(key: key);

  @override
  State<NotificationsPage> createState() => _NotificationsPageState();
}

class _NotificationsPageState extends State<NotificationsPage> {
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  Future<void> _onRefresh() async {
    context.read<NotificationBloc>().add(RefreshNotificationsEvent());

    await context.read<NotificationBloc>().stream.firstWhere(
      (state) => state.status != NotificationStatus.loading,
    );
  }

  void _onScroll() {
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent * 0.9) {
      final bloc = context.read<NotificationBloc>();
      if (bloc.state.hasMore &&
          bloc.state.status != NotificationStatus.loadingMore) {
        bloc.add(
          GetNotificationsEvent(
            page: bloc.state.currentPage + 1,
            loadMore: true,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      appBar: AppBar(
        backgroundColor: theme.scaffoldBackgroundColor,
        elevation: 0,
        centerTitle: false,
        title: Text(
          l10n.notifications,
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.w600,
            letterSpacing: -0.5,
          ),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.settings_outlined, size: 22),
            onPressed: () => context.push('/notification-settings'),
          ),
          PopupMenuButton(
            icon: const Icon(Icons.more_vert, size: 22),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
            ),
            itemBuilder: (context) => [
              PopupMenuItem(
                value: 'mark_all_read',
                child: Row(
                  children: [
                    Icon(
                      Icons.done_all,
                      size: 20,
                      color: theme.colorScheme.onSurface.withOpacity(0.7),
                    ),
                    const SizedBox(width: 12),
                    Text(l10n.markAllAsRead),
                  ],
                ),
              ),
              PopupMenuItem(
                value: 'delete_all',
                child: Row(
                  children: [
                    Icon(
                      Icons.delete_outline,
                      size: 20,
                      color: theme.colorScheme.error,
                    ),
                    const SizedBox(width: 12),
                    Text(
                      l10n.deleteAll,
                      style: TextStyle(color: theme.colorScheme.error),
                    ),
                  ],
                ),
              ),
            ],
            onSelected: (value) {
              final bloc = context.read<NotificationBloc>();
              if (value == 'mark_all_read') {
                bloc.add(MarkAllNotificationsAsReadEvent());
              } else if (value == 'delete_all') {
                _showDeleteAllDialog(context);
              }
            },
          ),
          const SizedBox(width: 4),
        ],
      ),
      body: LayoutBuilder(
        builder: (context, constraints) => RefreshIndicator(
          onRefresh: () => _onRefresh(),
          child: SingleChildScrollView(
            physics: const AlwaysScrollableScrollPhysics(),
            child: ConstrainedBox(
              constraints: BoxConstraints(
                minHeight: constraints.maxHeight,
                maxHeight: constraints.maxHeight,
              ),
              child: Column(
                children: [
                  Container(
                    height: 1,
                    color: theme.colorScheme.onSurface.withOpacity(0.08),
                  ),
                  Expanded(
                    child: BlocBuilder<NotificationBloc, NotificationState>(
                      builder: (context, state) {
                        if (state.status == NotificationStatus.loading) {
                          return const Center(
                            child: CircularProgressIndicator(),
                          );
                        }

                        if (state.status == NotificationStatus.failure) {
                          return ErrorStateWidget(
                            message:
                                state.errorMessage ??
                                l10n.errorLoadingNotifications,
                            onRetry: () {
                              context.read<NotificationBloc>().add(
                                RefreshNotificationsEvent(),
                              );
                            },
                            retryButtonText: l10n.retry,
                          );
                        }

                        if (state.notifications.isEmpty) {
                          return EmptyStateWidget(
                            icon: Icons.notifications_off_outlined,
                            title: l10n.noNotifications,
                            subtitle: l10n.allCaughtUp,
                            iconColor: theme.colorScheme.primary.withOpacity(
                              0.6,
                            ),
                          );
                        }

                        return RefreshIndicator(
                          onRefresh: () => _onRefresh(),
                          child: ListView.separated(
                            controller: _scrollController,
                            physics: AlwaysScrollableScrollPhysics(),
                            itemCount:
                                state.notifications.length +
                                (state.status == NotificationStatus.loadingMore
                                    ? 1
                                    : 0),
                            separatorBuilder: (context, index) => Container(
                              height: 1,
                              margin: const EdgeInsets.symmetric(horizontal: 20),
                              color: theme.colorScheme.onSurface.withOpacity(
                                0.06,
                              ),
                            ),
                            itemBuilder: (context, index) {
                              if (index == state.notifications.length) {
                                return const Center(
                                  child: Padding(
                                    padding: EdgeInsets.all(24.0),
                                    child: CircularProgressIndicator(
                                      strokeWidth: 2,
                                    ),
                                  ),
                                );
                              }

                              final notification = state.notifications[index];
                              return Dismissible(
                                key: Key(notification.id),
                                direction: DismissDirection.endToStart,
                                background: Container(
                                  color: theme.colorScheme.error.withOpacity(0.1),
                                  alignment: Alignment.centerRight,
                                  padding: const EdgeInsets.only(right: 24.0),
                                  child: Icon(
                                    Icons.delete_outline,
                                    color: theme.colorScheme.error,
                                    size: 22,
                                  ),
                                ),
                                confirmDismiss: (direction) async {
                                  return await ConfirmDeleteDialog.show(
                                    context,
                                    title: l10n.deleteNotification,
                                    content: l10n.deleteNotificationConfirm,
                                    onConfirm: () {},
                                  );
                                },
                                onDismissed: (direction) {
                                  context.read<NotificationBloc>().add(
                                    DeleteNotificationEvent(notification.id),
                                  );
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                      content: Text(l10n.notificationDeleted),
                                      behavior: SnackBarBehavior.floating,
                                      shape: RoundedRectangleBorder(
                                        borderRadius: BorderRadius.circular(12),
                                      ),
                                    ),
                                  );
                                },
                                child: NotificationTile(
                                  notification: notification,
                                ),
                              );
                            },
                          ),
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _showDeleteAllDialog(BuildContext context) async {
    final l10n = AppLocalizations.of(context)!;
    final confirmed = await ConfirmDeleteDialog.show(
      context,
      title: l10n.deleteAllNotifications,
      content: l10n.deleteAllNotificationsConfirm,
      onConfirm: () {},
    );

    if (confirmed == true && context.mounted) {
      context.read<NotificationBloc>().add(DeleteAllNotificationsEvent());
    }
  }
}

class NotificationTile extends StatelessWidget {
  final NotificationModel notification;

  const NotificationTile({super.key, required this.notification});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // Настройка локализации для timeago
    timeago.setLocaleMessages('ru', timeago.RuMessages());
    timeago.setLocaleMessages('az', timeago.AzMessages());

    // Determine display info
    String displayName = 'Anonymous';
    String? avatarUrl;
    String? firstName;
    String? lastName;
    bool isAnonymous = false;

    if (notification.post != null) {
      isAnonymous = notification.post!.isAnonymous;
    }

    if (!isAnonymous && notification.fromUser != null) {
      final user = notification.fromUser!;
      firstName = user.firstName;
      lastName = user.lastName;
      if (firstName != null && lastName != null) {
        displayName = '$firstName $lastName';
      }
      avatarUrl = user.photoUrl;
    }

    return InkWell(
      onTap: () => _navigateToNotificationTarget(context, notification),
      child: Container(
        color: notification.isRead
            ? null
            : theme.colorScheme.primary.withOpacity(0.04),
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Avatar
            UserAvatar(
              photoUrl: isAnonymous ? null : avatarUrl,
              firstName: isAnonymous ? null : firstName,
              lastName: isAnonymous ? null : lastName,
              size: 44,
            ),
            const SizedBox(width: 14),
            // Content
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    notification.title,
                    style: theme.textTheme.bodyLarge?.copyWith(
                      fontWeight: notification.isRead
                          ? FontWeight.w500
                          : FontWeight.w600,
                      letterSpacing: 0,
                    ),
                  ),
                  const SizedBox(height: 6),
                  Text(
                    notification.body,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: theme.colorScheme.onSurface.withOpacity(0.6),
                      letterSpacing: 0.1,
                      height: 1.4,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      if (!isAnonymous) ...[
                        Text(
                          displayName,
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurface.withOpacity(0.5),
                            fontWeight: FontWeight.w500,
                            letterSpacing: 0.1,
                          ),
                        ),
                        Text(
                          ' • ',
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurface.withOpacity(0.5),
                          ),
                        ),
                      ],
                      Text(
                        timeago.format(
                          notification.createdAt,
                          locale: Localizations
                              .localeOf(context)
                              .languageCode,
                        ),
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.5),
                          letterSpacing: 0.1,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
            // Thumbnail
            if (notification.post?.imageUrl != null) ...[
              const SizedBox(width: 14),
              ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: CachedNetworkImage(
                  imageUrl: notification.post!.imageUrl!,
                  width: 56,
                  height: 56,
                  fit: BoxFit.cover,
                  errorWidget: (context, error, stackTrace) {
                    return Container(
                      width: 56,
                      height: 56,
                      decoration: BoxDecoration(
                        color: theme.colorScheme.onSurface.withOpacity(0.08),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Icon(
                        Icons.image_outlined,
                        color: theme.colorScheme.onSurface.withOpacity(0.3),
                        size: 24,
                      ),
                    );
                  },
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  void _navigateToNotificationTarget(BuildContext context,
      NotificationModel notification,) {
    // Помечаем как прочитанное
    if (!notification.isRead) {
      context.read<NotificationBloc>().add(
        MarkNotificationAsReadEvent(notification.id),
      );
    }

    // Навигация в зависимости от типа
    switch (notification.type) {
      case 'new_post':
      case 'new_comment':
      case 'new_comment_like':
      case 'new_like':
      case 'comment_reply':
      case 'mention':
        if (notification.postId != null && notification.postId!.isNotEmpty) {
          context.push('/post/${notification.postId}');
        } else {
          _showNavigationError(context, 'Post not found');
        }
        break;

      case 'new_chat_message':
      case 'chat_mention':
        context.go('/chat');
        break;

      default:
        print('Unknown notification type: ${notification.type}');
        _showNavigationError(context, 'Cannot open this notification');
    }
  }

  void _showNavigationError(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        duration: const Duration(seconds: 2),
      ),
    );
  }
}



// ============================================
// FILE: features/notifications/model/notification_model.dart
// ============================================
import 'package:json_annotation/json_annotation.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';
import 'package:unitalk/features/feed/data/model/post_model.dart';

part 'notification_model.g.dart';

@JsonSerializable()
class NotificationModel {
  @JsonKey(name: '_id')
  final String id;
  final String userId;
  final String type;
  final String title;
  final String body;
  final String? postId;
  final String? commentId;
  final String? fromUserId;
  final bool isRead;
  final bool isSent;
  final DateTime? sentAt;
  final String language;
  final DateTime createdAt;
  final DateTime updatedAt;

  // Populated fields
  @JsonKey(includeFromJson: true, includeToJson: false)
  final UserModel? fromUser;
  @JsonKey(includeFromJson: true, includeToJson: false)
  final PostModel? post;

  NotificationModel({
    required this.id,
    required this.userId,
    required this.type,
    required this.title,
    required this.body,
    this.postId,
    this.commentId,
    this.fromUserId,
    required this.isRead,
    required this.isSent,
    this.sentAt,
    required this.language,
    required this.createdAt,
    required this.updatedAt,
    this.fromUser,
    this.post,
  });


  factory NotificationModel.fromJson(Map<String,dynamic> json) => _$NotificationModelFromJson(json);
  Map<String, dynamic> toJson() => _$NotificationModelToJson(this);

  NotificationModel copyWith({
    String? id,
    String? userId,
    String? type,
    String? title,
    String? body,
    String? postId,
    String? commentId,
    String? fromUserId,
    bool? isRead,
    bool? isSent,
    DateTime? sentAt,
    String? language,
    DateTime? createdAt,
    DateTime? updatedAt,
    UserModel? fromUser,
    PostModel? post,
  }) {
    return NotificationModel(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      type: type ?? this.type,
      title: title ?? this.title,
      body: body ?? this.body,
      postId: postId ?? this.postId,
      commentId: commentId ?? this.commentId,
      fromUserId: fromUserId ?? this.fromUserId,
      isRead: isRead ?? this.isRead,
      isSent: isSent ?? this.isSent,
      sentAt: sentAt ?? this.sentAt,
      language: language ?? this.language,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      fromUser: fromUser ?? this.fromUser,
      post: post ?? this.post,
    );
  }
}



// ============================================
// FILE: core/router/app_router.dart
// ============================================
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/core/di/service_locator.dart';
import 'package:unitalk/core/ui/common/fullscreen_image_viewer.dart';
import 'package:unitalk/core/ui/common/fullscreen_video_player.dart';
import 'package:unitalk/features/auth/presentation/bloc/auth_bloc.dart';
import 'package:unitalk/features/auth/presentation/bloc/auth_state.dart';
import 'package:go_router/go_router.dart';
import 'package:unitalk/features/auth/presentation/edit_profile_page.dart';
import 'package:unitalk/features/auth/presentation/page/about_page.dart';
import 'package:unitalk/features/auth/presentation/page/auth_page.dart';
import 'package:unitalk/features/auth/presentation/page/complete_profile_page.dart';
import 'package:unitalk/features/auth/presentation/page/delete_account_page.dart';
import 'package:unitalk/features/auth/presentation/page/privacy_policy_page.dart';
import 'package:unitalk/features/auth/presentation/profile_page.dart';
import 'package:unitalk/features/auth/presentation/verification_page.dart';
import 'package:unitalk/features/chat/presentation/page/chat_participants_page.dart';
import 'package:unitalk/features/chat/presentation/page/faculty_chat_screen.dart';
import 'package:unitalk/features/feed/presentation/bloc/announcement/announcement_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/comment/comment_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/comment_likers/comment_likers_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/post/post_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/post_likers/post_likers_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/user_profile/user_profile_bloc.dart';
import 'package:unitalk/features/feed/presentation/page/comment_likers_page.dart';
import 'package:unitalk/features/feed/presentation/page/create_post_page.dart';
import 'package:unitalk/features/feed/presentation/page/feed_page.dart';
import 'package:unitalk/features/feed/presentation/page/other_profile_screen.dart';
import 'package:unitalk/features/feed/presentation/page/post_detail_page.dart';
import 'package:unitalk/features/feed/presentation/page/post_likers_page.dart';
import 'package:unitalk/features/friendship/presentation/pages/friend_requests_page.dart';
import 'package:unitalk/features/friendship/presentation/pages/friends_list_page.dart';
import 'package:unitalk/features/home/home_page.dart';
import 'package:unitalk/features/notifications/presentation/page/notification_settings_page.dart';
import 'package:unitalk/features/notifications/presentation/page/notifications_page.dart';
import 'package:unitalk/features/report/presentation/page/blocked_users_page.dart';
import 'package:unitalk/features/report/presentation/page/my_reports_page.dart';
import 'package:unitalk/features/search/presentation/page/user_search_page.dart';
import 'package:unitalk/features/support/presentation/page/create_support_message_page.dart';
import 'package:unitalk/features/support/presentation/page/support_help_page.dart';
import 'package:unitalk/features/support/presentation/page/support_message_details_page.dart';
import 'package:unitalk/splash_page.dart';

class GoRouterRefreshStream extends ChangeNotifier {
  GoRouterRefreshStream(Stream<dynamic> stream) {
    notifyListeners();
    _subscription = stream.asBroadcastStream().listen(
      (dynamic _) => notifyListeners(),
    );
  }

  late final StreamSubscription<dynamic> _subscription;

  @override
  void dispose() {
    _subscription.cancel();
    super.dispose();
  }
}

final feedPageKey = GlobalKey<FeedPageState>();

final GoRouter router = GoRouter(
  initialLocation: '/splash',
  refreshListenable: GoRouterRefreshStream(sl<AuthBloc>().stream),
  navigatorKey: GlobalKey<NavigatorState>(),

  routes: [
    // === SPLASH & AUTH ===
    GoRoute(path: '/splash', builder: (context, state) => const SplashPage()),
    GoRoute(
      path: '/auth',
      builder: (context, state) => const IntroductionPage(),
    ),
    GoRoute(
      path: '/introduction',
      name: 'introduction',
      builder: (context, state) => const IntroductionPage(),
    ),
    GoRoute(
      path: '/profile-setup/name',
      name: 'profile-setup-name',
      builder: (context, state) => const CompleteProfilePage(),
    ),
    GoRoute(
      path: '/profile-verification',
      builder: (context, state) => const VerificationPage(),
    ),

    // === MAIN APP WITH BOTTOM NAV ===
    StatefulShellRoute.indexedStack(
      builder: (context, state, navigationShell) {
        return ScaffoldWithNavBar(navigationShell: navigationShell);
      },
      branches: [
        // === FEED BRANCH ===
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/feed',
              pageBuilder: (context, state) => NoTransitionPage(
                key: state.pageKey,
                child: BlocProvider(
                  create: (context) => sl<AnnouncementBloc>(),
                  child: BlocProvider(
                    create: (context) => sl<PostBloc>(),
                    child: FeedPage(key: feedPageKey),
                  ),
                ),
              ),
            ),
          ],
        ),

        // === SEARCH BRANCH ===
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/search',
              pageBuilder: (context, state) => NoTransitionPage(
                key: state.pageKey,
                child: const UserSearchPage(),
              ),
            ),
          ],
        ),

        // === CHAT BRANCH ===
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/chat',
              pageBuilder: (context, state) =>
                  NoTransitionPage(key: state.pageKey, child: const ChatPage()),
            ),
          ],
        ),

        // === PROFILE BRANCH ===
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/profile',
              pageBuilder: (context, state) => NoTransitionPage(
                key: state.pageKey,
                child: BlocProvider(
                  create: (context) => sl<PostBloc>(),
                  child: const ProfilePage(),
                ),
              ),
            ),
          ],
        ),
      ],
    ),

    // === STANDALONE ROUTES (outside bottom nav) ===

    // Notifications
    GoRoute(
      path: '/notifications',
      builder: (context, state) => const NotificationsPage(),
    ),
    GoRoute(
      path: '/notification-settings',
      builder: (context, state) => const NotificationSettingsPage(),
    ),

    // Posts
    GoRoute(
      path: '/create-post',
      builder: (context, state) => BlocProvider(
        create: (context) => sl<PostBloc>(),
        child: CreatePostPage(),
      ),
    ),
    GoRoute(
      path: '/post/:id',
      builder: (context, state) {
        final postId = state.pathParameters['id']!;
        return MultiBlocProvider(
          providers: [
            BlocProvider(create: (context) => sl<CommentBloc>()),
            BlocProvider(create: (context) => sl<PostBloc>()),
          ],
          child: PostDetailPage(postId: postId),
        );
      },
    ),
    GoRoute(
      path: '/post/:id/likers',
      builder: (context, state) {
        final postId = state.pathParameters['id']!;
        return BlocProvider(
          create: (context) => sl<PostLikersBloc>(),
          child: PostLikersPage(postId: postId),
        );
      },
    ),
    GoRoute(
      path: '/comment/:id/likers',
      builder: (context, state) {
        final commentId = state.pathParameters['id']!;
        return BlocProvider(
          create: (context) => sl<CommentLikersBloc>(),
          child: CommentLikersPage(commentId: commentId),
        );
      },
    ),

    GoRoute(
      path: '/blocked-users',
      builder: (context, state) => const BlockedUsersPage(),
    ),
    GoRoute(
      path: '/my-reports',
      builder: (context, state) => const MyReportsPage(),
    ),

    // Users
    GoRoute(
      path: '/user/:id',
      builder: (context, state) {
        final userId = state.pathParameters['id']!;
        return MultiBlocProvider(
          providers: [
            BlocProvider(create: (context) => sl<UserProfileBloc>()),
            BlocProvider(create: (context) => sl<PostBloc>()),
          ],
          child: OtherUserProfileScreen(userId: userId),
        );
      },
    ),

    // Profile
    GoRoute(
      path: '/edit-profile',
      builder: (context, state) => const EditProfilePage(),
    ),

    GoRoute(
      path: '/chat/participants',
      builder: (context, state) => const ChatParticipantsPage(),
    ),

    // Support
    GoRoute(
      path: '/support',
      builder: (context, state) => const HelpSupportPage(),
    ),
    GoRoute(
      path: '/support/create',
      builder: (context, state) => const CreateSupportMessagePage(),
    ),
    GoRoute(
      path: '/support/:id',
      builder: (context, state) {
        final messageId = state.pathParameters['id']!;
        return SupportMessageDetailsPage(messageId: messageId);
      },
    ),
    GoRoute(
      path: '/privacy-policy',
      builder: (context, state) => PrivacyPolicyPage(),
    ),
    GoRoute(
      path: '/terms-of-use',
      builder: (context, state) => TermsOfUsePage(),
    ),
    GoRoute(path: '/about', builder: (context, state) => AboutPage()),
    GoRoute(path: '/delete', builder: (context, state) => DeleteAccountPage()),

    // Добавьте в список роутов:
    GoRoute(
      path: '/friends',
      builder: (context, state) => const FriendsListPage(),
    ),
    GoRoute(
      path: '/friend-requests',
      builder: (context, state) => const FriendRequestsPage(),
    ),
    GoRoute(
      path: '/video/:videoUrl',
      name: 'fullscreen_video',
      builder: (context, state) {
        final videoUrl = Uri.decodeComponent(state.pathParameters['videoUrl']!);
        final autoPlay = state.uri.queryParameters['autoPlay'] == 'true';
        return FullscreenVideoPlayer(videoUrl: videoUrl, autoPlay: autoPlay);
      },
    ),
    GoRoute(
      path: '/image/:imageUrl',
      name: 'fullscreen_image',
      builder: (context, state) {
        final imageUrl = Uri.decodeComponent(state.pathParameters['imageUrl']!);
        return FullscreenImageViewer(imageUrl: imageUrl);
      },
    ),
  ],

  errorBuilder: (context, state) => Scaffold(
    body: Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.error_outline, size: 64, color: Colors.red),
          const SizedBox(height: 16),
          Text(
            'Navigation Error',
            style: Theme.of(context).textTheme.headlineSmall,
          ),
          const SizedBox(height: 8),
          Text(state.error.toString()),
          const SizedBox(height: 24),
          ElevatedButton(
            onPressed: () => context.go('/feed'),
            child: const Text('Go to Feed'),
          ),
        ],
      ),
    ),
  ),
);



// ============================================
// FILE: core/theme/app_theme.dart
// ============================================
import 'package:flutter/material.dart';
import 'app_colors.dart';

class AppTheme {
  static final lightTheme = ThemeData(
    brightness: Brightness.light,
    primaryColor: AppColors.primary,
    scaffoldBackgroundColor: AppColors.backgroundLight,
    colorScheme: ColorScheme.light(
      primary: AppColors.primary,
      secondary: AppColors.accent,
      surface: AppColors.backgroundLight,
      background: AppColors.backgroundLight,
    ),
    appBarTheme: const AppBarTheme(
      foregroundColor: Colors.black,
      titleTextStyle: TextStyle(
        fontSize: 20,
        fontWeight: FontWeight.bold,
        color: Colors.black,
      ),
    ),
    textTheme: const TextTheme(
      bodyLarge: TextStyle(color: AppColors.textLight),
      bodyMedium: TextStyle(color: AppColors.textLight),
      bodySmall: TextStyle(color: AppColors.textLight),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: AppColors.primary,
        foregroundColor: Colors.white,
      ),
    ),
  );

  static final darkTheme = ThemeData(
    brightness: Brightness.dark,
    primaryColor: AppColors.primaryDark,
    scaffoldBackgroundColor: AppColors.backgroundDark,
    colorScheme: ColorScheme.dark(
      primary: AppColors.primaryDark,
      secondary: AppColors.accent,
      surface: AppColors.backgroundDark,
      background: AppColors.backgroundDark,
    ),
    appBarTheme: const AppBarTheme(
      backgroundColor: AppColors.primaryDark,
      foregroundColor: Colors.white,
      titleTextStyle: TextStyle(
        fontSize: 20,
        fontWeight: FontWeight.bold,
        color: Colors.white,
      ),
    ),
    textTheme: const TextTheme(
      bodyLarge: TextStyle(color: AppColors.textDark),
      bodyMedium: TextStyle(color: AppColors.textDark),
      bodySmall: TextStyle(color: AppColors.textDark),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: AppColors.primaryDark,
        foregroundColor: Colors.white,
      ),
    ),
  );
}


// ============================================
// FILE: core/theme/app_colors.dart
// ============================================
import 'package:flutter/material.dart';

class AppColors {
  // Primary colors
  static const Color primary = Color(0xFF1565C0);
  static const Color primaryDark = Color(0xff60a4ff);

  // Accent colors
  static const Color accent = Color(0xFFB0FFC3);

  // Backgrounds
  static const Color backgroundLight = Colors.white;
  static const Color backgroundDark = Color(0xFF121212);

  // Text colors
  static const Color textLight = Colors.black87;
  static const Color textDark = Colors.white70;

  // Avatar backgrounds
  static const Color avatarBackgroundLight = Color(0xFFF5F5F5); // ~5% opacity black on white
  static const Color avatarBackgroundDark = Color(0xFF2A2A2A); // ~30% opacity white on dark

  // Avatar text/icon colors
  static const Color avatarContentLight = Color(0xFF9E9E9E); // ~60% opacity black
  static const Color avatarContentDark = Color(0xFFB3B3B3); // ~60% opacity white
}


// ============================================
// FILE: core/utils/notifications_utils.dart
// ============================================
import 'package:firebase_messaging/firebase_messaging.dart';

extension NotificationsUtils on RemoteMessage{
  String? getRouteFromNotification() {
    final data = this.data;
    final type = data['type'];

    switch (type) {
      case 'new_post':
      case 'new_comment':
      case 'new_like':
      case 'comment_reply':
      case 'mention':
      case 'new_comment_like':
        final postId = data['postId'];
        return postId != null ? '/post/$postId' : null;

      case 'new_chat_message':
      case 'chat_mention':
        return '/chat';

      default:
        return '/notifications';
    }
  }

}




// ============================================
// FILE: l10n/app_en.arb
// ============================================
{
  "@@locale": "en",

  "continueWithApple": "Continue with Apple",


  "appName": "UniTalky",
  "@appName": {
    "description": "Application name"
  },

  "back": "Back",
  "@back": {
    "description": "Back button label"
  },

  "cancel": "Cancel",
  "@cancel": {
    "description": "Cancel button label"
  },

  "save": "Save",
  "@save": {
    "description": "Save button label"
  },

  "delete": "Delete",
  "@delete": {
    "description": "Delete button label"
  },

  "retry": "Retry",
  "@retry": {
    "description": "Retry button label"
  },

  "continueButton": "Continue",
  "@continueButton": {
    "description": "Continue button label"
  },

  "close": "Close",
  "@close": {
    "description": "Close button label"
  },

  "complete": "Complete",
  "@complete": {
    "description": "Complete button label"
  },

  "welcome": "Welcome",
  "@welcome": {
    "description": "Welcome message"
  },

  "introSubtitle": "Connect with your university community",
  "@introSubtitle": {
    "description": "Intro subtitle on welcome screen"
  },

  "introDescription": "Stay up to date with your university life",
  "@introDescription": {
    "description": "Introduction description"
  },

  "signInWithGoogle": "Sign in with Google",
  "@signInWithGoogle": {
    "description": "Google sign in button"
  },

  "continueWithGoogle": "Continue with Google",
  "@continueWithGoogle": {
    "description": "Continue with Google button"
  },

  "byContinuingYouAgree": "By continuing, you agree to our",
  "@byContinuingYouAgree": {
    "description": "Terms agreement prefix"
  },

  "and": "and",
  "@and": {
    "description": "Conjunction 'and'"
  },

  "termsOfService": "Terms of Service",
  "@termsOfService": {
    "description": "Terms of Service link text"
  },

  "privacyPolicy": "Privacy Policy",
  "@privacyPolicy": {
    "description": "Privacy Policy link text"
  },

  "errorOccurred": "Oops! Something went wrong",
  "@errorOccurred": {
    "description": "Generic error message"
  },

  "anErrorOccurred": "An error occurred",
  "@anErrorOccurred": {
    "description": "Generic error message alternative"
  },

  "profileSetup": "Profile Setup",
  "@profileSetup": {
    "description": "Profile setup page title"
  },

  "completeProfile": "Complete Your Profile",
  "@completeProfile": {
    "description": "Complete profile page title"
  },

  "completeProfileTitle": "Welcome aboard!",
  "@completeProfileTitle": {
    "description": "Complete profile welcome title"
  },

  "completeProfileSubtitle": "Let's get you set up in just a few steps",
  "@completeProfileSubtitle": {
    "description": "Complete profile subtitle"
  },

  "whatsYourName": "What's your name?",
  "@whatsYourName": {
    "description": "Name setup question"
  },

  "realNameRequired": "Use your real name to get verified and build trust in the community",
  "@realNameRequired": {
    "description": "Real name requirement explanation"
  },

  "personalInformation": "Personal Info",
  "@personalInformation": {
    "description": "Personal information section header"
  },

  "firstName": "First Name",
  "@firstName": {
    "description": "First name field label"
  },

  "firstNameHint": "Enter your first name",
  "@firstNameHint": {
    "description": "First name field hint"
  },

  "enterFirstName": "Enter your first name",
  "@enterFirstName": {
    "description": "First name field placeholder"
  },

  "firstNameRequired": "First name is required",
  "@firstNameRequired": {
    "description": "First name validation error"
  },

  "firstNameTooShort": "First name must be at least 2 characters",
  "@firstNameTooShort": {
    "description": "First name length validation"
  },

  "lastName": "Last Name",
  "@lastName": {
    "description": "Last name field label"
  },

  "lastNameHint": "Enter your last name",
  "@lastNameHint": {
    "description": "Last name field hint"
  },

  "enterLastName": "Enter your last name",
  "@enterLastName": {
    "description": "Last name field placeholder"
  },

  "lastNameRequired": "Last name is required",
  "@lastNameRequired": {
    "description": "Last name validation error"
  },

  "lastNameTooShort": "Last name must be at least 2 characters",
  "@lastNameTooShort": {
    "description": "Last name length validation"
  },

  "fillAllFields": "Please fill in all required fields",
  "@fillAllFields": {
    "description": "Form validation error"
  },

  "academicInformation": "Academic Info",
  "@academicInformation": {
    "description": "Academic information section header"
  },

  "university": "University",
  "@university": {
    "description": "University field label"
  },

  "selectUniversity": "Select University",
  "@selectUniversity": {
    "description": "Select university page title"
  },

  "selectYourUniversity": "Select your university",
  "@selectYourUniversity": {
    "description": "Select university header"
  },

  "chooseUniversityYouAttend": "Choose the university you attend",
  "@chooseUniversityYouAttend": {
    "description": "Select university description"
  },

  "selectUniversityPrompt": "Select university",
  "@selectUniversityPrompt": {
    "description": "Select university dropdown prompt"
  },

  "selectUniversitySubtitle": "Choose a university to view its feed",
  "@selectUniversitySubtitle": {
    "description": "University selection bottom sheet subtitle"
  },

  "selectUniversityFirst": "Select a university first",
  "@selectUniversityFirst": {
    "description": "Error when faculty selected before university"
  },

  "searchUniversity": "Search university...",
  "@searchUniversity": {
    "description": "University search placeholder"
  },

  "searchUniversities": "Search universities...",
  "@searchUniversities": {
    "description": "Universities search placeholder"
  },

  "universityRequired": "Please select a university",
  "@universityRequired": {
    "description": "University validation error"
  },

  "failedToLoadUniversities": "Failed to load universities",
  "@failedToLoadUniversities": {
    "description": "University loading error"
  },

  "noUniversitiesFound": "No universities found",
  "@noUniversitiesFound": {
    "description": "Empty state for university search"
  },

  "yourUniversity": "Your University",
  "@yourUniversity": {
    "description": "Your university label"
  },

  "tapToChangeUniversity": "Tap to change university",
  "@tapToChangeUniversity": {
    "description": "Change university hint"
  },

  "faculty": "Faculty",
  "@faculty": {
    "description": "Faculty field label"
  },

  "selectFaculty": "Select Faculty",
  "@selectFaculty": {
    "description": "Select faculty page title"
  },

  "selectYourFaculty": "Select your faculty",
  "@selectYourFaculty": {
    "description": "Select faculty header"
  },

  "chooseYourFieldOfStudy": "Choose your field of study",
  "@chooseYourFieldOfStudy": {
    "description": "Select faculty description"
  },

  "selectFacultyPrompt": "Select faculty",
  "@selectFacultyPrompt": {
    "description": "Select faculty dropdown prompt"
  },

  "searchFaculty": "Search faculty...",
  "@searchFaculty": {
    "description": "Faculty search placeholder"
  },

  "searchFaculties": "Search faculties...",
  "@searchFaculties": {
    "description": "Faculties search placeholder"
  },

  "facultyRequired": "Please select a faculty",
  "@facultyRequired": {
    "description": "Faculty validation error"
  },

  "failedToLoadFaculties": "Failed to load faculties",
  "@failedToLoadFaculties": {
    "description": "Faculty loading error"
  },

  "noFacultiesFound": "No faculties found",
  "@noFacultiesFound": {
    "description": "Empty state for faculty search"
  },

  "sector": "Sector",
  "@sector": {
    "description": "Sector field label"
  },

  "selectSector": "Select Sector",
  "@selectSector": {
    "description": "Select sector page title"
  },

  "selectSectorPrompt": "Select sector",
  "@selectSectorPrompt": {
    "description": "Select sector dropdown prompt"
  },

  "sectorAzerbaijani": "Azerbaijani",
  "@sectorAzerbaijani": {
    "description": "Azerbaijani sector"
  },

  "sectorRussian": "Russian",
  "@sectorRussian": {
    "description": "Russian sector"
  },

  "sectorEnglish": "English",
  "@sectorEnglish": {
    "description": "English sector"
  },

  "select": "Select {item}",
  "@select": {
    "description": "Generic select placeholder",
    "placeholders": {
      "item": {
        "type": "String",
        "example": "option"
      }
    }
  },

  "notSelected": "Not selected",
  "@notSelected": {
    "description": "Semantic label when nothing is selected"
  },

  "tryDifferentSearchTerm": "Try a different search term",
  "@tryDifferentSearchTerm": {
    "description": "Empty search state subtitle"
  },

  "accountVerification": "Get Verified",
  "@accountVerification": {
    "description": "Account verification page title"
  },

  "getVerified": "Get Verified",
  "@getVerified": {
    "description": "Get verified button"
  },

  "verifyStudentStatus": "Verify your student status",
  "@verifyStudentStatus": {
    "description": "Verification call to action"
  },

  "verified": "Verified",
  "@verified": {
    "description": "Verified status badge"
  },

  "verificationPending": "Verification Pending",
  "@verificationPending": {
    "description": "Verification pending status"
  },

  "verificationUnderReview": "Your verification is under review",
  "@verificationUnderReview": {
    "description": "Verification under review message"
  },

  "verificationPendingTitle": "Under Review",
  "@verificationPendingTitle": {
    "description": "Verification pending title"
  },

  "verificationPendingMessage": "We're checking your document. You'll be notified when it's done (usually 1-3 days).",
  "@verificationPendingMessage": {
    "description": "Verification pending message"
  },

  "verificationRejected": "Verification Rejected",
  "@verificationRejected": {
    "description": "Verification rejected status"
  },

  "pleaseTryAgain": "Please try again",
  "@pleaseTryAgain": {
    "description": "Try again message"
  },

  "verificationRejectedTitle": "Verification Rejected",
  "@verificationRejectedTitle": {
    "description": "Verification rejected title"
  },

  "reason": "Reason:",
  "@reason": {
    "description": "Reason label"
  },

  "uploadNewScreenshot": "Please upload a new screenshot from the MyGov app Education section",
  "@uploadNewScreenshot": {
    "description": "Upload new screenshot instruction"
  },

  "tryAgain": "Try Again",
  "@tryAgain": {
    "description": "Try again button"
  },

  "accountVerifiedTitle": "You're Verified! 🎉",
  "@accountVerifiedTitle": {
    "description": "Account verified title"
  },

  "accountVerifiedMessage": "Your account is verified! You now have full access to all features.",
  "@accountVerifiedMessage": {
    "description": "Account verified message"
  },

  "verificationWarningTitle": "Heads Up!",
  "@verificationWarningTitle": {
    "description": "Verification warning title"
  },

  "verificationWarningMessage": "Changing your university or faculty will reset your verification. You'll need to verify again.",
  "@verificationWarningMessage": {
    "description": "Verification warning message"
  },

  "verificationWarning": "Important: Only screenshots from MyGov app Education section are accepted. Student ID cards won't work.",
  "@verificationWarning": {
    "description": "Verification document warning"
  },

  "verificationTimeline": "Verification usually takes 1-3 business days. We'll notify you when it's complete.",
  "@verificationTimeline": {
    "description": "Verification timeline info"
  },

  "myGovDocumentUpload": "MyGov Document Upload",
  "@myGovDocumentUpload": {
    "description": "MyGov upload section title"
  },

  "myGovUploadInstruction": "Upload a screenshot of the Education section from your MyGov app",
  "@myGovUploadInstruction": {
    "description": "MyGov upload instruction"
  },

  "howToPrepare": "How to prepare?",
  "@howToPrepare": {
    "description": "How to prepare section"
  },

  "verificationStep1": "1. Open the MyGov mobile app",
  "@verificationStep1": {
    "description": "Verification step 1"
  },

  "verificationStep2": "2. Go to the 'Education' section",
  "@verificationStep2": {
    "description": "Verification step 2"
  },

  "verificationStep3": "3. Take a screenshot showing your student info",
  "@verificationStep3": {
    "description": "Verification step 3"
  },

  "verificationStep4": "4. Make sure the image is clear and readable",
  "@verificationStep4": {
    "description": "Verification step 4"
  },

  "noScreenshotSelected": "No screenshot selected",
  "@noScreenshotSelected": {
    "description": "No screenshot selected message"
  },

  "pleaseSelectImage": "Please select an image",
  "@pleaseSelectImage": {
    "description": "Select image prompt"
  },

  "uploadFailed": "Upload failed",
  "@uploadFailed": {
    "description": "Upload failed error"
  },

  "documentUploadedSuccessfully": "Document uploaded successfully!",
  "@documentUploadedSuccessfully": {
    "description": "Document upload success"
  },

  "uploadAndSend": "Upload and Send",
  "@uploadAndSend": {
    "description": "Upload and send button"
  },

  "fromGallery": "From Gallery",
  "@fromGallery": {
    "description": "From gallery option"
  },

  "gallery": "Gallery",
  "@gallery": {
    "description": "Gallery option"
  },

  "camera": "Camera",
  "@camera": {
    "description": "Camera option"
  },

  "chooseFromGallery": "Choose from Gallery",
  "@chooseFromGallery": {
    "description": "Choose from gallery button"
  },

  "takePhoto": "Take a Photo",
  "@takePhoto": {
    "description": "Take photo button"
  },

  "removePhoto": "Remove Photo",
  "@removePhoto": {
    "description": "Remove photo button"
  },

  "addImage": "Add Image",
  "@addImage": {
    "description": "Add image button"
  },

  "attachImage": "Attach Image",
  "@attachImage": {
    "description": "Attach image button"
  },

  "changeImage": "Change Image",
  "@changeImage": {
    "description": "Change image button"
  },

  "errorPickingImage": "Error picking image: {error}",
  "@errorPickingImage": {
    "description": "Error picking image message",
    "placeholders": {
      "error": {
        "type": "String"
      }
    }
  },

  "errorTakingPhoto": "Error taking photo: {error}",
  "@errorTakingPhoto": {
    "description": "Error taking photo message",
    "placeholders": {
      "error": {
        "type": "String"
      }
    }
  },

  "imageLoadError": "Failed to load image",
  "@imageLoadError": {
    "description": "Image load error message"
  },

  "settings": "Settings",
  "@settings": {
    "description": "Settings page title"
  },

  "darkMode": "Dark Mode",
  "@darkMode": {
    "description": "Dark mode setting"
  },

  "language": "Language",
  "@language": {
    "description": "Language setting"
  },

  "selectLanguage": "Select Language",
  "@selectLanguage": {
    "description": "Select language title"
  },

  "notifications": "Notifications",
  "@notifications": {
    "description": "Notifications setting and page title"
  },

  "notificationSettings": "Notification Settings",
  "@notificationSettings": {
    "description": "Notification settings page title"
  },

  "enableNotifications": "Enable Notifications",
  "@enableNotifications": {
    "description": "Enable notifications toggle"
  },

  "enableNotificationsDescription": "Turn on/off all notifications",
  "@enableNotificationsDescription": {
    "description": "Enable notifications description"
  },

  "noNotifications": "No notifications yet",
  "@noNotifications": {
    "description": "Empty notifications state"
  },

  "errorLoadingNotifications": "Failed to load notifications",
  "@errorLoadingNotifications": {
    "description": "Notifications loading error"
  },

  "errorLoadingSettings": "Failed to load settings",
  "@errorLoadingSettings": {
    "description": "Settings loading error"
  },

  "markAllAsRead": "Mark all as read",
  "@markAllAsRead": {
    "description": "Mark all notifications as read"
  },

  "deleteAll": "Delete all",
  "@deleteAll": {
    "description": "Delete all button"
  },

  "deleteNotification": "Delete notification",
  "@deleteNotification": {
    "description": "Delete notification title"
  },

  "deleteNotificationConfirm": "Delete this notification?",
  "@deleteNotificationConfirm": {
    "description": "Delete notification confirmation"
  },

  "deleteAllNotifications": "Delete all notifications",
  "@deleteAllNotifications": {
    "description": "Delete all notifications title"
  },

  "deleteAllNotificationsConfirm": "Delete all notifications? This can't be undone.",
  "@deleteAllNotificationsConfirm": {
    "description": "Delete all notifications confirmation"
  },

  "notificationDeleted": "Notification deleted",
  "@notificationDeleted": {
    "description": "Notification deleted success"
  },

  "posts": "Posts",
  "@posts": {
    "description": "Posts label"
  },

  "newPosts": "New Posts",
  "@newPosts": {
    "description": "New posts notification setting"
  },

  "newPostsDescription": "Get notified when someone posts",
  "@newPostsDescription": {
    "description": "New posts notification description"
  },

  "newComments": "New Comments",
  "@newComments": {
    "description": "New comments notification setting"
  },

  "newCommentsDescription": "Get notified when someone comments on your posts",
  "@newCommentsDescription": {
    "description": "New comments notification description"
  },

  "newLikes": "New Likes",
  "@newLikes": {
    "description": "New likes notification setting"
  },

  "newLikesDescription": "Get notified when someone likes your posts",
  "@newLikesDescription": {
    "description": "New likes notification description"
  },

  "comments": "Comments",
  "@comments": {
    "description": "Comments label"
  },

  "commentReplies": "Comment Replies",
  "@commentReplies": {
    "description": "Comment replies notification setting"
  },

  "commentRepliesDescription": "Get notified when someone replies to your comments",
  "@commentRepliesDescription": {
    "description": "Comment replies notification description"
  },

  "mentions": "Mentions",
  "@mentions": {
    "description": "Mentions notification setting"
  },

  "mentionsDescription": "Get notified when someone mentions you",
  "@mentionsDescription": {
    "description": "Mentions notification description"
  },

  "chatMessages": "Chat Messages",
  "@chatMessages": {
    "description": "Chat messages notification setting"
  },

  "chatMessagesDescription": "Get notified about new messages in faculty chat",
  "@chatMessagesDescription": {
    "description": "Chat messages notification description"
  },

  "chatMentions": "Chat Mentions",
  "@chatMentions": {
    "description": "Chat mentions notification setting"
  },

  "chatMentionsDescription": "Get notified when someone mentions you in chat",
  "@chatMentionsDescription": {
    "description": "Chat mentions notification description"
  },

  "privacySecurity": "Privacy & Security",
  "@privacySecurity": {
    "description": "Privacy and security setting"
  },

  "helpSupport": "Help & Support",
  "@helpSupport": {
    "description": "Help and support setting and page title"
  },

  "about": "About",
  "@about": {
    "description": "About setting"
  },

  "logout": "Logout",
  "@logout": {
    "description": "Logout button"
  },

  "areYouSureLogout": "Are you sure you want to logout?",
  "@areYouSureLogout": {
    "description": "Logout confirmation"
  },

  "profile": "Profile",
  "@profile": {
    "description": "Profile page title and nav label"
  },

  "editProfile": "Edit Profile",
  "@editProfile": {
    "description": "Edit profile button"
  },

  "failedToUpdateProfile": "Failed to update profile",
  "@failedToUpdateProfile": {
    "description": "Profile update error"
  },

  "myPosts": "My Posts",
  "@myPosts": {
    "description": "My posts section"
  },

  "postsCount": "{count, plural, =0{No posts} =1{1 post} other{{count} posts}}",
  "@postsCount": {
    "description": "Posts count",
    "placeholders": {
      "count": {
        "type": "int"
      }
    }
  },

  "noPostsYet": "No posts yet",
  "@noPostsYet": {
    "description": "Empty posts state"
  },

  "userHasNoPosts": "This user hasn't posted anything yet",
  "@userHasNoPosts": {
    "description": "Empty user posts state"
  },

  "studentIdCard": "Student ID Card",
  "@studentIdCard": {
    "description": "Student ID card title"
  },

  "idLabel": "ID",
  "@idLabel": {
    "description": "ID label"
  },

  "notAvailable": "N/A",
  "@notAvailable": {
    "description": "Not available placeholder"
  },

  "verificationRequired": "Verification Required",
  "@verificationRequired": {
    "description": "Verification required message"
  },

  "verificationRequiredTitle": "Get Verified First",
  "@verificationRequiredTitle": {
    "description": "Verification required title"
  },

  "chatAccessVerifiedOnly": "Only verified students can chat. Complete verification to join the conversation.",
  "@chatAccessVerifiedOnly": {
    "description": "Chat verification required message"
  },

  "verifiedUsersOnly": "Only verified students can chat",
  "@verifiedUsersOnly": {
    "description": "Verified users only notice"
  },

  "facultyStudentsOnly": "Students from your faculty only",
  "@facultyStudentsOnly": {
    "description": "Faculty students only notice"
  },

  "privateAndSecure": "Private and secure communication",
  "@privateAndSecure": {
    "description": "Privacy notice"
  },

  "canOnlyPostInOwnUniversity": "You can only post in your own university",
  "@canOnlyPostInOwnUniversity": {
    "description": "Post restriction message"
  },

  "chat": "Chat",
  "@chat": {
    "description": "Chat page title and nav label"
  },

  "connecting": "Connecting...",
  "@connecting": {
    "description": "Connecting status"
  },

  "connectionError": "Connection Error",
  "@connectionError": {
    "description": "Connection error message"
  },

  "chatDescription": "This is the {facultyName} faculty chat. Only verified students can participate.",
  "@chatDescription": {
    "description": "Chat description",
    "placeholders": {
      "facultyName": {
        "type": "String"
      }
    }
  },

  "noMessages": "No messages yet",
  "@noMessages": {
    "description": "Empty chat state"
  },

  "noMessagesYet": "No Messages Yet",
  "@noMessagesYet": {
    "description": "Empty messages state title"
  },

  "startConversation": "Be the first to start the conversation!",
  "@startConversation": {
    "description": "Empty chat call to action"
  },

  "createFirstSupportMessage": "Create your first support message to get help from our team",
  "@createFirstSupportMessage": {
    "description": "Empty support messages state"
  },

  "typeMessage": "Type a message...",
  "@typeMessage": {
    "description": "Message input placeholder"
  },

  "userIsTyping": "{name} is typing...",
  "@userIsTyping": {
    "description": "User typing indicator",
    "placeholders": {
      "name": {
        "type": "String"
      }
    }
  },

  "participants": "Participants",
  "@participants": {
    "description": "Participants label"
  },

  "participantsCount": "{count, plural, =0{No participants} =1{1 participant} other{{count} participants}}",
  "@participantsCount": {
    "description": "Participants count",
    "placeholders": {
      "count": {
        "type": "int"
      }
    }
  },

  "totalParticipants": "{count, plural, =0{No participants} =1{1 participant} other{{count} participants}}",
  "@totalParticipants": {
    "description": "Total participants count",
    "placeholders": {
      "count": {
        "type": "int"
      }
    }
  },

  "noParticipants": "No Participants",
  "@noParticipants": {
    "description": "No participants title"
  },

  "noParticipantsDescription": "There are no participants in this chat yet",
  "@noParticipantsDescription": {
    "description": "No participants description"
  },

  "loadingParticipants": "Loading participants...",
  "@loadingParticipants": {
    "description": "Loading participants status"
  },

  "yesterday": "Yesterday",
  "@yesterday": {
    "description": "Yesterday time label"
  },

  "weekday": "{day, select, 1{Mon} 2{Tue} 3{Wed} 4{Thu} 5{Fri} 6{Sat} 7{Sun} other{}}",
  "@weekday": {
    "description": "Weekday abbreviation",
    "placeholders": {
      "day": {
        "type": "String"
      }
    }
  },

  "daysAgo": "{count}d ago",
  "@daysAgo": {
    "description": "Days ago time label",
    "placeholders": {
      "count": {
        "type": "int",
        "example": "3"
      }
    }
  },

  "newPost": "New Post",
  "@newPost": {
    "description": "New post page title"
  },

  "post": "POST",
  "@post": {
    "description": "Post button"
  },
  "postTitle": "Post",
  "@postTitle": {
    "description": "Title for the post detail page shown in the app bar"
  },

  "anonymous": "Anonymous",
  "@anonymous": {
    "description": "Anonymous user label"
  },

  "user": "User",
  "@user": {
    "description": "Default user label"
  },

  "whatsOnYourMind": "What's on your mind?",
  "@whatsOnYourMind": {
    "description": "Post content placeholder"
  },

  "characterCount": "{current} / {max}",
  "@characterCount": {
    "description": "Character count display",
    "placeholders": {
      "current": {
        "type": "int"
      },
      "max": {
        "type": "int"
      }
    }
  },

  "actions": "ACTIONS",
  "@actions": {
    "description": "Actions section header"
  },

  "anonymousMode": "Anonymous Mode",
  "@anonymousMode": {
    "description": "Anonymous mode label"
  },

  "publicMode": "Public Mode",
  "@publicMode": {
    "description": "Public mode label"
  },

  "yourIdentityIsHidden": "Your identity is hidden",
  "@yourIdentityIsHidden": {
    "description": "Anonymous mode description"
  },

  "yourNameIsVisible": "Your name is visible",
  "@yourNameIsVisible": {
    "description": "Public mode description"
  },

  "anonymousToggleEnable": "Post anonymously",
  "@anonymousToggleEnable": {
    "description": "Enable anonymous mode tooltip"
  },

  "anonymousToggleDisable": "Post with your name",
  "@anonymousToggleDisable": {
    "description": "Disable anonymous mode tooltip"
  },

  "anonymousToggleLabelOn": "Anonymous mode is on",
  "@anonymousToggleLabelOn": {
    "description": "Anonymous mode active label"
  },

  "anonymousToggleLabelOff": "Anonymous mode is off",
  "@anonymousToggleLabelOff": {
    "description": "Anonymous mode inactive label"
  },

  "pleaseAddContent": "Add some content or an image to post",
  "@pleaseAddContent": {
    "description": "Empty post error"
  },

  "postCreatedSuccessfully": "Posted! 🎉",
  "@postCreatedSuccessfully": {
    "description": "Post created success"
  },

  "failedToCreatePost": "Failed to create post",
  "@failedToCreatePost": {
    "description": "Post creation error"
  },

  "failedToLoadPosts": "Failed to load posts",
  "@failedToLoadPosts": {
    "description": "Posts loading error"
  },

  "beTheFirstToShare": "Be the first to share something!",
  "@beTheFirstToShare": {
    "description": "Empty feed call to action"
  },

  "postNotFound": "Post not found",
  "@postNotFound": {
    "description": "Post not found error"
  },

  "postMayHaveBeenDeleted": "This post may have been deleted",
  "@postMayHaveBeenDeleted": {
    "description": "Post deleted message"
  },

  "deletePost": "Delete Post",
  "@deletePost": {
    "description": "Delete post title"
  },

  "deletePostConfirmation": "Delete this post?",
  "@deletePostConfirmation": {
    "description": "Delete post confirmation"
  },

  "like": "Like",
  "@like": {
    "description": "Like button label"
  },

  "likes": "Likes",
  "@likes": {
    "description": "Likes label"
  },

  "failedToLoadLikes": "Failed to load likes",
  "@failedToLoadLikes": {
    "description": "Likes loading error"
  },

  "noLikesYet": "No likes yet",
  "@noLikesYet": {
    "description": "Empty likes state"
  },

  "beTheFirstToLike": "Be the first to like this post",
  "@beTheFirstToLike": {
    "description": "Empty likes call to action"
  },

  "comment": "Comment",
  "@comment": {
    "description": "Comment button label"
  },

  "noCommentsYet": "No comments yet",
  "@noCommentsYet": {
    "description": "Empty comments state"
  },

  "startTheConversation": "Start the conversation",
  "@startTheConversation": {
    "description": "Empty comments call to action"
  },

  "commentAnonymously": "Comment anonymously...",
  "@commentAnonymously": {
    "description": "Anonymous comment placeholder"
  },

  "writeComment": "Write a comment...",
  "@writeComment": {
    "description": "Comment input placeholder"
  },

  "deleteComment": "Delete Comment",
  "@deleteComment": {
    "description": "Delete comment title"
  },

  "deleteCommentConfirmation": "Delete this comment?",
  "@deleteCommentConfirmation": {
    "description": "Delete comment confirmation"
  },

  "reply": "Reply",
  "@reply": {
    "description": "Reply button label"
  },

  "repliesCount": "{count, plural, =0{No replies} =1{1 reply} other{{count} replies}}",
  "@repliesCount": {
    "description": "Replies count",
    "placeholders": {
      "count": {
        "type": "int"
      }
    }
  },

  "replyAnonymously": "Reply anonymously...",
  "@replyAnonymously": {
    "description": "Anonymous reply placeholder"
  },

  "writeReply": "Write a reply...",
  "@writeReply": {
    "description": "Reply input placeholder"
  },

  "deleteReply": "Delete Reply",
  "@deleteReply": {
    "description": "Delete reply title"
  },

  "deleteReplyConfirmation": "Delete this reply?",
  "@deleteReplyConfirmation": {
    "description": "Delete reply confirmation"
  },

  "share": "Share",
  "@share": {
    "description": "Share button label"
  },

  "repost": "Repost",
  "@repost": {
    "description": "Repost button label"
  },

  "navFeed": "Feed",
  "@navFeed": {
    "description": "Feed navigation label"
  },

  "navSearch": "Search",
  "@navSearch": {
    "description": "Search navigation label"
  },

  "navChat": "Chat",
  "@navChat": {
    "description": "Chat navigation label"
  },

  "navProfile": "Profile",
  "@navProfile": {
    "description": "Profile navigation label"
  },

  "searchUsers": "Search Users",
  "@searchUsers": {
    "description": "Search users page title"
  },

  "searchUsersByName": "Search users by name...",
  "@searchUsersByName": {
    "description": "Search users placeholder"
  },

  "searchForUsers": "Search for users by name",
  "@searchForUsers": {
    "description": "Search users description"
  },

  "typeToStartSearching": "Type at least 2 characters to start searching",
  "@typeToStartSearching": {
    "description": "Search minimum characters message"
  },

  "noUsersFound": "No users found",
  "@noUsersFound": {
    "description": "Empty search results"
  },

  "tryDifferentName": "Try searching with a different name",
  "@tryDifferentName": {
    "description": "Empty search hint"
  },

  "usersFound": "{count, plural, =0{No users found} =1{1 user found} other{{count} users found}}",
  "@usersFound": {
    "description": "Search results count",
    "placeholders": {
      "count": {
        "type": "int"
      }
    }
  },

  "userNotFound": "User not found",
  "@userNotFound": {
    "description": "User not found error"
  },

  "errorMessage": "Error: {error}",
  "@errorMessage": {
    "description": "Error message with details",
    "placeholders": {
      "error": {
        "type": "String"
      }
    }
  },

  "createMessage": "Create Message",
  "@createMessage": {
    "description": "Create support message button"
  },

  "newMessage": "New Message",
  "@newMessage": {
    "description": "New message FAB label"
  },

  "filterByStatus": "Filter by Status",
  "@filterByStatus": {
    "description": "Filter by status title"
  },

  "clearFilter": "Clear",
  "@clearFilter": {
    "description": "Clear filter button"
  },

  "allMessages": "All Messages",
  "@allMessages": {
    "description": "All messages filter option"
  },

  "pending": "Pending",
  "@pending": {
    "description": "Pending status"
  },

  "inProgress": "In Progress",
  "@inProgress": {
    "description": "In progress status"
  },

  "resolved": "Resolved",
  "@resolved": {
    "description": "Resolved status"
  },

  "closed": "Closed",
  "@closed": {
    "description": "Closed status"
  },

  "newSupportMessage": "New Support Message",
  "@newSupportMessage": {
    "description": "New support message page title"
  },

  "supportTeamResponse": "Our support team typically responds within 24 hours",
  "@supportTeamResponse": {
    "description": "Support response time info"
  },

  "category": "Category",
  "@category": {
    "description": "Category field label"
  },

  "selectCategory": "Select Category",
  "@selectCategory": {
    "description": "Select category title"
  },

  "technicalIssue": "Technical Issue",
  "@technicalIssue": {
    "description": "Technical issue category"
  },

  "accountIssue": "Account Issue",
  "@accountIssue": {
    "description": "Account issue category"
  },

  "verificationCategory": "Verification",
  "@verificationCategory": {
    "description": "Verification category"
  },

  "contentIssue": "Content Issue",
  "@contentIssue": {
    "description": "Content issue category"
  },

  "other": "Other",
  "@other": {
    "description": "Other category"
  },

  "@subject": {
    "description": "Subject field label"
  },

  "subjectHint": "Brief description of your issue",
  "@subjectHint": {
    "description": "Subject field hint"
  },

  "subjectRequired": "Subject is required",
  "@subjectRequired": {
    "description": "Subject validation error"
  },

  "subjectTooLong": "Subject must be less than 200 characters",
  "@subjectTooLong": {
    "description": "Subject length validation"
  },

  "message": "Message",
  "@message": {
    "description": "Message field label"
  },

  "messageHint": "Message...",
  "@messageHint": {
    "description": "Message field hint"
  },

  "messageRequired": "Message is required",
  "@messageRequired": {
    "description": "Message validation error"
  },

  "messageTooLong": "Message must be less than 2000 characters",
  "@messageTooLong": {
    "description": "Message length validation"
  },

  "submitMessage": "Submit Message",
  "@submitMessage": {
    "description": "Submit message button"
  },

  "messageSentSuccess": "Support message sent successfully!",
  "@messageSentSuccess": {
    "description": "Message sent success"
  },

  "messageDetails": "Message Details",
  "@messageDetails": {
    "description": "Message details page title"
  },

  "allCaughtUp": "You're all caught up!",
  "@allCaughtUp": {
    "description": "Empty state message when user has seen all content"
  },
  "categoryTechnical": "Technical",
  "@categoryTechnical": {
    "description": "Technical support category"
  },
  "categoryAccount": "Account",
  "@categoryAccount": {
    "description": "Account support category"
  },
  "categoryVerification": "Verification",
  "@categoryVerification": {
    "description": "Verification support category"
  },
  "categoryContent": "Content",
  "@categoryContent": {
    "description": "Content support category"
  },
  "categoryOther": "Other",
  "@categoryOther": {
    "description": "Other support category"
  },
  "statusPending": "Pending",
  "@statusPending": {
    "description": "Pending status label"
  },
  "statusInProgress": "In Progress",
  "@statusInProgress": {
    "description": "In progress status label"
  },
  "statusResolved": "Resolved",
  "@statusResolved": {
    "description": "Resolved status label"
  },
  "statusClosed": "Closed",
  "@statusClosed": {
    "description": "Closed status label"
  },
  "clear": "Clear",
  "@clear": {
    "description": "Clear filter button"
  },
  "dateTimeFormat": "{day}/{month}/{year} at {hour}:{minute}",
  "@dateTimeFormat": {
    "description": "Date and time format",
    "placeholders": {
      "day": {
        "type": "int"
      },
      "month": {
        "type": "int"
      },
      "year": {
        "type": "int"
      },
      "hour": {
        "type": "String"
      },
      "minute": {
        "type": "String"
      }
    }
  },
  "categoryTechnicalIssue": "Technical Issue",
  "@categoryTechnicalIssue": {
    "description": "Technical issue category label"
  },
  "categoryAccountIssue": "Account Issue",
  "@categoryAccountIssue": {
    "description": "Account issue category label"
  },
  "categoryContentIssue": "Content Issue",
  "@categoryContentIssue": {
    "description": "Content issue category label"
  },
  "supportResponseTime": "Our support team typically responds within 24 hours",
  "@supportResponseTime": {
    "description": "Info message about response time"
  },
  "supportMessageSentSuccess": "Support message sent successfully",
  "@supportMessageSentSuccess": {
    "description": "Success message after sending support message"
  },

  "deleteAccount": "Delete Account",
  "deleteAccountWarning": "⚠️ Warning: This action is permanent!",
  "deleteAccountDescription": "Deleting your account will permanently remove all your data from our servers. This includes:",
  "willBeDeleted": "What will be deleted:",
  "allPosts": "All your posts",
  "allComments": "All your comments",
  "profileData": "Your profile and personal data",
  "thisActionCannotBeUndone": "This action cannot be undone!",
  "finalConfirmation": "Final Confirmation",
  "typeDeleteToConfirm": "Type DELETE to confirm account deletion:",
  "pleaseTypeDeleteCorrectly": "Please type DELETE correctly to confirm",
  "deleteForever": "Delete Forever",
  "termsOfUse": "Terms of Use",

  "verificationRequiredMessage": "You need to be verified to access the chat. Please complete your verification first.",
  "goToProfile": "Go to Profile",
  "edit": "Edit",
  "editMessage": "Edit Message",
  "deleteMessage": "Delete Message",
  "deleteMessageConfirm": "Are you sure you want to delete this message?",
  "enterMessage": "Enter message",

  "failedToLoadMessages": "Failed to load messages",

  "unknown": "Unknown",
  "photo": "Photo",
  "messageDeleted": "Message deleted",
  "edited": "(edited)",
  "replyTo": "Reply to",


  "aboutApp": "About App",
  "appVersion": "Version 1.0.0",
  "projectDescription": "Project Description",
  "aboutProjectText": "UniTalk is a modern mobile application developed as part of a student project for the 'Brand and Advertising' course. The app is designed to improve communication between university students.",
  "courseInformation": "Course Information",
  "subject": "Subject:",
  "brandAndAdvertising": "Brand and Advertising",
  "group": "Group:",
  "teacher": "Teacher:",
  "teacherName": "Lydia Safronova",
  "projectTeam": "Project Team",
  "studentName1": "Rauf Khalilov",
  "studentName2": "Taleh Badalov",
  "studentName3": "Gunay Mirzayeva",
  "studentName4": "Anastasia Lobastova",
  "studentName5": "Ismayil Nagiyev",
  "projectPurpose": "Project Purpose",
  "purposeText": "Creating a convenient platform for student communication, information sharing, and collaborative work on educational projects.",
  "madeWithLove": "Made with ❤️ by Group 787 students",
  "universityInformation": "University Information",
  "universityName": "Azerbaijan State University of Economics (UNEC)",
  "facultyName": "Design",
  "blockUser": "Block User",
  "unblockUser": "Unblock User",
  "blockedUsers": "Blocked Users",
  "noBlockedUsers": "No blocked users",
  "blockUserConfirmation": "Are you sure you want to block {name}?",
  "unblockUserConfirmation": "Are you sure you want to unblock {name}?",
  "youBlockedThisUser": "You blocked this user",
  "thisUserBlockedYou": "This user blocked you",
  "userBlocked": "User blocked successfully",
  "userUnblocked": "User unblocked successfully",
  "block": "Block",
  "unblock": "Unblock",

  "reportTitle": "Report",
  "reportPost": "Report Post",
  "reportComment": "Report Comment",
  "reportMessage": "Report Message",
  "reportUser": "Report User",
  "myReports": "My Reports",
  "noReports": "No reports yet",
  "selectReportCategory": "Please select a category",
  "selectReportReason": "Please select a reason for reporting",
  "reportSubmitted": "Report submitted successfully",
  "submitReport": "Submit Report",
  "cancelReport": "Cancel Report",
  "cancelReportConfirmation": "Are you sure you want to cancel this report?",

  "spam": "Spam",
  "harassment": "Harassment",
  "hateSpeech": "Hate Speech",
  "violence": "Violence",
  "nudity": "Nudity",
  "falseInformation": "False Information",
  "impersonation": "Impersonation",
  "underReview": "Under Review",
  "rejected": "Rejected",

  "additionalDetails": "Additional Details (Optional)",
  "describeIssue": "Describe the issue...",
  "all": "All",
  "filter": "Filter",
  "report": "Report",
  "yes": "Yes",
  "no": "No",

  "likedByPrefix": "Liked by",
  "andOthers": "and {count} others",
  "@andOthers": {
    "placeholders": {
      "count": {
        "type": "int"
      }
    }
  },
  "likesCount": "{count} likes",
  "@likesCount": {
    "placeholders": {
      "count": {
        "type": "int"
      }
    }
  },

  "filters": "Filters",
  "@filters": {
    "description": "Filters title"
  },

  "active": "active",
  "@active": {
    "description": "Active filters count suffix"
  },

  "sortBy": "Sort By",
  "@sortBy": {
    "description": "Sort by section title"
  },

  "newest": "Newest",
  "@newest": {
    "description": "Sort by newest option"
  },

  "popular": "Popular",
  "@popular": {
    "description": "Sort by popular option"
  },

  "sectorAz": "Azerbaijani",
  "@sectorAz": {
    "description": "Azerbaijani sector filter"
  },

  "sectorRu": "Russian",
  "@sectorRu": {
    "description": "Russian sector filter"
  },

  "sectorEn": "English",
  "@sectorEn": {
    "description": "English sector filter"
  },

  "allFaculties": "All Faculties",
  "@allFaculties": {
    "description": "All faculties filter option"
  },

  "clearAll": "Clear All",
  "@clearAll": {
    "description": "Clear all filters button"
  },

  "apply": "Apply",
  "@apply": {
    "description": "Apply filters button"
  },

  "replyingTo": "Replying to",
  "noInternetConnection": "No internet connection",
  "checkConnectionAndRetry": "Please check your connection and try again",
  "announcement": "Announcement",
  "advertisement": "Advertisement",
  "event": "Event",
  "information": "Information",
  "featured": "Featured",
  "learnMore": "Learn More",
  "video": "Video",
  "addMedia": "Add media",
  "typeToConfirm": "Type to confirm",
  "loadingImage": "Loading image...",
  "imageLoadFailed": "Failed to load image",
  "translate": "Translate",
  "showOriginal": "Show original",
  "translating": "Translating...",
  "translationFailed": "Translation failed",
  "pinnedPost": "Pinned post",
  "resubmissionInfo": "Please upload a new screenshot following the guidelines below.",

  "friends": "Friends",
  "friendRequests": "Friend Requests",
  "addFriend": "Add Friend",
  "add": "Add",
  "removeFriend": "Remove Friend",
  "cancelRequest": "Cancel Request",
  "accept": "Accept",
  "reject": "Reject",
  "pending": "Pending",
  "remove": "Remove",
  "removeFriendConfirmation": "Are you sure you want to remove this friend?",
  "noFriendsYet": "No friends yet",
  "startAddingFriends": "Start adding friends to connect with them",
  "noIncomingRequests": "No incoming requests",
  "noIncomingRequestsSubtitle": "You don't have any pending friend requests",
  "noOutgoingRequests": "No sent requests",
  "noOutgoingRequestsSubtitle": "You haven't sent any friend requests yet",
  "incoming": "Incoming",
  "outgoing": "Outgoing",
  "sentAt": "Sent",
  "usersFound": "{count} users found",
  "@usersFound": {
    "placeholders": {
      "count": {
        "type": "int"
      }
    }
  }

}


// ============================================
// FILE: l10n/app_ru.arb
// ============================================
{
  "@@locale": "ru",

  "appName": "UniTalky",
  "@appName": {
    "description": "Application name"
  },

  "verificationRequiredMessage": "Вам необходимо пройти верификацию для доступа к чату. Пожалуйста, завершите процесс верификации.",
  "goToProfile": "Перейти в профиль",
  "edit": "Редактировать",

  "editMessage": "Редактировать сообщение",
  "deleteMessage": "Удалить сообщение",
  "deleteMessageConfirm": "Вы уверены, что хотите удалить это сообщение?",
  "enterMessage": "Введите сообщение",

  "failedToLoadMessages": "Не удалось загрузить сообщения",

  "unknown": "Неизвестно",
  "photo": "Фото",
  "messageDeleted": "Сообщение удалено",
  "edited": "(ред.)",
  "replyTo": "Ответ",

  "continueWithApple": "Продолжить с Apple",
  "back": "Назад",
  "cancel": "Отмена",
  "save": "Сохранить",
  "delete": "Удалить",
  "retry": "Повторить",
  "continueButton": "Продолжить",
  "close": "Закрыть",
  "complete": "Завершить",
  "welcome": "Добро пожаловать",
  "introSubtitle": "Общайтесь с университетским сообществом",
  "introDescription": "Будьте в курсе жизни своего университета!",
  "signInWithGoogle": "Войти через Google",
  "continueWithGoogle": "Продолжить с Google",
  "byContinuingYouAgree": "Продолжая, вы соглашаетесь с нашими",
  "and": "и",
  "termsOfService": "Условиями использования",
  "privacyPolicy": "Политикой конфиденциальности",
  "errorOccurred": "Упс! Что-то пошло не так",
  "anErrorOccurred": "Произошла ошибка",

  "profileSetup": "Настройка профиля",
  "completeProfile": "Заполните профиль",
  "completeProfileTitle": "Добро пожаловать!",
  "completeProfileSubtitle": "Давайте настроим ваш профиль за пару шагов",
  "whatsYourName": "Как вас зовут?",
  "realNameRequired": "Используйте настоящее имя, чтобы пройти верификацию и завоевать доверие в сообществе",

  "personalInformation": "Личные данные",
  "firstName": "Имя",
  "firstNameHint": "Введите ваше имя",
  "enterFirstName": "Введите ваше имя",
  "firstNameRequired": "Имя обязательно",
  "firstNameTooShort": "Имя должно содержать минимум 2 символа",
  "lastName": "Фамилия",
  "lastNameHint": "Введите вашу фамилию",
  "enterLastName": "Введите вашу фамилию",
  "lastNameRequired": "Фамилия обязательна",
  "lastNameTooShort": "Фамилия должна содержать минимум 2 символа",
  "fillAllFields": "Пожалуйста, заполните все обязательные поля",

  "academicInformation": "Учебная информация",
  "university": "Университет",
  "selectUniversity": "Выберите университет",
  "selectYourUniversity": "Выберите ваш университет",
  "chooseUniversityYouAttend": "Выберите университет, в котором вы учитесь",
  "selectUniversityPrompt": "Выберите университет",
  "selectUniversitySubtitle": "Выберите университет для просмотра ленты",
  "selectUniversityFirst": "Сначала выберите университет",
  "searchUniversity": "Поиск университета...",
  "searchUniversities": "Поиск университетов...",
  "universityRequired": "Пожалуйста, выберите университет",
  "failedToLoadUniversities": "Не удалось загрузить университеты",
  "noUniversitiesFound": "Университеты не найдены",
  "yourUniversity": "Ваш университет",
  "tapToChangeUniversity": "Нажмите, чтобы сменить университет",

  "faculty": "Факультет",
  "selectFaculty": "Выберите факультет",
  "selectYourFaculty": "Выберите ваш факультет",
  "chooseYourFieldOfStudy": "Выберите направление обучения",
  "selectFacultyPrompt": "Выберите факультет",
  "searchFaculty": "Поиск факультета...",
  "searchFaculties": "Поиск факультетов...",
  "facultyRequired": "Пожалуйста, выберите факультет",
  "failedToLoadFaculties": "Не удалось загрузить факультеты",
  "noFacultiesFound": "Факультеты не найдены",

  "sector": "Сектор",
  "selectSector": "Выберите сектор",
  "selectSectorPrompt": "Выберите сектор",
  "sectorAzerbaijani": "Азербайджанский",
  "sectorRussian": "Русский",
  "sectorEnglish": "Английский",

  "select": "Выберите {item}",
  "notSelected": "Не выбрано",
  "tryDifferentSearchTerm": "Попробуйте другой запрос",

  "accountVerification": "Верификация",
  "getVerified": "Пройти верификацию",
  "verifyStudentStatus": "Подтвердите свой студенческий статус",
  "verified": "Верифицирован",
  "verificationPending": "На проверке",
  "verificationUnderReview": "Ваша верификация проверяется",
  "verificationPendingTitle": "На проверке",
  "verificationPendingMessage": "Мы проверяем ваш документ. Вы получите уведомление, когда проверка завершится (обычно 1-3 дня).",
  "verificationRejected": "Верификация отклонена",
  "pleaseTryAgain": "Попробуйте снова",
  "verificationRejectedTitle": "Верификация отклонена",
  "reason": "Причина:",
  "uploadNewScreenshot": "Пожалуйста, загрузите новый скриншот из раздела Образование приложения MyGov",
  "tryAgain": "Попробовать снова",
  "accountVerifiedTitle": "Вы верифицированы! 🎉",
  "accountVerifiedMessage": "Ваш аккаунт верифицирован! Теперь доступны все функции.",
  "verificationWarningTitle": "Внимание!",
  "verificationWarningMessage": "Смена университета или факультета сбросит вашу верификацию. Вам нужно будет пройти её заново.",
  "verificationWarning": "Важно: Принимаются только скриншоты из раздела Образование приложения MyGov. Студенческие билеты не подходят.",
  "verificationTimeline": "Верификация обычно занимает 1-3 рабочих дня. Мы уведомим вас, когда она завершится.",

  "myGovDocumentUpload": "Загрузка документа MyGov",
  "myGovUploadInstruction": "Загрузите скриншот раздела Образование из приложения MyGov",
  "howToPrepare": "Как подготовить?",
  "verificationStep1": "1. Откройте мобильное приложение MyGov",
  "verificationStep2": "2. Перейдите в раздел 'Образование'",
  "verificationStep3": "3. Сделайте скриншот, где видна ваша студенческая информация",
  "verificationStep4": "4. Убедитесь, что изображение чёткое и читаемое",
  "noScreenshotSelected": "Скриншот не выбран",
  "pleaseSelectImage": "Пожалуйста, выберите изображение",
  "uploadFailed": "Ошибка загрузки",
  "documentUploadedSuccessfully": "Документ успешно загружен!",
  "uploadAndSend": "Загрузить и отправить",

  "fromGallery": "Из галереи",
  "gallery": "Галерея",
  "camera": "Камера",
  "chooseFromGallery": "Выбрать из галереи",
  "takePhoto": "Сделать фото",
  "removePhoto": "Удалить фото",
  "addImage": "Добавить изображение",
  "attachImage": "Прикрепить изображение",
  "changeImage": "Изменить изображение",
  "errorPickingImage": "Ошибка выбора изображения: {error}",
  "errorTakingPhoto": "Ошибка при создании фото: {error}",
  "imageLoadError": "Не удалось загрузить изображение",

  "settings": "Настройки",
  "darkMode": "Тёмная тема",
  "language": "Язык",
  "selectLanguage": "Выберите язык",
  "notifications": "Уведомления",
  "notificationSettings": "Настройки уведомлений",
  "enableNotifications": "Включить уведомления",
  "enableNotificationsDescription": "Включить/выключить все уведомления",
  "noNotifications": "Пока нет уведомлений",
  "errorLoadingNotifications": "Не удалось загрузить уведомления",
  "errorLoadingSettings": "Не удалось загрузить настройки",
  "markAllAsRead": "Отметить все как прочитанные",
  "deleteAll": "Удалить все",
  "deleteNotification": "Удалить уведомление",
  "deleteNotificationConfirm": "Удалить это уведомление?",
  "deleteAllNotifications": "Удалить все уведомления",
  "deleteAllNotificationsConfirm": "Удалить все уведомления? Это действие нельзя отменить.",
  "notificationDeleted": "Уведомление удалено",

  "posts": "Посты",
  "newPosts": "Новые посты",
  "newPostsDescription": "Уведомлять о новых постах",
  "newComments": "Новые комментарии",
  "newCommentsDescription": "Уведомлять о комментариях к вашим постам",
  "newLikes": "Новые лайки",
  "newLikesDescription": "Уведомлять о лайках к вашим постам",

  "comments": "Комментарии",
  "commentReplies": "Ответы на комментарии",
  "commentRepliesDescription": "Уведомлять об ответах на ваши комментарии",
  "mentions": "Упоминания",
  "mentionsDescription": "Уведомлять, когда вас упоминают",

  "chatMessages": "Сообщения в чате",
  "chatMessagesDescription": "Уведомлять о новых сообщениях в чате факультета",
  "chatMentions": "Упоминания в чате",
  "chatMentionsDescription": "Уведомлять, когда вас упоминают в чате",

  "privacySecurity": "Конфиденциальность и безопасность",
  "helpSupport": "Помощь и поддержка",
  "about": "О приложении",
  "logout": "Выйти",
  "areYouSureLogout": "Вы уверены, что хотите выйти?",

  "profile": "Профиль",
  "editProfile": "Редактировать профиль",
  "failedToUpdateProfile": "Не удалось обновить профиль",
  "myPosts": "Мои посты",
  "postsCount": "{count, plural, =0{Нет постов} =1{1 пост} few{{count} поста} other{{count} постов}}",
  "noPostsYet": "Постов пока нет",
  "userHasNoPosts": "Этот пользователь пока ничего не постил",

  "studentIdCard": "Студенческий билет",
  "idLabel": "ID",
  "notAvailable": "Н/Д",

  "verificationRequired": "Требуется верификация",
  "verificationRequiredTitle": "Пройдите верификацию",
  "chatAccessVerifiedOnly": "Только верифицированные студенты могут общаться в чате. Пройдите верификацию, чтобы присоединиться.",
  "verifiedUsersOnly": "Только верифицированные студенты",
  "facultyStudentsOnly": "Только студенты вашего факультета",
  "privateAndSecure": "Приватное и безопасное общение",
  "canOnlyPostInOwnUniversity": "Вы можете публиковать только в своём университете",

  "chat": "Чат",
  "connecting": "Подключение...",
  "connectionError": "Ошибка подключения",
  "chatDescription": "Это чат факультета {facultyName}. Могут участвовать только верифицированные студенты.",
  "noMessages": "Сообщений пока нет",
  "noMessagesYet": "Сообщений пока нет",
  "startConversation": "Будьте первым, кто начнёт разговор!",
  "createFirstSupportMessage": "Создайте первое сообщение для получения помощи от нашей команды",
  "typeMessage": "Напишите сообщение...",
  "userIsTyping": "{name} печатает...",

  "participants": "Участники",
  "participantsCount": "{count, plural, =0{Нет участников} =1{1 участник} few{{count} участника} other{{count} участников}}",
  "totalParticipants": "{count, plural, =0{Нет участников} =1{1 участник} few{{count} участника} other{{count} участников}}",
  "noParticipants": "Нет участников",
  "noParticipantsDescription": "В этом чате пока нет участников",
  "loadingParticipants": "Загрузка участников...",

  "yesterday": "Вчера",
  "weekday": "{day, select, 1{Пн} 2{Вт} 3{Ср} 4{Чт} 5{Пт} 6{Сб} 7{Вс} other{}}",
  "daysAgo": "{count}д назад",

  "newPost": "Новый пост",
  "post": "ОПУБЛИКОВАТЬ",
  "postTitle": "Пост",
  "anonymous": "Аноним",
  "user": "Пользователь",
  "whatsOnYourMind": "Что у вас нового?",
  "characterCount": "{current} / {max}",
  "actions": "ДЕЙСТВИЯ",
  "anonymousMode": "Анонимный режим",
  "publicMode": "Публичный режим",
  "yourIdentityIsHidden": "Ваша личность скрыта",
  "yourNameIsVisible": "Ваше имя видно",
  "anonymousToggleEnable": "Опубликовать анонимно",
  "anonymousToggleDisable": "Опубликовать под своим именем",
  "anonymousToggleLabelOn": "Анонимный режим включён",
  "anonymousToggleLabelOff": "Анонимный режим выключен",

  "pleaseAddContent": "Добавьте текст или изображение для публикации",
  "postCreatedSuccessfully": "Опубликовано! 🎉",
  "failedToCreatePost": "Не удалось создать пост",
  "failedToLoadPosts": "Не удалось загрузить посты",
  "beTheFirstToShare": "Будьте первым, кто поделится чем-то!",
  "postNotFound": "Пост не найден",
  "postMayHaveBeenDeleted": "Этот пост мог быть удалён",
  "deletePost": "Удалить пост",
  "deletePostConfirmation": "Удалить этот пост?",

  "like": "Нравится",
  "likes": "Лайки",
  "failedToLoadLikes": "Не удалось загрузить лайки",
  "noLikesYet": "Лайков пока нет",
  "beTheFirstToLike": "Будьте первым, кто поставит лайк",

  "comment": "Комментарий",
  "noCommentsYet": "Комментариев пока нет",
  "startTheConversation": "Начните обсуждение",
  "commentAnonymously": "Комментировать анонимно...",
  "writeComment": "Напишите комментарий...",
  "deleteComment": "Удалить комментарий",
  "deleteCommentConfirmation": "Удалить этот комментарий?",

  "reply": "Ответить",
  "repliesCount": "{count, plural, =0{Нет ответов} =1{1 ответ} few{{count} ответа} other{{count} ответов}}",
  "replyAnonymously": "Ответить анонимно...",
  "writeReply": "Напишите ответ...",
  "deleteReply": "Удалить ответ",
  "deleteReplyConfirmation": "Удалить этот ответ?",

  "share": "Поделиться",
  "repost": "Репост",

  "navFeed": "Лента",
  "navSearch": "Поиск",
  "navChat": "Чат",
  "navProfile": "Профиль",

  "searchUsers": "Поиск пользователей",
  "searchUsersByName": "Поиск по имени...",
  "searchForUsers": "Ищите пользователей по имени",
  "typeToStartSearching": "Введите минимум 2 символа для начала поиска",
  "noUsersFound": "Пользователи не найдены",
  "tryDifferentName": "Попробуйте другое имя",
  "usersFound": "{count, plural, =0{Пользователи не найдены} =1{Найден 1 пользователь} one{Найден {count} пользователь} few{Найдено {count} пользователя} many{Найдено {count} пользователей} other{Найдено {count} пользователей}}",
  "userNotFound": "Пользователь не найден",
  "errorMessage": "Ошибка: {error}",

  "createMessage": "Создать сообщение",
  "newMessage": "Новое сообщение",
  "filterByStatus": "Фильтр по статусу",
  "clearFilter": "Очистить",
  "allMessages": "Все сообщения",
  "pending": "В ожидании",
  "inProgress": "В процессе",
  "resolved": "Решено",
  "closed": "Закрыто",

  "newSupportMessage": "Новое обращение в поддержку",
  "supportTeamResponse": "Наша команда обычно отвечает в течение 24 часов",
  "category": "Категория",
  "selectCategory": "Выберите категорию",
  "technicalIssue": "Техническая проблема",
  "accountIssue": "Проблема с аккаунтом",
  "verificationCategory": "Верификация",
  "contentIssue": "Проблема с контентом",
  "other": "Другое",

  "subjectHint": "Краткое описание вашей проблемы",
  "subjectRequired": "Тема обязательна",
  "subjectTooLong": "Тема должна быть короче 200 символов",

  "message": "Сообщение",
  "messageHint": "Сообщение...",
  "messageRequired": "Сообщение обязательно",
  "messageTooLong": "Сообщение должно быть короче 2000 символов",

  "submitMessage": "Отправить сообщение",
  "messageSentSuccess": "Сообщение успешно отправлено!",
  "messageDetails": "Детали сообщения",

  "allCaughtUp": "Вы всё просмотрели!",
  "categoryTechnical": "Техническая",
  "categoryAccount": "Аккаунт",
  "categoryVerification": "Верификация",
  "categoryContent": "Контент",
  "categoryOther": "Другое",
  "statusPending": "Ожидает",
  "statusInProgress": "В процессе",
  "statusResolved": "Решено",
  "statusClosed": "Закрыто",
  "clear": "Очистить",
  "dateTimeFormat": "{day}/{month}/{year} в {hour}:{minute}",
  "categoryTechnicalIssue": "Техническая проблема",
  "categoryAccountIssue": "Проблема с аккаунтом",
  "categoryContentIssue": "Проблема с контентом",
  "supportResponseTime": "Наша служба поддержки обычно отвечает в течение 24 часов",
  "supportMessageSentSuccess": "Сообщение в поддержку успешно отправлено",
  "deleteAccount": "Удалить аккаунт",
  "deleteAccountWarning": "⚠️ Внимание: Это действие необратимо!",
  "deleteAccountDescription": "Удаление аккаунта приведет к безвозвратному удалению всех ваших данных с наших серверов. Это включает:",
  "willBeDeleted": "Что будет удалено:",
  "allPosts": "Все ваши посты",
  "allComments": "Все ваши комментарии",
  "profileData": "Ваш профиль и личные данные",
  "thisActionCannotBeUndone": "Это действие нельзя отменить!",
  "finalConfirmation": "Финальное подтверждение",
  "typeDeleteToConfirm": "Введите DELETE для подтверждения удаления аккаунта:",
  "pleaseTypeDeleteCorrectly": "Пожалуйста, введите DELETE правильно для подтверждения",
  "deleteForever": "Удалить навсегда",
  "termsOfUse": "Условия использования",

  "aboutApp": "О приложении",
  "appVersion": "Версия 1.0.0",
  "projectDescription": "Описание проекта",
  "aboutProjectText": "UniTalk - это современное мобильное приложение, разработанное в рамках студенческого проекта по предмету «Бренд и реклама». Приложение создано для улучшения коммуникации между студентами университета.",
  "courseInformation": "Информация о курсе",
  "subject": "Предмет:",
  "brandAndAdvertising": "Бренд и реклама",
  "group": "Группа:",
  "teacher": "Преподаватель:",
  "teacherName": "Лидия Сафронова",
  "projectTeam": "Команда проекта",
  "studentName1": "Рауф Халилов",
  "studentName2": "Талех Бадалов",
  "studentName3": "Гюнай Мирзоева",
  "studentName4": "Анастасия Лобастова",
  "studentName5": "Исмаил Нагиев",
  "projectPurpose": "Цель проекта",
  "purposeText": "Создание удобной платформы для студенческого общения, обмена информацией и совместной работы над учебными проектами.",
  "madeWithLove": "Сделано с ❤️ студентами группы 787",
  "universityInformation": "Информация об университете",
  "universityName": "Азербайджанский Государственный Экономический Университет (UNEC)",
  "facultyName": "Дизайн",

  "blockUser": "Заблокировать пользователя",
  "unblockUser": "Разблокировать пользователя",
  "blockedUsers": "Заблокированные пользователи",
  "noBlockedUsers": "Нет заблокированных пользователей",
  "blockUserConfirmation": "Вы уверены, что хотите заблокировать {name}?",
  "unblockUserConfirmation": "Вы уверены, что хотите разблокировать {name}?",
  "youBlockedThisUser": "Вы заблокировали этого пользователя",
  "thisUserBlockedYou": "Этот пользователь заблокировал вас",
  "userBlocked": "Пользователь успешно заблокирован",
  "userUnblocked": "Пользователь успешно разблокирован",
  "block": "Заблокировать",
  "unblock": "Разблокировать",

  "report": "Пожаловаться",
  "reportTitle": "Жалоба",
  "reportPost": "Пожаловаться на пост",
  "reportComment": "Пожаловаться на комментарий",
  "reportMessage": "Пожаловаться на сообщение",
  "reportUser": "Пожаловаться на пользователя",
  "myReports": "Мои жалобы",
  "noReports": "Жалоб пока нет",
  "selectReportCategory": "Пожалуйста, выберите категорию",
  "selectReportReason": "Пожалуйста, выберите причину жалобы",
  "reportSubmitted": "Жалоба успешно отправлена",
  "submitReport": "Отправить жалобу",
  "cancelReport": "Отменить жалобу",
  "cancelReportConfirmation": "Вы уверены, что хотите отменить эту жалобу?",

  "spam": "Спам",
  "harassment": "Домогательство",
  "hateSpeech": "Разжигание ненависти",
  "violence": "Насилие",
  "nudity": "Обнажённое содержание",
  "falseInformation": "Ложная информация",
  "impersonation": "Имперсонация",
  "underReview": "На рассмотрении",
  "rejected": "Отклонено",

  "additionalDetails": "Дополнительные детали (необязательно)",
  "describeIssue": "Опишите проблему...",
  "all": "Все",
  "filter": "Фильтр",
  "yes": "Да",
  "no": "Нет",

  "likedByPrefix": "Нравится",
  "andOthers": "и еще {count}",
  "likesCount": "{count} отметок «Нравится»",

  "filters": "Фильтры",
  "@filters": {
    "description": "Filters title"
  },

  "active": "активно",
  "@active": {
    "description": "Active filters count suffix"
  },

  "sortBy": "Сортировать",
  "@sortBy": {
    "description": "Sort by section title"
  },

  "newest": "Новые",
  "@newest": {
    "description": "Sort by newest option"
  },

  "popular": "Популярные",
  "@popular": {
    "description": "Sort by popular option"
  },

  "sectorAz": "Азербайджанский",
  "@sectorAz": {
    "description": "Azerbaijani sector filter"
  },

  "sectorRu": "Русский",
  "@sectorRu": {
    "description": "Russian sector filter"
  },

  "sectorEn": "Английский",
  "@sectorEn": {
    "description": "English sector filter"
  },

  "allFaculties": "Все Факультеты",
  "@allFaculties": {
    "description": "All faculties filter option"
  },

  "clearAll": "Очистить Всё",
  "@clearAll": {
    "description": "Clear all filters button"
  },

  "apply": "Применить",
  "@apply": {
    "description": "Apply filters button"
  },
  "replyingTo": "Отвечаете",
  "noInternetConnection": "Нет подключения к интернету",
  "checkConnectionAndRetry": "Пожалуйста, проверьте соединение и попробуйте снова",
  "announcement": "Объявление",
  "advertisement": "Реклама",
  "event": "Событие",
  "information": "Информация",
  "featured": "Важное",
  "learnMore": "Подробнее",
  "video": "Видео",
  "addMedia": "Добавить медиа",
  "typeToConfirm": "Введите для подтверждения",
  "loadingImage": "Загрузка изображения...",
  "imageLoadFailed": "Не удалось загрузить изображение",
  "translate": "Перевести",
  "showOriginal": "Показать оригинал",
  "translating": "Перевод...",
  "translationFailed": "Ошибка перевода",
  "pinnedPost": "Закрепленный пост",
  "resubmissionInfo": "Пожалуйста, загрузите новый скриншот, следуя инструкциям ниже.",
  "friends": "Friends",
  "friendRequests": "Friend Requests",
  "addFriend": "Add Friend",
  "add": "Add",
  "removeFriend": "Remove Friend",
  "cancelRequest": "Cancel Request",
  "accept": "Accept",
  "reject": "Reject",
  "pending": "Pending",
  "remove": "Remove",
  "removeFriendConfirmation": "Are you sure you want to remove this friend?",
  "noFriendsYet": "No friends yet",
  "startAddingFriends": "Start adding friends to connect with them",
  "noIncomingRequests": "No incoming requests",
  "noIncomingRequestsSubtitle": "You don't have any pending friend requests",
  "noOutgoingRequests": "No sent requests",
  "noOutgoingRequestsSubtitle": "You haven't sent any friend requests yet",
  "incoming": "Incoming",
  "outgoing": "Outgoing",
  "sentAt": "Sent",
  "usersFound": "{count} users found",
  "@usersFound": {
    "placeholders": {
      "count": {
        "type": "int"
      }
    }
  }


}


// ============================================
// FILE: l10n/app_az.arb
// ============================================
{
  "@@locale": "az",

  "appName": "UniTalky",
  "continueWithApple": "Apple ilə davam et",
  "@appName": {
    "description": "Application name"
  },

  "back": "Geri",
  "cancel": "Ləğv et",
  "save": "Yadda saxla",
  "delete": "Sil",
  "retry": "Yenidən cəhd et",
  "continueButton": "Davam et",
  "close": "Bağla",
  "complete": "Tamamla",
  "welcome": "Xoş gəlmisiniz",
  "introSubtitle": "Universitet icması ilə əlaqə qurun",
  "introDescription": "Universitet həyatından xəbərdar ol",
  "signInWithGoogle": "Google ilə daxil olun",
  "continueWithGoogle": "Google ilə davam et",
  "byContinuingYouAgree": "Davam etməklə siz bizim",
  "and": "və",
  "termsOfService": "İstifadə Şərtlərimiz",
  "privacyPolicy": "Məxfilik Siyasətimiz",
  "errorOccurred": "Xəta baş verdi",
  "anErrorOccurred": "Xəta baş verdi",

  "profileSetup": "Profil quraşdırılması",
  "completeProfile": "Profilinizi tamamlayın",
  "completeProfileTitle": "Xoş gəldiniz!",
  "completeProfileSubtitle": "Gəlin bir neçə addımda profilinizi quraşdıraq",
  "whatsYourName": "Adınız nədir?",
  "realNameRequired": "Yoxlanılmaq və icmada etibar qazanmaq üçün real adınızdan istifadə edin",

  "personalInformation": "Şəxsi məlumat",
  "firstName": "Ad",
  "firstNameHint": "Adınızı daxil edin",
  "enterFirstName": "Adınızı daxil edin",
  "firstNameRequired": "Ad vacibdir",
  "firstNameTooShort": "Ad ən azı 2 simvoldan ibarət olmalıdır",
  "lastName": "Soyad",
  "lastNameHint": "Soyadınızı daxil edin",
  "enterLastName": "Soyadınızı daxil edin",
  "lastNameRequired": "Soyad vacibdir",
  "lastNameTooShort": "Soyad ən azı 2 simvoldan ibarət olmalıdır",
  "fillAllFields": "Zəhmət olmasa bütün vacib sahələri doldurun",

  "academicInformation": "Təhsil məlumatı",
  "university": "Universitet",
  "selectUniversity": "Universitet seçin",
  "selectYourUniversity": "Universitetinizi seçin",
  "chooseUniversityYouAttend": "Oxuduğunuz universiteti seçin",
  "selectUniversityPrompt": "Universitet seçin",
  "selectUniversitySubtitle": "Lenti görmək üçün universitet seçin",
  "selectUniversityFirst": "Əvvəlcə universitet seçin",
  "searchUniversity": "Universitet axtar...",
  "searchUniversities": "Universitetləri axtar...",
  "universityRequired": "Zəhmət olmasa universitet seçin",
  "failedToLoadUniversities": "Universitetlər yüklənə bilmədi",
  "noUniversitiesFound": "Universitet tapılmadı",
  "yourUniversity": "Universitetiniz",
  "tapToChangeUniversity": "Universiteti dəyişmək üçün toxunun",

  "faculty": "Fakültə",
  "selectFaculty": "Fakültə seçin",
  "selectYourFaculty": "Fakültənizi seçin",
  "chooseYourFieldOfStudy": "Təhsil sahənizi seçin",
  "selectFacultyPrompt": "Fakültə seçin",
  "searchFaculty": "Fakültə axtar...",
  "searchFaculties": "Fakültələri axtar...",
  "facultyRequired": "Zəhmət olmasa fakültə seçin",
  "failedToLoadFaculties": "Fakültələr yüklənə bilmədi",
  "noFacultiesFound": "Fakültə tapılmadı",

  "sector": "Sektor",
  "selectSector": "Sektor seçin",
  "selectSectorPrompt": "Sektor seçin",
  "sectorAzerbaijani": "Azərbaycan",
  "sectorRussian": "Rus",
  "sectorEnglish": "İngilis",

  "select": "{item} seçin",
  "notSelected": "Seçilməyib",
  "tryDifferentSearchTerm": "Başqa axtarış sorğusu yoxlayın",

  "accountVerification": "Yoxlanılma",
  "getVerified": "Yoxlanılın",
  "verifyStudentStatus": "Tələbə statusunuzu təsdiq edin",
  "verified": "Yoxlanılıb",
  "verificationPending": "Yoxlanılır",
  "verificationUnderReview": "Yoxlanılmanız nəzərdən keçirilir",
  "verificationPendingTitle": "Yoxlanılır",
  "verificationPendingMessage": "Sənədiniz yoxlanılır. Proses bitdikdə bildiriş alacaqsınız (adətən 1-3 gün).",
  "verificationRejected": "Yoxlanılma rədd edildi",
  "pleaseTryAgain": "Yenidən cəhd edin",
  "verificationRejectedTitle": "Yoxlanılma rədd edildi",
  "reason": "Səbəb:",
  "uploadNewScreenshot": "Zəhmət olmasa MyGov tətbiqinin Təhsil bölməsindən yeni skrinşot yükləyin",
  "tryAgain": "Yenidən cəhd et",
  "accountVerifiedTitle": "Yoxlanıldınız! 🎉",
  "accountVerifiedMessage": "Hesabınız yoxlanıldı! İndi bütün funksiyalara girişiniz var.",
  "verificationWarningTitle": "Diqqət!",
  "verificationWarningMessage": "Universitet və ya fakültəni dəyişdirmək yoxlanılmanızı sıfırlayacaq. Yenidən yoxlanılmaq lazımdır.",
  "verificationWarning": "Önəmli: Yalnız MyGov tətbiqinin Təhsil bölməsindən skrinşotlar qəbul edilir. Tələbə biletləri uyğun deyil.",
  "verificationTimeline": "Yoxlanılma adətən 1-3 iş günü çəkir. Tamamlandıqda sizə bildiriş göndərəcəyik.",

  "myGovDocumentUpload": "MyGov sənəd yükləmə",
  "myGovUploadInstruction": "MyGov tətbiqindən Təhsil bölməsinin skrinşotunu yükləyin",
  "howToPrepare": "Necə hazırlamaq olar?",
  "verificationStep1": "1. MyGov mobil tətbiqini açın",
  "verificationStep2": "2. 'Təhsil' bölməsinə keçin",
  "verificationStep3": "3. Tələbə məlumatınızın göründüyü skrinşot çəkin",
  "verificationStep4": "4. Şəklin aydın və oxunaqlı olduğundan əmin olun",
  "noScreenshotSelected": "Skrinşot seçilməyib",
  "pleaseSelectImage": "Zəhmət olmasa şəkil seçin",
  "uploadFailed": "Yükləmə uğursuz oldu",
  "documentUploadedSuccessfully": "Sənəd uğurla yükləndi!",
  "uploadAndSend": "Yüklə və göndər",

  "fromGallery": "Qalereya",
  "gallery": "Qalereya",
  "camera": "Kamera",
  "chooseFromGallery": "Qalereyadan seç",
  "takePhoto": "Foto çək",
  "removePhoto": "Fotonu sil",
  "addImage": "Şəkil əlavə et",
  "addMedia": "Media əlavə et",
  "attachImage": "Şəkil əlavə et",
  "changeImage": "Şəkli dəyiş",
  "errorPickingImage": "Şəkil seçilərkən xəta: {error}",
  "errorTakingPhoto": "Foto çəkilərkən xəta: {error}",
  "imageLoadError": "Şəkil yüklənə bilmədi",

  "settings": "Parametrlər",
  "darkMode": "Qaranlıq tema",
  "language": "Dil",
  "selectLanguage": "Dil seçin",
  "notifications": "Bildirişlər",
  "notificationSettings": "Bildiriş parametrləri",
  "enableNotifications": "Bildirişləri aktivləşdir",
  "enableNotificationsDescription": "Bütün bildirişləri açın/bağlayın",
  "noNotifications": "Hələ bildiriş yoxdur",
  "errorLoadingNotifications": "Bildirişlər yüklənə bilmədi",
  "errorLoadingSettings": "Parametrlər yüklənə bilmədi",
  "markAllAsRead": "Hamısını oxunmuş kimi işarələ",
  "deleteAll": "Hamısını sil",
  "deleteNotification": "Bildirişi sil",
  "deleteNotificationConfirm": "Bu bildirişi silmək istədiyinizə əminsiniz?",
  "deleteAllNotifications": "Bütün bildirişləri sil",
  "deleteAllNotificationsConfirm": "Bütün bildirişləri silmək istəyirsiniz? Bu əməliyyat geri qaytarıla bilməz.",
  "notificationDeleted": "Bildiriş silindi",

  "posts": "Yazılar",
  "newPosts": "Yeni yazılar",
  "newPostsDescription": "Yeni yazılar haqqında bildiriş alın",
  "newComments": "Yeni şərhlər",
  "newCommentsDescription": "Yazılarınıza şərhlər haqqında bildiriş alın",
  "newLikes": "Yeni bəyənmələr",
  "newLikesDescription": "Yazılarınıza bəyənmələr haqqında bildiriş alın",

  "comments": "Şərhlər",
  "commentReplies": "Şərh cavabları",
  "commentRepliesDescription": "Şərhlərinizə cavablar haqqında bildiriş alın",
  "mentions": "Qeydlər",
  "mentionsDescription": "Sizi qeyd edəndə bildiriş alın",

  "chatMessages": "Çat mesajları",
  "chatMessagesDescription": "Fakültə çatında yeni mesajlar haqqında bildiriş alın",
  "chatMentions": "Çatda qeydlər",
  "chatMentionsDescription": "Çatda sizi qeyd edəndə bildiriş alın",

  "privacySecurity": "Məxfilik və təhlükəsizlik",
  "helpSupport": "Kömək və dəstək",
  "about": "Haqqında",
  "logout": "Çıxış",
  "areYouSureLogout": "Çıxış etmək istədiyinizə əminsiniz?",

  "profile": "Profil",
  "editProfile": "Profili redaktə et",
  "failedToUpdateProfile": "Profil yenilənə bilmədi",
  "myPosts": "Yazılarım",
  "postsCount": "{count, plural, =0{Yazı yoxdur} =1{1 yazı} other{{count} yazı}}",
  "noPostsYet": "Hələ yazı yoxdur",
  "userHasNoPosts": "Bu istifadəçi hələ heç nə paylaşmayıb",

  "studentIdCard": "Tələbə bileti",
  "idLabel": "ID",
  "notAvailable": "M/Y",

  "verificationRequired": "Yoxlanılma tələb olunur",
  "verificationRequiredTitle": "Yoxlanılın",
  "chatAccessVerifiedOnly": "Yalnız yoxlanılmış tələbələr çatda iştirak edə bilər. Qoşulmaq üçün yoxlanılma prosesini tamamlayın.",
  "verifiedUsersOnly": "Yalnız yoxlanılmış tələbələr",
  "facultyStudentsOnly": "Yalnız sizin fakültənin tələbələri",
  "privateAndSecure": "Məxfi və təhlükəsiz ünsiyyət",
  "canOnlyPostInOwnUniversity": "Yalnız öz universitetinizdə paylaşım edə bilərsiniz",

  "chat": "Çat",
  "connecting": "Qoşulur...",
  "connectionError": "Əlaqə xətası",
  "chatDescription": "Bu {facultyName} fakültəsinin çatıdır. Yalnız yoxlanılmış tələbələr iştirak edə bilər.",
  "noMessages": "Hələ mesaj yoxdur",
  "noMessagesYet": "Hələ mesaj yoxdur",
  "startConversation": "Söhbətə başlayan ilk şəxs olun!",
  "createFirstSupportMessage": "Komandamızdan kömək almaq üçün ilk mesajı yaradın",
  "typeMessage": "Mesaj yazın...",
  "userIsTyping": "{name} yazır...",

  "participants": "İştirakçılar",
  "participantsCount": "{count, plural, =0{İştirakçı yoxdur} =1{1 iştirakçı} other{{count} iştirakçı}}",
  "totalParticipants": "{count, plural, =0{İştirakçı yoxdur} =1{1 iştirakçı} other{{count} iştirakçı}}",
  "noParticipants": "İştirakçı yoxdur",
  "noParticipantsDescription": "Bu çatda hələ iştirakçı yoxdur",
  "loadingParticipants": "İştirakçılar yüklənir...",

  "yesterday": "Dünən",
  "weekday": "{day, select, 1{Baz.e} 2{Ç.a} 3{Ç} 4{C.a} 5{C} 6{Ş} 7{B} other{}}",
  "daysAgo": "{count} gün əvvəl",

  "newPost": "Yeni yazı",
  "post": "PAYLAŞ",
  "postTitle": "Yazı",
  "anonymous": "Anonim",
  "user": "İstifadəçi",
  "whatsOnYourMind": "Nə düşünürsünüz?",
  "characterCount": "{current} / {max}",
  "actions": "ƏMƏLİYYATLAR",
  "anonymousMode": "Anonim rejim",
  "publicMode": "Açıq rejim",
  "yourIdentityIsHidden": "Şəxsiyyətiniz gizlidir",
  "yourNameIsVisible": "Adınız görünür",
  "anonymousToggleEnable": "Anonim paylaş",
  "anonymousToggleDisable": "Adınızla paylaş",
  "anonymousToggleLabelOn": "Anonim rejim aktiv",
  "anonymousToggleLabelOff": "Anonim rejim deaktiv",

  "pleaseAddContent": "Paylaşmaq üçün mətn və ya şəkil əlavə edin",
  "postCreatedSuccessfully": "Paylaşıldı! 🎉",
  "failedToCreatePost": "Yazı yaradıla bilmədi",
  "failedToLoadPosts": "Yazılar yüklənə bilmədi",
  "beTheFirstToShare": "İlk paylaşan siz olun!",
  "postNotFound": "Yazı tapılmadı",
  "postMayHaveBeenDeleted": "Bu yazı silinmiş ola bilər",
  "deletePost": "Yazını sil",
  "deletePostConfirmation": "Bu yazını silmək istədiyinizə əminsiniz?",

  "like": "Bəyən",
  "likes": "Bəyənmələr",
  "failedToLoadLikes": "Bəyənmələr yüklənə bilmədi",
  "noLikesYet": "Hələ bəyənmə yoxdur",
  "beTheFirstToLike": "Bu yazını bəyənən ilk şəxs olun",

  "comment": "Şərh",
  "noCommentsYet": "Hələ şərh yoxdur",
  "startTheConversation": "Müzakirəyə başlayın",
  "commentAnonymously": "Anonim şərh yazın...",
  "writeComment": "Şərh yazın...",
  "deleteComment": "Şərhi sil",
  "deleteCommentConfirmation": "Bu şərhi silmək istədiyinizə əminsiniz?",

  "reply": "Cavabla",
  "repliesCount": "{count, plural, =0{Cavab yoxdur} =1{1 cavab} other{{count} cavab}}",
  "replyAnonymously": "Anonim cavab yazın...",
  "writeReply": "Cavab yazın...",
  "deleteReply": "Cavabı sil",
  "deleteReplyConfirmation": "Bu cavabı silmək istədiyinizə əminsiniz?",

  "share": "Paylaş",
  "repost": "Yenidən paylaş",

  "navFeed": "Lent",
  "navSearch": "Axtar",
  "navChat": "Çat",
  "navProfile": "Profil",

  "searchUsers": "İstifadəçi axtar",
  "searchUsersByName": "Ada görə axtar...",
  "searchForUsers": "İstifadəçiləri ada görə axtarın",
  "typeToStartSearching": "Axtarışa başlamaq üçün ən azı 2 simvol yazın",
  "noUsersFound": "İstifadəçi tapılmadı",
  "tryDifferentName": "Başqa adla axtarın",
  "usersFound": "{count, plural, =0{İstifadəçi tapılmadı} =1{1 istifadəçi tapıldı} other{{count} istifadəçi tapıldı}}",
  "userNotFound": "İstifadəçi tapılmadı",
  "errorMessage": "Xəta: {error}",

  "createMessage": "Mesaj yarat",
  "newMessage": "Yeni mesaj",
  "filterByStatus": "Statusa görə filter",
  "clearFilter": "Təmizlə",
  "allMessages": "Bütün mesajlar",
  "pending": "Gözləyir",
  "inProgress": "İcra olunur",
  "resolved": "Həll olundu",
  "closed": "Bağlandı",

  "newSupportMessage": "Yeni dəstək mesajı",
  "supportTeamResponse": "Dəstək komandamız adətən 24 saat ərzində cavab verir",
  "category": "Kateqoriya",
  "selectCategory": "Kateqoriya seçin",
  "technicalIssue": "Texniki problem",
  "accountIssue": "Hesab problemi",
  "verificationCategory": "Yoxlanılma",
  "contentIssue": "Kontent problemi",
  "other": "Digər",

  "verificationRequiredMessage": "Söhbətə daxil olmaq üçün təsdiqdən keçməlisiniz. Zəhmət olmasa, əvvəlcə təsdiqi tamamlayın.",
  "goToProfile": "Profilə Keç",
  "edit": "Redaktə Et",

  "editMessage": "Mesajı Redaktə Et",
  "deleteMessage": "Mesajı Sil",
  "deleteMessageConfirm": "Bu mesajı silmək istədiyinizdən əminsiniz?",
  "enterMessage": "Mesaj daxil edin",

  "failedToLoadMessages": "Mesajları yükləmək alınmadı",

  "unknown": "Naməlum",
  "photo": "Şəkil",
  "messageDeleted": "Mesaj silindi",
  "edited": "(red.)",
  "replyTo": "Cavab",
  "subjectHint": "Probleminizin qısa təsviri",
  "subjectRequired": "Mövzu vacibdir",
  "subjectTooLong": "Mövzu 200 simvoldan qısa olmalıdır",

  "message": "Mesaj",
  "messageHint": "Mesaj...",
  "messageRequired": "Mesaj vacibdir",
  "messageTooLong": "Mesaj 2000 simvoldan qısa olmalıdır",

  "submitMessage": "Mesajı göndər",
  "messageSentSuccess": "Dəstək mesajı uğurla göndərildi!",
  "messageDetails": "Mesaj detalları",

  "allCaughtUp": "Hamısını gördünüz!",
  "categoryTechnical": "Texniki",
  "categoryAccount": "Hesab",
  "categoryVerification": "Doğrulama",
  "categoryContent": "Məzmun",
  "categoryOther": "Digər",
  "statusPending": "Gözləyir",
  "statusInProgress": "Prosesdə",
  "statusResolved": "Həll olundu",
  "statusClosed": "Bağlandı",
  "clear": "Təmizlə",
  "dateTimeFormat": "{day}/{month}/{year} saat {hour}:{minute}",
  "categoryTechnicalIssue": "Texniki problem",
  "categoryAccountIssue": "Hesab problemi",
  "categoryContentIssue": "Məzmun problemi",
  "supportResponseTime": "Dəstək komandamız adətən 24 saat ərzində cavab verir",
  "supportMessageSentSuccess": "Dəstək mesajı uğurla göndərildi",
  "deleteAccount": "Hesabı sil",
  "deleteAccountWarning": "⚠️ Xəbərdarlıq: Bu əməliyyat geri qaytarılmazdır!",
  "deleteAccountDescription": "Hesabınızı silmək bütün məlumatlarınızı serverlərmizdən birdəfəlik siləcək. Bura daxildir:",
  "willBeDeleted": "Nə silinəcək:",
  "allPosts": "Bütün postlarınız",
  "allComments": "Bütün şərhləriniz",
  "profileData": "Profiliniz və şəxsi məlumatlarınız",
  "thisActionCannotBeUndone": "Bu əməliyyatı geri qaytarmaq mümkün deyil!",
  "finalConfirmation": "Son təsdiq",
  "typeDeleteToConfirm": "Hesabın silinməsini təsdiqləmək üçün DELETE yazın:",
  "pleaseTypeDeleteCorrectly": "Zəhmət olmasa təsdiq üçün DELETE düzgün yazın",
  "deleteForever": "Həmişəlik sil",
  "termsOfUse": "İstifadə şərtləri",
  "aboutApp": "Tətbiq haqqında",
  "appVersion": "Versiya 1.0.0",
  "projectDescription": "Layihənin təsviri",
  "aboutProjectText": "UniTalk «Brend və Reklam» fənni üzrə tələbə layihəsi çərçivəsində hazırlanmış müasir mobil tətbiqdir. Tətbiq universitet tələbələri arasında ünsiyyətin yaxşılaşdırılması üçün yaradılmışdır.",
  "courseInformation": "Kurs haqqında məlumat",
  "subject": "Fənn:",
  "brandAndAdvertising": "Brend və Reklam",
  "group": "Qrup:",
  "teacher": "Müəllim:",
  "teacherName": "Lidiya Safronova",
  "projectTeam": "Layihə komandası",
  "studentName1": "Rauf Xəlilov",
  "studentName2": "Taleh Bədəlov",
  "studentName3": "Günay Mirzəyeva",
  "studentName4": "Anastasiya Lobastova",
  "studentName5": "Ismayil Nağıyev",
  "projectPurpose": "Layihənin məqsədi",
  "purposeText": "Tələbələrin ünsiyyəti, informasiya mübadiləsi və tədris layihələri üzərində birgə işləmək üçün rahat platformanın yaradılması.",
  "madeWithLove": "787 qrup tələbələri tərəfindən ❤️ ilə hazırlanmışdır",
  "universityInformation": "Universitet haqqında məlumat",
  "universityName": "Azərbaycan Dövlət İqtisad Universiteti (UNEC)",
  "facultyName": "Dizayn",

  "blockUser": "İstifadəçini blokla",
  "unblockUser": "Bloku götür",
  "blockedUsers": "Bloklanan istifadəçilər",
  "noBlockedUsers": "Bloklanan istifadəçi yoxdur",
  "blockUserConfirmation": "{name} istifadəçisini bloklamaq istədiyinizə əminsiniz?",
  "unblockUserConfirmation": "{name} istifadəçisinin blokunu götürmək istədiyinizə əminsiniz?",
  "youBlockedThisUser": "Bu istifadəçini bloklamısınız",
  "thisUserBlockedYou": "Bu istifadəçi sizi bloklamışdır",
  "userBlocked": "İstifadəçi uğurla bloklandı",
  "userUnblocked": "İstifadəçinin bloku uğurla götürüldü",
  "block": "Blokla",
  "unblock": "Bloku götür",

  "report": "Şikayət et",
  "reportTitle": "Şikayət",
  "reportPost": "Yazıya şikayət et",
  "reportComment": "Şərhə şikayət et",
  "reportMessage": "Mesaja şikayət et",
  "reportUser": "İstifadəçiyə şikayət et",
  "myReports": "Şikayətlərim",
  "noReports": "Hələ şikayət yoxdur",
  "selectReportCategory": "Zəhmət olmasa kateqoriya seçin",
  "selectReportReason": "Zəhmət olmasa şikayət səbəbini seçin",
  "reportSubmitted": "Şikayət uğurla göndərildi",
  "submitReport": "Şikayəti göndər",
  "cancelReport": "Şikayəti ləğv et",
  "cancelReportConfirmation": "Bu şikayəti ləğv etmək istədiyinizə əminsiniz?",

  "spam": "Spam",
  "harassment": "Təzyiq",
  "hateSpeech": "Nifrət nitqi",
  "violence": "Zorakılıq",
  "nudity": "Çılpaqlıq",
  "falseInformation": "Yalan məlumat",
  "impersonation": "Saxta şəxsiyyət",
  "underReview": "Baxılır",
  "rejected": "Rədd edildi",

  "additionalDetails": "Əlavə təfərrüatlar (İstəyə bağlı)",
  "describeIssue": "Problemi təsvir edin...",
  "all": "Hamısı",
  "filter": "Filter",
  "yes": "Bəli",
  "no": "Xeyr",

  "likedByPrefix": "Bəyəndi",
  "andOthers": "və daha {count}",
  "likesCount": "{count} bəyənmə",

  "filters": "Filtrlər",
  "@filters": {
    "description": "Filters title"
  },

  "active": "aktiv",
  "@active": {
    "description": "Active filters count suffix"
  },

  "sortBy": "Sırala",
  "@sortBy": {
    "description": "Sort by section title"
  },

  "newest": "Yeni",
  "@newest": {
    "description": "Sort by newest option"
  },

  "popular": "Populyar",
  "@popular": {
    "description": "Sort by popular option"
  },

  "sectorAz": "Azərbaycan",
  "@sectorAz": {
    "description": "Azerbaijani sector filter"
  },

  "sectorRu": "Rus",
  "@sectorRu": {
    "description": "Russian sector filter"
  },

  "sectorEn": "İngilis",
  "@sectorEn": {
    "description": "English sector filter"
  },

  "allFaculties": "Bütün Fakültələr",
  "@allFaculties": {
    "description": "All faculties filter option"
  },

  "clearAll": "Hamısını Təmizlə",
  "@clearAll": {
    "description": "Clear all filters button"
  },

  "apply": "Tətbiq Et",
  "@apply": {
    "description": "Apply filters button"
  },

  "replyingTo": "Cavab verir",
  "noInternetConnection": "İnternet bağlantısı yoxdur",
  "checkConnectionAndRetry": "Zəhmət olmasa bağlantınızı yoxlayın və yenidən cəhd edin",
  "announcement": "Elan",
  "advertisement": "Reklam",
  "event": "Tədbir",
  "information": "Məlumat",
  "featured": "Seçilmiş",
  "learnMore": "Ətraflı",
  "video": "Video",

  "typeToConfirm": "Təsdiq etmək üçün yazın",

  "loadingImage": "Şəkil yüklənir...",
  "imageLoadFailed": "Şəkil yüklənə bilmədi",
  "translate": "Tərcümə et",
  "showOriginal": "Orijinalı göstər",
  "translating": "Tərcümə olunur...",
  "translationFailed": "Tərcümə uğursuz oldu",
  "pinnedPost": "Sabitlənmiş göndəriş",
  "resubmissionInfo": "Zəhmət olmasa aşağıdakı təlimatlara əməl edərək yeni ekran görüntüsü yükləyin.",

  "friends": "Friends",
  "friendRequests": "Friend Requests",
  "addFriend": "Add Friend",
  "add": "Add",
  "removeFriend": "Remove Friend",
  "cancelRequest": "Cancel Request",
  "accept": "Accept",
  "reject": "Reject",
  "pending": "Pending",
  "remove": "Remove",
  "removeFriendConfirmation": "Are you sure you want to remove this friend?",
  "noFriendsYet": "No friends yet",
  "startAddingFriends": "Start adding friends to connect with them",
  "noIncomingRequests": "No incoming requests",
  "noIncomingRequestsSubtitle": "You don't have any pending friend requests",
  "noOutgoingRequests": "No sent requests",
  "noOutgoingRequestsSubtitle": "You haven't sent any friend requests yet",
  "incoming": "Incoming",
  "outgoing": "Outgoing",
  "sentAt": "Sent",
  "usersFound": "{count} users found",
  "@usersFound": {
    "placeholders": {
      "count": {
        "type": "int"
      }
    }
  }


}


// ============================================
// FILE: l10n/bloc/locale_cubit.dart
// ============================================
import 'package:unitalk/l10n/domain/repository/locale_repository.dart';
import 'package:unitalk/features/auth/data/datasource/user_remote_datasource.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class LocaleCubit extends Cubit<Locale> {
  final LocaleRepository _repository;
  final UserRemoteDataSource _userDataSource;

  LocaleCubit(this._repository, this._userDataSource) : super(const Locale('en'));

  /// Загружает локальный язык при старте приложения (до авторизации)
  Future<void> loadLocale() async {
    final saved = await _repository.getSavedLocale();
    emit(saved);
  }

  /// Синхронизирует язык после входа пользователя
  /// - isFirstLogin = true: отправляем локальный язык на сервер
  /// - isFirstLogin = false: используем язык с сервера
  Future<void> syncWithUser({
    required String? userLanguage,
    required bool isFirstLogin,
  }) async {
    if (isFirstLogin) {
      // При первом входе (регистрации) - отправляем локальный язык на сервер
      final currentLocale = state;
      print('📝 First login: sending local language to server: ${currentLocale.languageCode}');

      try {
        await _userDataSource.updateLanguage(currentLocale.languageCode);
        print('✅ Local language synced to server');
      } catch (e) {
        print('⚠️ Failed to sync local language to server: $e');
      }
    } else {
      // При повторном входе - используем язык с сервера
      if (userLanguage != null && _isValidLanguage(userLanguage)) {
        final serverLocale = Locale(userLanguage);

        // Только если язык отличается от текущего
        if (serverLocale.languageCode != state.languageCode) {
          print('🌍 Using server language: $userLanguage');
          await _repository.saveLocale(serverLocale);
          emit(serverLocale);
        }
      }
    }
  }

  /// Меняет язык вручную (из настроек) и синхронизирует с сервером
  Future<void> changeLocale(Locale locale) async {
    try {
      // 1. Сохраняем локально сразу для быстрого отклика UI
      await _repository.saveLocale(locale);
      emit(locale);

      // 2. Отправляем на сервер в фоне
      await _userDataSource.updateLanguage(locale.languageCode);
      print('✅ Language synced to server: ${locale.languageCode}');
    } catch (e) {
      // Если ошибка на сервере - не критично, локально уже сохранено
      print('⚠️ Failed to sync language to server: $e');
    }
  }

  bool _isValidLanguage(String code) {
    return ['en', 'ru', 'az'].contains(code);
  }
}


// ============================================
// FILE: main.dart
// ============================================
import 'dart:async';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:flutter_app_badge/flutter_app_badge.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:go_router/go_router.dart';
import 'package:unitalk/core/di/service_locator.dart';
import 'package:unitalk/core/router/app_router.dart' as AppRouter;
import 'package:unitalk/core/theme/app_theme.dart';
import 'package:unitalk/core/theme/bloc/theme_bloc.dart';
import 'package:unitalk/core/theme/bloc/theme_event.dart';
import 'package:unitalk/core/theme/bloc/theme_state.dart';
import 'package:unitalk/core/theme/domain/entity/app_theme_mode.dart';
import 'package:unitalk/features/auth/presentation/bloc/auth_bloc.dart';
import 'package:unitalk/features/auth/presentation/bloc/auth_event.dart';
import 'package:unitalk/features/auth/presentation/bloc/auth_state.dart';
import 'package:unitalk/features/block/presentation/bloc/block_bloc.dart';
import 'package:unitalk/features/chat/presentation/bloc/chat_bloc.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_bloc.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_bloc.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_event.dart';
import 'package:unitalk/features/report/presentation/bloc/report_bloc.dart';
import 'package:unitalk/features/search/presentation/bloc/user_search_bloc.dart';
import 'package:unitalk/features/support/presentation/bloc/support_bloc.dart';
import 'package:unitalk/features/university/presentation/manager/university_bloc.dart';
import 'package:unitalk/features/university/presentation/manager/university_event.dart';
import 'package:unitalk/firebase_options.dart';
import 'package:unitalk/l10n/app_localizations.dart' show AppLocalizations;
import 'package:unitalk/l10n/bloc/locale_cubit.dart';

final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  FlutterAppBadge.count(0);

  await initDependencies();
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  late final NotificationBloc _notificationBloc;
  late final ChatBloc _chatBloc;
  late final AuthBloc _authBloc;
  late final LocaleCubit _localeCubit;
  late final GoRouter _router;

  StreamSubscription<AuthState>? _authSubscription;
  StreamSubscription<RemoteMessage>? _foregroundMessagesSubscription;
  StreamSubscription<RemoteMessage>? _messageOpenedSubscription;
  StreamSubscription<String>? _tokenRefreshSubscription;

  bool _hasInitializedNotifications = false;

  @override
  void initState() {
    super.initState();
    _notificationBloc = sl<NotificationBloc>();
    _chatBloc = sl<ChatBloc>();
    _authBloc = sl<AuthBloc>()..add(GetCurrentUserEvent());
    _localeCubit = sl<LocaleCubit>()..loadLocale();
    _router = AppRouter.router;

    _setupFCM();
    _setupNotificationHandlers();
    _listenToAuth();
  }

  void _setupFCM() async {
    final settings = await FirebaseMessaging.instance.requestPermission(
      alert: true,
      badge: true,
      sound: true,
      provisional: false,
    );

    if (settings.authorizationStatus == AuthorizationStatus.authorized ||
        settings.authorizationStatus == AuthorizationStatus.provisional) {

      await FirebaseMessaging.instance.setForegroundNotificationPresentationOptions(
        alert: false,
        badge: false,
        sound: false,

      );

      final token = await FirebaseMessaging.instance.getToken();
      if (token != null && _authBloc.state.status == AuthStatus.authenticated) {
        _notificationBloc.add(SaveFcmTokenEvent(token));
      }

      _tokenRefreshSubscription = FirebaseMessaging.instance.onTokenRefresh
          .listen((newToken) {
        if (_authBloc.state.status == AuthStatus.authenticated) {
          _notificationBloc.add(SaveFcmTokenEvent(newToken));
        }
      });
    }
  }

  void _setupNotificationHandlers() {
    // Foreground notifications
    _foregroundMessagesSubscription = FirebaseMessaging.onMessage.listen((
      message,
    ) {
      _notificationBloc.add(HandleIncomingNotificationEvent(message.data));

      if (message.notification != null) {
        _showLocalNotification(message);
      }
    });

    // Background notification taps
    _messageOpenedSubscription = FirebaseMessaging.onMessageOpenedApp.listen((
      message,
    ) {
      _navigateFromNotification(message);
    });

    // Local notification initialization
    flutterLocalNotificationsPlugin.initialize(
      const InitializationSettings(
        android: AndroidInitializationSettings('@mipmap/ic_launcher'),
        iOS: DarwinInitializationSettings(),
      ),
      onDidReceiveNotificationResponse: (details) {
        if (details.payload != null) {
          _router.go('/notifications');
        }
      },
    );
  }

  void _showLocalNotification(RemoteMessage message) async {
    final notificationDetails = NotificationDetails(
      android: AndroidNotificationDetails(
        message.data['type'] == 'new_chat_message' ? 'chat' : 'default',
        message.data['type'] == 'new_chat_message' ? 'Chat' : 'Default',
        importance: Importance.high,
        priority: Priority.high,
      ),
      iOS: DarwinNotificationDetails(
        presentAlert: true,
        presentBadge: true,
        presentSound: true,
        sound: 'default',
        badgeNumber: 1,
      ),
    );

    await flutterLocalNotificationsPlugin.show(
      message.hashCode,
      message.notification?.title ?? 'New notification',
      message.notification?.body ?? '',
      notificationDetails,
      payload: message.data['notificationId'],
    );
  }

  void _navigateFromNotification(RemoteMessage message) {
    final route = _getRouteFromNotification(message);
    if (route != null) {
      _router.push(route);
    }
  }

  String? _getRouteFromNotification(RemoteMessage message) {
    final data = message.data;
    final type = data['type'];

    switch (type) {
      case 'new_post':
      case 'new_comment':
      case 'new_like':
      case 'comment_reply':
      case 'new_comment_like':
      case 'mention':
        if (data['postId'] != null) {
          return '/post/${data['postId']}';
        }
        break;
      case 'new_chat_message':
      case 'chat_mention':
        return '/chat';
      default:
        return '/notifications';
    }
    return null;
  }

  void _listenToAuth() {
    _authSubscription = _authBloc.stream.listen((state) {
      if (state.status == AuthStatus.authenticated) {
        _onUserAuthenticated(state);
      } else if (state.status == AuthStatus.unauthenticated ||
          state.status == AuthStatus.logout) {
        _onUserUnauthenticated();
      }
    });

    if (_authBloc.state.status == AuthStatus.authenticated) {
      _onUserAuthenticated(_authBloc.state);
    }
  }

  void _onUserAuthenticated(AuthState state) async {
    if (_hasInitializedNotifications) return;
    _hasInitializedNotifications = true;

    final isFirstLogin = _isFirstLogin(state.user);

    await _localeCubit.syncWithUser(
      userLanguage: state.user?.language,
      isFirstLogin: isFirstLogin,
    );

    final token = await FirebaseMessaging.instance.getToken();
    if (token != null) {
      _notificationBloc.add(SaveFcmTokenEvent(token));
    }

    _notificationBloc.add(GetNotificationSettingsEvent());
    _notificationBloc.add(GetNotificationsEvent());
  }

  bool _isFirstLogin(dynamic user) {
    return user == null ||
        user.language == null ||
        user.language.isEmpty ||
        !user.isProfileComplete;
  }

  void _onUserUnauthenticated() {
    _hasInitializedNotifications = false;
    _notificationBloc.add(RemoveFcmTokenEvent());
  }

  @override
  void dispose() {
    _authSubscription?.cancel();
    _foregroundMessagesSubscription?.cancel();
    _messageOpenedSubscription?.cancel();
    _tokenRefreshSubscription?.cancel();

    _notificationBloc.close();
    _authBloc.close();
    _localeCubit.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return MultiBlocProvider(
      providers: [
        BlocProvider.value(value: _authBloc),
        BlocProvider(create: (_) => sl<ThemeBloc>()..add(LoadTheme())),
        BlocProvider(
          create: (_) => sl<UniversityBloc>()..add(LoadUniversitiesEvent()),
        ),
        BlocProvider.value(value: _localeCubit),
        BlocProvider.value(value: _chatBloc),
        BlocProvider(create: (_) => sl<UserSearchBloc>()),
        BlocProvider(create: (_) => sl<SupportBloc>()),
        BlocProvider.value(value: _notificationBloc),
        BlocProvider(create: (_) => sl<BlockBloc>()),
        BlocProvider(create: (_) => sl<ReportBloc>()),
        BlocProvider(create: (context) => sl<FriendshipBloc>()), // ← ДОБАВИТЬ

      ],
      child: BlocBuilder<ThemeBloc, ThemeState>(
        builder: (context, themeState) {
          return BlocListener<AuthBloc, AuthState>(
            listener: (context, state) {
              if(state.status == AuthStatus.logout){
                _router.go('/auth');
              }
              if(state.status == AuthStatus.unauthenticated){
                if(_router.state.matchedLocation != '/auth' && !_router.state.matchedLocation.startsWith('/profile-setup')){
                  _router.go('/auth');
                }
              }
              print('asada ${state.status}');
            },
            child: BlocBuilder<LocaleCubit, Locale>(
              builder: (context, locale) {
                return MaterialApp.router(
                  title: 'UniTalky',
                  debugShowCheckedModeBanner: false,
                  darkTheme: AppTheme.darkTheme,
                  theme: AppTheme.lightTheme,
                  themeMode: themeState.themeMode == AppThemeMode.dark
                      ? ThemeMode.dark
                      : ThemeMode.light,
                  locale: locale,
                  localizationsDelegates: const [
                    AppLocalizations.delegate,
                    GlobalMaterialLocalizations.delegate,
                    GlobalWidgetsLocalizations.delegate,
                    GlobalCupertinoLocalizations.delegate,
                  ],
                  supportedLocales: const [
                    Locale('en'),
                    Locale('az'),
                    Locale('ru'),
                  ],
                  routerConfig: _router,
                );
              },
            ),
          );
        },
      ),
    );
  }
}



