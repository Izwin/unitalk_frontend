import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/features/friendship/data/model/friendship_model.dart' show FriendshipStatusResponse, FriendshipStatus;
import 'package:unitalk/features/friendship/domain/repository/friendship_repository.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_state.dart' show FriendshipState, FriendshipStateStatus;
import 'friendship_event.dart';


class FriendshipBloc extends Bloc<FriendshipEvent, FriendshipState> {
  final FriendshipRepository repository;

  FriendshipBloc({required this.repository}) : super(FriendshipState.initial()) {
    on<SendFriendRequestEvent>(_onSendFriendRequest);
    on<AcceptFriendRequestEvent>(_onAcceptFriendRequest);
    on<RejectFriendRequestEvent>(_onRejectFriendRequest);
    on<RemoveFriendshipEvent>(_onRemoveFriendship);
    on<LoadFriendsListEvent>(_onLoadFriendsList);
    on<LoadIncomingRequestsEvent>(_onLoadIncomingRequests);
    on<LoadOutgoingRequestsEvent>(_onLoadOutgoingRequests);
    on<LoadFriendshipStatusEvent>(_onLoadFriendshipStatus);
    on<ClearFriendshipStateEvent>(_onClearState);
  }



  // Загрузить список друзей
  Future<void> _onLoadFriendsList(
      LoadFriendsListEvent event,
      Emitter<FriendshipState> emit,
      ) async {
    if (event.loadMore) {
      if (!state.friendsHasMore || state.isLoadingMore) return;
      emit(state.copyWith(status: FriendshipStateStatus.loadingMore));
    } else {
      emit(state.copyWith(
        status: FriendshipStateStatus.loading,
        friends: [],
        friendsPage: 1,
      ));
    }

    final page = event.loadMore ? state.friendsPage : 1;

    final result = await repository.getFriendsList(page: page, limit: 20);

    result.fold(
          (failure) {
        emit(state.copyWith(
          status: FriendshipStateStatus.failure,
          errorMessage: failure.message,
        ));
      },
          (newFriends) {
        final updatedFriends = event.loadMore
            ? [...state.friends, ...newFriends]
            : newFriends;

        emit(state.copyWith(
          status: FriendshipStateStatus.success,
          friends: updatedFriends,
          friendsPage: page + 1,
          friendsHasMore: newFriends.length >= 20,
        ));
      },
    );
  }

  // Загрузить входящие запросы
  Future<void> _onLoadIncomingRequests(
      LoadIncomingRequestsEvent event,
      Emitter<FriendshipState> emit,
      ) async {
    if (event.loadMore) {
      if (!state.incomingHasMore || state.isLoadingMore) return;
      emit(state.copyWith(status: FriendshipStateStatus.loadingMore));
    } else {
      emit(state.copyWith(
        status: FriendshipStateStatus.loading,
        incomingRequests: [],
        incomingPage: 1,
      ));
    }

    final page = event.loadMore ? state.incomingPage : 1;

    final result = await repository.getIncomingRequests(page: page, limit: 20);

    result.fold(
          (failure) {
        emit(state.copyWith(
          status: FriendshipStateStatus.failure,
          errorMessage: failure.message,
        ));
      },
          (newRequests) {
        final updatedRequests = event.loadMore
            ? [...state.incomingRequests, ...newRequests]
            : newRequests;

        emit(state.copyWith(
          status: FriendshipStateStatus.success,
          incomingRequests: updatedRequests,
          incomingPage: page + 1,
          incomingHasMore: newRequests.length >= 20,
        ));
      },
    );
  }

  // Загрузить исходящие запросы
  Future<void> _onLoadOutgoingRequests(
      LoadOutgoingRequestsEvent event,
      Emitter<FriendshipState> emit,
      ) async {
    if (event.loadMore) {
      if (!state.outgoingHasMore || state.isLoadingMore) return;
      emit(state.copyWith(status: FriendshipStateStatus.loadingMore));
    } else {
      emit(state.copyWith(
        status: FriendshipStateStatus.loading,
        outgoingRequests: [],
        outgoingPage: 1,
      ));
    }

    final page = event.loadMore ? state.outgoingPage : 1;

    final result = await repository.getOutgoingRequests(page: page, limit: 20);

    result.fold(
          (failure) {
        emit(state.copyWith(
          status: FriendshipStateStatus.failure,
          errorMessage: failure.message,
        ));
      },
          (newRequests) {
        final updatedRequests = event.loadMore
            ? [...state.outgoingRequests, ...newRequests]
            : newRequests;

        emit(state.copyWith(
          status: FriendshipStateStatus.success,
          outgoingRequests: updatedRequests,
          outgoingPage: page + 1,
          outgoingHasMore: newRequests.length >= 20,
        ));
      },
    );
  }

  // Загрузить статус дружбы с пользователем
  Future<void> _onLoadFriendshipStatus(
      LoadFriendshipStatusEvent event,
      Emitter<FriendshipState> emit,
      ) async {
    final result = await repository.getFriendshipStatus(event.userId);

    result.fold(
          (failure) {
        emit(state.copyWith(
          status: FriendshipStateStatus.failure,
          errorMessage: failure.message,
        ));
      },
          (status) {
        final updatedStatuses = Map<String, FriendshipStatusResponse>.from(
          state.friendshipStatuses,
        );
        updatedStatuses[event.userId] = status;

        emit(state.copyWith(
          status: FriendshipStateStatus.success,
          friendshipStatuses: updatedStatuses,
        ));
      },
    );
  }

  // Очистить состояние
  void _onClearState(
      ClearFriendshipStateEvent event,
      Emitter<FriendshipState> emit,
      ) {
    emit(FriendshipState.initial());
  }

  // Отправить запрос в друзья
  Future<void> _onSendFriendRequest(
      SendFriendRequestEvent event,
      Emitter<FriendshipState> emit,
      ) async {
    final result = await repository.sendFriendRequest(event.userId);

    result.fold(
          (failure) {
        emit(state.copyWith(
          status: FriendshipStateStatus.failure,
          errorMessage: failure.message,
        ));
      },
          (friendship) {
        // ✅ ИСПРАВЛЕНО: Используем правильный тип
        final updatedStatuses = Map<String, FriendshipStatusResponse>.from(
          state.friendshipStatuses,
        );

        updatedStatuses[event.userId] = FriendshipStatusResponse(
          status: FriendshipStatus.pending,
          isFriend: false,
          friendshipId: friendship.id ?? friendship.friendshipId,
          isRequester: true,
          createdAt: friendship.createdAt ?? DateTime.now(),
        );

        emit(state.copyWith(
          status: FriendshipStateStatus.success,
          friendshipStatuses: updatedStatuses,
        ));
      },
    );
  }

// Удалить дружбу
  Future<void> _onRemoveFriendship(
      RemoveFriendshipEvent event,
      Emitter<FriendshipState> emit,
      ) async {
    final result = await repository.removeFriendship(event.friendshipId);

    result.fold(
          (failure) {
        emit(state.copyWith(
          status: FriendshipStateStatus.failure,
          errorMessage: failure.message,
        ));
      },
          (_) {
        // ✅ ИСПРАВЛЕНО: Приоритет event.userId
        String? targetUserId = event.userId;

        // Если userId не передан, ищем в списках
        if (targetUserId == null) {
          // Ищем в исходящих запросах
          for (final request in state.outgoingRequests) {
            if (request.friendshipId == event.friendshipId) {
              targetUserId = request.user.id;
              break;
            }
          }

          // Ищем в друзьях
          if (targetUserId == null) {
            for (final friend in state.friends) {
              // Можно добавить поле friendshipId в модель или искать по другому
              // Пока пропускаем, так как в списке друзей нет friendshipId
            }
          }

          // ✅ НОВОЕ: Ищем в friendshipStatuses по friendshipId
          if (targetUserId == null) {
            for (final entry in state.friendshipStatuses.entries) {
              if (entry.value.friendshipId == event.friendshipId) {
                targetUserId = entry.key;
                break;
              }
            }
          }
        }

        // Обновляем списки
        final updatedFriends = state.friends
            .where((friend) => friend.id != targetUserId)
            .toList();

        final updatedOutgoing = state.outgoingRequests
            .where((req) => req.friendshipId != event.friendshipId)
            .toList();

        // Обновляем статусы
        final updatedStatuses = Map<String, FriendshipStatusResponse>.from(
          state.friendshipStatuses,
        );

        if (targetUserId != null) {
          updatedStatuses[targetUserId] = FriendshipStatusResponse(
            status: FriendshipStatus.none,
            isFriend: false,
          );
        }

        emit(state.copyWith(
          status: FriendshipStateStatus.success,
          friends: updatedFriends,
          outgoingRequests: updatedOutgoing,
          friendshipStatuses: updatedStatuses,
        ));
      },
    );
  }

// Принять запрос в друзья
  Future<void> _onAcceptFriendRequest(
      AcceptFriendRequestEvent event,
      Emitter<FriendshipState> emit,
      ) async {
    final result = await repository.acceptFriendRequest(event.friendshipId);

    result.fold(
          (failure) {
        emit(state.copyWith(
          status: FriendshipStateStatus.failure,
          errorMessage: failure.message,
        ));
      },
          (friendship) {
        // ✅ ИСПРАВЛЕНО: Находим пользователя и обновляем статус
        String? targetUserId;

        for (final request in state.incomingRequests) {
          if (request.friendshipId == event.friendshipId) {
            targetUserId = request.user.id;
            break;
          }
        }

        // Удаляем из входящих запросов
        final updatedIncoming = state.incomingRequests
            .where((req) => req.friendshipId != event.friendshipId)
            .toList();

        // Обновляем статусы
        final updatedStatuses = Map<String, FriendshipStatusResponse>.from(
          state.friendshipStatuses,
        );

        if (targetUserId != null) {
          updatedStatuses[targetUserId] = FriendshipStatusResponse(
            status: FriendshipStatus.accepted,
            isFriend: true,
            friendshipId: event.friendshipId,
            acceptedAt: DateTime.now(),
          );
        }

        emit(state.copyWith(
          status: FriendshipStateStatus.success,
          incomingRequests: updatedIncoming,
          friendshipStatuses: updatedStatuses,
        ));

        // Перезагружаем список друзей
        add(LoadFriendsListEvent());
      },
    );
  }

// Отклонить запрос в друзья
  Future<void> _onRejectFriendRequest(
      RejectFriendRequestEvent event,
      Emitter<FriendshipState> emit,
      ) async {
    final result = await repository.rejectFriendRequest(event.friendshipId);

    result.fold(
          (failure) {
        emit(state.copyWith(
          status: FriendshipStateStatus.failure,
          errorMessage: failure.message,
        ));
      },
          (_) {
        // ✅ ИСПРАВЛЕНО: Находим пользователя и обновляем статус
        String? targetUserId;

        for (final request in state.incomingRequests) {
          if (request.friendshipId == event.friendshipId) {
            targetUserId = request.user.id;
            break;
          }
        }

        // Удаляем из входящих запросов
        final updatedIncoming = state.incomingRequests
            .where((req) => req.friendshipId != event.friendshipId)
            .toList();

        // Обновляем статусы
        final updatedStatuses = Map<String, FriendshipStatusResponse>.from(
          state.friendshipStatuses,
        );

        if (targetUserId != null) {
          updatedStatuses[targetUserId] = FriendshipStatusResponse(
            status: FriendshipStatus.rejected,
            isFriend: false,
          );
        }

        emit(state.copyWith(
          status: FriendshipStateStatus.success,
          incomingRequests: updatedIncoming,
          friendshipStatuses: updatedStatuses,
        ));
      },
    );
  }
}abstract class FriendshipEvent {}

// Управление дружбой
class SendFriendRequestEvent extends FriendshipEvent {
  final String userId;
  SendFriendRequestEvent(this.userId);
}

class AcceptFriendRequestEvent extends FriendshipEvent {
  final String friendshipId;
  AcceptFriendRequestEvent(this.friendshipId);
}

class RejectFriendRequestEvent extends FriendshipEvent {
  final String friendshipId;
  RejectFriendRequestEvent(this.friendshipId);
}

class RemoveFriendshipEvent extends FriendshipEvent {
  final String friendshipId;
  final String? userId; // ✅ ДОБАВИТЬ

  RemoveFriendshipEvent(this.friendshipId, {this.userId}); // ✅ ИЗМЕНИТЬ
}

// Загрузка данных
class LoadFriendsListEvent extends FriendshipEvent {
  final bool loadMore;
  LoadFriendsListEvent({this.loadMore = false});
}

class LoadIncomingRequestsEvent extends FriendshipEvent {
  final bool loadMore;
  LoadIncomingRequestsEvent({this.loadMore = false});
}

class LoadOutgoingRequestsEvent extends FriendshipEvent {
  final bool loadMore;
  LoadOutgoingRequestsEvent({this.loadMore = false});
}

class LoadFriendshipStatusEvent extends FriendshipEvent {
  final String userId;
  LoadFriendshipStatusEvent(this.userId);
}

// Очистка
class ClearFriendshipStateEvent extends FriendshipEvent {}import 'package:unitalk/features/auth/data/model/user_model.dart';
import 'package:unitalk/features/friendship/data/model/friendship_model.dart';

enum FriendshipStateStatus { initial, loading, success, failure, loadingMore }

class FriendshipState {
  final FriendshipStateStatus status;

  // Списки
  final List<UserModel> friends;
  final List<FriendRequestModel> incomingRequests;
  final List<FriendRequestModel> outgoingRequests;

  // Пагинация
  final int friendsPage;
  final int incomingPage;
  final int outgoingPage;
  final bool friendsHasMore;
  final bool incomingHasMore;
  final bool outgoingHasMore;

  // Статус дружбы с конкретным пользователем
  final Map<String, FriendshipStatusResponse> friendshipStatuses;

  // Ошибки
  final String? errorMessage;

  FriendshipState({
    required this.status,
    this.friends = const [],
    this.incomingRequests = const [],
    this.outgoingRequests = const [],
    this.friendsPage = 1,
    this.incomingPage = 1,
    this.outgoingPage = 1,
    this.friendsHasMore = true,
    this.incomingHasMore = true,
    this.outgoingHasMore = true,
    this.friendshipStatuses = const {},
    this.errorMessage,
  });

  factory FriendshipState.initial() => FriendshipState(
    status: FriendshipStateStatus.initial,
  );

  FriendshipState copyWith({
    FriendshipStateStatus? status,
    List<UserModel>? friends,
    List<FriendRequestModel>? incomingRequests,
    List<FriendRequestModel>? outgoingRequests,
    int? friendsPage,
    int? incomingPage,
    int? outgoingPage,
    bool? friendsHasMore,
    bool? incomingHasMore,
    bool? outgoingHasMore,
    Map<String, FriendshipStatusResponse>? friendshipStatuses,
    String? errorMessage,
  }) {
    return FriendshipState(
      status: status ?? this.status,
      friends: friends ?? this.friends,
      incomingRequests: incomingRequests ?? this.incomingRequests,
      outgoingRequests: outgoingRequests ?? this.outgoingRequests,
      friendsPage: friendsPage ?? this.friendsPage,
      incomingPage: incomingPage ?? this.incomingPage,
      outgoingPage: outgoingPage ?? this.outgoingPage,
      friendsHasMore: friendsHasMore ?? this.friendsHasMore,
      incomingHasMore: incomingHasMore ?? this.incomingHasMore,
      outgoingHasMore: outgoingHasMore ?? this.outgoingHasMore,
      friendshipStatuses: friendshipStatuses ?? this.friendshipStatuses,
      errorMessage: errorMessage,
    );
  }

  // Геттеры для удобства
  FriendshipStatusResponse? getFriendshipStatus(String userId) {
    return friendshipStatuses[userId];
  }

  bool get isLoading => status == FriendshipStateStatus.loading;
  bool get isLoadingMore => status == FriendshipStateStatus.loadingMore;
  bool get hasError => status == FriendshipStateStatus.failure;
}import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/core/ui/common/empty_state_widget.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_bloc.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_event.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_state.dart';
import 'package:unitalk/features/friendship/presentation/widgets/friend_list_tile.dart';
import 'package:unitalk/l10n/app_localizations.dart';
import 'package:timeago/timeago.dart' as timeago;

class FriendRequestsPage extends StatefulWidget {
  const FriendRequestsPage({Key? key}) : super(key: key);

  @override
  State<FriendRequestsPage> createState() => _FriendRequestsPageState();
}

class _FriendRequestsPageState extends State<FriendRequestsPage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final ScrollController _incomingScrollController = ScrollController();
  final ScrollController _outgoingScrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _incomingScrollController.addListener(_onIncomingScroll);
    _outgoingScrollController.addListener(_onOutgoingScroll);

    // Загружаем входящие запросы при открытии
    context.read<FriendshipBloc>().add(LoadIncomingRequestsEvent());
  }

  @override
  void dispose() {
    _tabController.dispose();
    _incomingScrollController.dispose();
    _outgoingScrollController.dispose();
    super.dispose();
  }

  void _onIncomingScroll() {
    if (_isBottomIncoming) {
      final state = context.read<FriendshipBloc>().state;
      if (state.incomingHasMore && !state.isLoadingMore) {
        context.read<FriendshipBloc>().add(LoadIncomingRequestsEvent(loadMore: true));
      }
    }
  }

  void _onOutgoingScroll() {
    if (_isBottomOutgoing) {
      final state = context.read<FriendshipBloc>().state;
      if (state.outgoingHasMore && !state.isLoadingMore) {
        context.read<FriendshipBloc>().add(LoadOutgoingRequestsEvent(loadMore: true));
      }
    }
  }

  bool get _isBottomIncoming {
    if (!_incomingScrollController.hasClients) return false;
    final maxScroll = _incomingScrollController.position.maxScrollExtent;
    final currentScroll = _incomingScrollController.offset;
    return currentScroll >= (maxScroll * 0.85);
  }

  bool get _isBottomOutgoing {
    if (!_outgoingScrollController.hasClients) return false;
    final maxScroll = _outgoingScrollController.position.maxScrollExtent;
    final currentScroll = _outgoingScrollController.offset;
    return currentScroll >= (maxScroll * 0.85);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: theme.scaffoldBackgroundColor,
        surfaceTintColor: theme.scaffoldBackgroundColor,
        title: Text(
          l10n.friendRequests,
          style: TextStyle(
            color: theme.textTheme.titleLarge?.color,
            fontSize: 20,
            fontWeight: FontWeight.w600,
          ),
        ),
        bottom: TabBar(
          controller: _tabController,
          labelColor: theme.primaryColor,
          unselectedLabelColor: theme.textTheme.bodySmall?.color?.withOpacity(0.6),
          indicatorColor: theme.primaryColor,
          onTap: (index) {
            if (index == 0) {
              context.read<FriendshipBloc>().add(LoadIncomingRequestsEvent());
            } else {
              context.read<FriendshipBloc>().add(LoadOutgoingRequestsEvent());
            }
          },
          tabs: [
            Tab(text: l10n.incoming),
            Tab(text: l10n.outgoing),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildIncomingTab(l10n, theme),
          _buildOutgoingTab(l10n, theme),
        ],
      ),
    );
  }

  Widget _buildIncomingTab(AppLocalizations l10n, ThemeData theme) {
    return BlocBuilder<FriendshipBloc, FriendshipState>(
      builder: (context, state) {
        if (state.status == FriendshipStateStatus.loading && state.incomingRequests.isEmpty) {
          return Center(
            child: CircularProgressIndicator(
              strokeWidth: 2,
              color: theme.primaryColor,
            ),
          );
        }

        if (state.hasError) {
          return EmptyStateWidget(
            icon: Icons.error_outline,
            title: state.errorMessage ?? l10n.anErrorOccurred,
            subtitle: null,
          );
        }

        if (state.incomingRequests.isEmpty) {
          return EmptyStateWidget(
            icon: Icons.inbox_outlined,
            title: l10n.noIncomingRequests,
            subtitle: l10n.noIncomingRequestsSubtitle,
          );
        }

        return RefreshIndicator(
          onRefresh: () async {
            context.read<FriendshipBloc>().add(LoadIncomingRequestsEvent());
          },
          child: ListView.separated(
            controller: _incomingScrollController,
            padding: const EdgeInsets.symmetric(vertical: 8),
            itemCount: state.incomingRequests.length + (state.incomingHasMore ? 1 : 0),
            separatorBuilder: (context, index) => Divider(
              height: 1,
              color: theme.dividerColor.withOpacity(0.1),
              indent: 76,
            ),
            itemBuilder: (context, index) {
              if (index >= state.incomingRequests.length) {
                return Padding(
                  padding: const EdgeInsets.all(16),
                  child: Center(
                    child: SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: theme.primaryColor,
                      ),
                    ),
                  ),
                );
              }

              final request = state.incomingRequests[index];
              return FriendListTile(
                user: request.user,
                subtitle: timeago.format(request.requestedAt),
                trailing: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    IconButton(
                      icon: const Icon(Icons.check, size: 20),
                      onPressed: () {
                        context.read<FriendshipBloc>().add(
                          AcceptFriendRequestEvent(request.friendshipId),
                        );
                      },
                      style: IconButton.styleFrom(
                        backgroundColor: theme.primaryColor,
                        foregroundColor: Colors.white,
                      ),
                    ),
                    const SizedBox(width: 8),
                    IconButton(
                      icon: const Icon(Icons.close, size: 20),
                      onPressed: () {
                        context.read<FriendshipBloc>().add(
                          RejectFriendRequestEvent(request.friendshipId),
                        );
                      },
                      style: IconButton.styleFrom(
                        backgroundColor: theme.cardColor,
                        foregroundColor: theme.textTheme.bodyMedium?.color,
                        side: BorderSide(color: theme.dividerColor),
                      ),
                    ),
                  ],
                ),
              );
            },
          ),
        );
      },
    );
  }

  Widget _buildOutgoingTab(AppLocalizations l10n, ThemeData theme) {
    return BlocBuilder<FriendshipBloc, FriendshipState>(
      builder: (context, state) {
        if (state.status == FriendshipStateStatus.loading && state.outgoingRequests.isEmpty) {
          return Center(
            child: CircularProgressIndicator(
              strokeWidth: 2,
              color: theme.primaryColor,
            ),
          );
        }

        if (state.hasError) {
          return EmptyStateWidget(
            icon: Icons.error_outline,
            title: state.errorMessage ?? l10n.anErrorOccurred,
            subtitle: null,
          );
        }

        if (state.outgoingRequests.isEmpty) {
          return EmptyStateWidget(
            icon: Icons.send_outlined,
            title: l10n.noOutgoingRequests,
            subtitle: l10n.noOutgoingRequestsSubtitle,
          );
        }

        return RefreshIndicator(
          onRefresh: () async {
            context.read<FriendshipBloc>().add(LoadOutgoingRequestsEvent());
          },
          child: ListView.separated(
            controller: _outgoingScrollController,
            padding: const EdgeInsets.symmetric(vertical: 8),
            itemCount: state.outgoingRequests.length + (state.outgoingHasMore ? 1 : 0),
            separatorBuilder: (context, index) => Divider(
              height: 1,
              color: theme.dividerColor.withOpacity(0.1),
              indent: 76,
            ),
            itemBuilder: (context, index) {
              if (index >= state.outgoingRequests.length) {
                return Padding(
                  padding: const EdgeInsets.all(16),
                  child: Center(
                    child: SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: theme.primaryColor,
                      ),
                    ),
                  ),
                );
              }

              final request = state.outgoingRequests[index];
              return FriendListTile(
                user: request.user,
                subtitle: '${l10n.sentAt} ${timeago.format(request.requestedAt)}',
                trailing: IconButton(
                  icon: const Icon(Icons.close, size: 20),
                  onPressed: () {
                    context.read<FriendshipBloc>().add(
                      RemoveFriendshipEvent(request.friendshipId),
                    );
                  },
                  style: IconButton.styleFrom(
                    backgroundColor: theme.cardColor,
                    foregroundColor: theme.textTheme.bodyMedium?.color,
                    side: BorderSide(color: theme.dividerColor),
                  ),
                ),
              );
            },
          ),
        );
      },
    );
  }
}import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/core/ui/common/empty_state_widget.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_bloc.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_event.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_state.dart';
import 'package:unitalk/features/friendship/presentation/widgets/friend_list_tile.dart';
import 'package:unitalk/l10n/app_localizations.dart';

class FriendsListPage extends StatefulWidget {
  const FriendsListPage({Key? key}) : super(key: key);

  @override
  State<FriendsListPage> createState() => _FriendsListPageState();
}

class _FriendsListPageState extends State<FriendsListPage> {
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
    // Загружаем друзей при открытии страницы
    context.read<FriendshipBloc>().add(LoadFriendsListEvent());
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_isBottom) {
      final state = context.read<FriendshipBloc>().state;
      if (state.friendsHasMore && !state.isLoadingMore) {
        context.read<FriendshipBloc>().add(LoadFriendsListEvent(loadMore: true));
      }
    }
  }

  bool get _isBottom {
    if (!_scrollController.hasClients) return false;
    final maxScroll = _scrollController.position.maxScrollExtent;
    final currentScroll = _scrollController.offset;
    return currentScroll >= (maxScroll * 0.85);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: theme.scaffoldBackgroundColor,
        surfaceTintColor: theme.scaffoldBackgroundColor,
        title: Text(
          l10n.friends,
          style: TextStyle(
            color: theme.textTheme.titleLarge?.color,
            fontSize: 20,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      body: BlocBuilder<FriendshipBloc, FriendshipState>(
        builder: (context, state) {
          if (state.status == FriendshipStateStatus.loading && state.friends.isEmpty) {
            return Center(
              child: CircularProgressIndicator(
                strokeWidth: 2,
                color: theme.primaryColor,
              ),
            );
          }

          if (state.hasError) {
            return EmptyStateWidget(
              icon: Icons.error_outline,
              title: state.errorMessage ?? l10n.anErrorOccurred,
              subtitle: null,
            );
          }

          if (state.friends.isEmpty) {
            return EmptyStateWidget(
              icon: Icons.people_outline,
              title: l10n.noFriendsYet,
              subtitle: l10n.startAddingFriends,
            );
          }

          return RefreshIndicator(
            onRefresh: () async {
              context.read<FriendshipBloc>().add(LoadFriendsListEvent());
            },
            child: ListView.separated(
              controller: _scrollController,
              padding: const EdgeInsets.symmetric(vertical: 8),
              itemCount: state.friends.length + (state.friendsHasMore ? 1 : 0),
              separatorBuilder: (context, index) => Divider(
                height: 1,
                color: theme.dividerColor.withOpacity(0.1),
                indent: 76,
              ),
              itemBuilder: (context, index) {
                if (index >= state.friends.length) {
                  return Padding(
                    padding: const EdgeInsets.all(16),
                    child: Center(
                      child: SizedBox(
                        width: 24,
                        height: 24,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          color: theme.primaryColor,
                        ),
                      ),
                    ),
                  );
                }

                final friend = state.friends[index];
                return FriendListTile(user: friend);
              },
            ),
          );
        },
      ),
    );
  }
}import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_bloc.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_event.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_state.dart'
    show FriendshipState;
import 'package:unitalk/l10n/app_localizations.dart';

import '../../data/model/friendship_model.dart' show FriendshipStatus;

class FriendshipButton extends StatelessWidget {
  final String userId;
  final bool compact;

  const FriendshipButton({Key? key, required this.userId, this.compact = false})
    : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = AppLocalizations.of(context)!;

    return BlocBuilder<FriendshipBloc, FriendshipState>(
      builder: (context, state) {
        final friendshipStatus = state.getFriendshipStatus(userId);

        if (friendshipStatus == null) {
          // Если статус еще не загружен, загружаем его
          context.read<FriendshipBloc>().add(LoadFriendshipStatusEvent(userId));
          return const SizedBox.shrink();
        }

        final status = friendshipStatus.status;
        final isRequester = friendshipStatus.isRequester ?? false;
        final friendshipId = friendshipStatus.friendshipId;

        // Уже друзья
        if (status == FriendshipStatus.accepted) {
          return _buildButton(
            context: context,
            label: compact ? l10n.friends : l10n.removeFriend,
            icon: compact ? Icons.people : Icons.person_remove,
            backgroundColor: theme.cardColor,
            foregroundColor: theme.textTheme.bodyMedium?.color,
            borderColor: theme.dividerColor,
            onPressed: () {
              _showRemoveFriendDialog(context, friendshipId!);
            },
          );
        }

        // Ожидает ответа (текущий пользователь отправил запрос)
        if (status == FriendshipStatus.pending && isRequester) {
          return _buildButton(
            context: context,
            label: compact ? l10n.pending : l10n.cancelRequest,
            icon: compact ? Icons.schedule : Icons.close,
            backgroundColor: theme.cardColor,
            foregroundColor: theme.textTheme.bodyMedium?.color?.withOpacity(
              0.6,
            ),
            borderColor: theme.dividerColor,
            onPressed: () {
              context.read<FriendshipBloc>().add(
                RemoveFriendshipEvent(
                  friendshipId!,
                  userId: userId,
                ), // ✅ ИЗМЕНЕНО
              );
            },
          );
        }

        // Входящий запрос (другой пользователь отправил запрос)
        if (status == FriendshipStatus.pending && !isRequester) {
          return Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildButton(
                context: context,
                label: l10n.accept,
                icon: Icons.check,
                backgroundColor: theme.primaryColor,
                foregroundColor: Colors.white,
                onPressed: () {
                  context.read<FriendshipBloc>().add(
                    AcceptFriendRequestEvent(friendshipId!),
                  );
                },
              ),
              const SizedBox(width: 8),
              _buildButton(
                context: context,
                label: l10n.reject,
                icon: Icons.close,
                backgroundColor: theme.cardColor,
                foregroundColor: theme.textTheme.bodyMedium?.color,
                borderColor: theme.dividerColor,
                onPressed: () {
                  context.read<FriendshipBloc>().add(
                    RejectFriendRequestEvent(friendshipId!),
                  );
                },
              ),
            ],
          );
        }

        // Нет дружбы
        return _buildButton(
          context: context,
          label: compact ? l10n.add : l10n.addFriend,
          icon: compact ? Icons.person_add : Icons.person_add_outlined,
          backgroundColor: theme.primaryColor,
          foregroundColor: Colors.white,
          onPressed: () {
            context.read<FriendshipBloc>().add(SendFriendRequestEvent(userId));
          },
        );
      },
    );
  }

  Widget _buildButton({
    required BuildContext context,
    required String label,
    required IconData icon,
    required Color backgroundColor,
    required Color? foregroundColor,
    Color? borderColor,
    required VoidCallback onPressed,
  }) {
    return compact
        ? IconButton.filled(
            onPressed: onPressed,
            icon: Icon(icon, size: 20),
            style: IconButton.styleFrom(
              backgroundColor: backgroundColor,
              foregroundColor: foregroundColor,
              side: borderColor != null ? BorderSide(color: borderColor) : null,
            ),
          )
        : ElevatedButton.icon(
            onPressed: onPressed,
            icon: Icon(icon, size: 18),
            label: Text(label),
            style: ElevatedButton.styleFrom(
              backgroundColor: backgroundColor,
              foregroundColor: foregroundColor,
              elevation: 0,
              side: borderColor != null ? BorderSide(color: borderColor) : null,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
            ),
          );
  }

  void _showRemoveFriendDialog(BuildContext context, String friendshipId) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);

    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text(l10n.removeFriend),
        content: Text(l10n.removeFriendConfirmation),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: Text(l10n.cancel),
          ),
          TextButton(
            onPressed: () {
              context.read<FriendshipBloc>().add(
                RemoveFriendshipEvent(
                  friendshipId,
                  userId: userId,
                ), // ✅ ИЗМЕНЕНО
              );
              Navigator.pop(dialogContext);
            },
            style: TextButton.styleFrom(
              foregroundColor: theme.colorScheme.error,
            ),
            child: Text(l10n.remove),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:unitalk/l10n/app_localizations.dart';

class FriendsCountButton extends StatelessWidget {
  final int friendsCount;
  final String? userId;
  final bool isDark;

  const FriendsCountButton({
    Key? key,
    required this.friendsCount,
    this.userId,
    this.isDark = false,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return InkWell(
      onTap: () {
        // Открываем список друзей
        context.push('/friends');
      },
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: isDark
              ? Colors.white.withOpacity(0.1)
              : Colors.white.withOpacity(0.2),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: Colors.white.withOpacity(0.2),
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.people_outline,
              size: 20,
              color: isDark ? Colors.white : Colors.white,
            ),
            const SizedBox(width: 8),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  '$friendsCount',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: isDark ? Colors.white : Colors.white,
                    height: 1.2,
                  ),
                ),
                Text(
                  l10n.friends,
                  style: TextStyle(
                    fontSize: 11,
                    color: (isDark ? Colors.white : Colors.white).withOpacity(0.8),
                    height: 1,
                  ),
                ),
              ],
            ),
            const SizedBox(width: 4),
            Icon(
              Icons.chevron_right,
              size: 16,
              color: (isDark ? Colors.white : Colors.white).withOpacity(0.6),
            ),
          ],
        ),
      ),
    );
  }
}import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:unitalk/core/ui/common/user_avatar.dart';
import 'package:unitalk/core/ui/common/user_meta_info.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

class FriendListTile extends StatelessWidget {
  final UserModel user;
  final String? subtitle;
  final Widget? trailing;
  final VoidCallback? onTap;

  const FriendListTile({
    Key? key,
    required this.user,
    this.subtitle,
    this.trailing,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final locale = Localizations.localeOf(context).languageCode;

    return InkWell(
      onTap: onTap ?? () => context.push('/user/${user.id}'),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            UserAvatar(
              photoUrl: user.photoUrl,
              firstName: user.firstName,
              lastName: user.lastName,
              size: 48,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Flexible(
                        child: Text(
                          '${user.firstName ?? ''} ${user.lastName ?? ''}'.trim(),
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w600,
                            color: theme.textTheme.titleLarge?.color,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                      if (user.isVerified == true) ...[
                        const SizedBox(width: 4),
                        Icon(
                          Icons.verified,
                          size: 16,
                          color: theme.primaryColor,
                        ),
                      ],
                    ],
                  ),
                  const SizedBox(height: 4),
                  if (subtitle != null)
                    Text(
                      subtitle!,
                      style: TextStyle(
                        fontSize: 13,
                        color: theme.textTheme.bodySmall?.color?.withOpacity(0.6),
                      ),
                    )
                  else if (user.faculty != null || user.sector != null)
                    UserMetaInfo(
                      faculty: user.faculty?.getLocalizedName(locale),
                      sector: user.sector,
                      fontSize: 13,
                    ),
                ],
              ),
            ),
            if (trailing != null) ...[
              const SizedBox(width: 8),
              trailing!,
            ],
          ],
        ),
      ),
    );
  }
}import 'package:dartz/dartz.dart';
import 'package:unitalk/core/failure/failure.dart';
import 'package:unitalk/features/friendship/data/datasource/friendship_remote_datasource.dart';
import 'package:unitalk/features/friendship/data/model/friendship_model.dart';
import 'package:unitalk/features/friendship/domain/repository/friendship_repository.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

class FriendshipRepositoryImpl implements FriendshipRepository {
  final FriendshipRemoteDataSource remoteDataSource;

  FriendshipRepositoryImpl(this.remoteDataSource);

  @override
  Future<Either<Failure, FriendshipModel>> sendFriendRequest(String userId) async {
    try {
      final result = await remoteDataSource.sendFriendRequest(userId);
      return Right(result);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, FriendshipModel>> acceptFriendRequest(String friendshipId) async {
    try {
      final result = await remoteDataSource.acceptFriendRequest(friendshipId);
      return Right(result);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, FriendshipModel>> rejectFriendRequest(String friendshipId) async {
    try {
      final result = await remoteDataSource.rejectFriendRequest(friendshipId);
      return Right(result);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> removeFriendship(String friendshipId) async {
    try {
      await remoteDataSource.removeFriendship(friendshipId);
      return const Right(null);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<UserModel>>> getFriendsList({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await remoteDataSource.getFriendsList(
        page: page,
        limit: limit,
      );

      final friends = (response['friends'] as List)
          .map((json) => UserModel.fromJson(json as Map<String, dynamic>))
          .toList();

      return Right(friends);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<FriendRequestModel>>> getIncomingRequests({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await remoteDataSource.getIncomingRequests(
        page: page,
        limit: limit,
      );

      final requests = (response['requests'] as List)
          .map((json) => FriendRequestModel.fromJson(json as Map<String, dynamic>))
          .toList();

      return Right(requests);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<FriendRequestModel>>> getOutgoingRequests({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await remoteDataSource.getOutgoingRequests(
        page: page,
        limit: limit,
      );

      final requests = (response['requests'] as List)
          .map((json) => FriendRequestModel.fromJson(json as Map<String, dynamic>))
          .toList();

      return Right(requests);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, FriendshipStatusResponse>> getFriendshipStatus(String userId) async {
    try {
      final result = await remoteDataSource.getFriendshipStatus(userId);
      return Right(result);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }
}import 'package:dartz/dartz.dart';
import 'package:unitalk/core/failure/failure.dart';
import 'package:unitalk/features/friendship/data/model/friendship_model.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

abstract class FriendshipRepository {
  // Управление дружбой
  Future<Either<Failure, FriendshipModel>> sendFriendRequest(String userId);
  Future<Either<Failure, FriendshipModel>> acceptFriendRequest(String friendshipId);
  Future<Either<Failure, FriendshipModel>> rejectFriendRequest(String friendshipId);
  Future<Either<Failure, void>> removeFriendship(String friendshipId);

  // Получение данных
  Future<Either<Failure, List<UserModel>>> getFriendsList({
    int page = 1,
    int limit = 20,
  });

  Future<Either<Failure, List<FriendRequestModel>>> getIncomingRequests({
    int page = 1,
    int limit = 20,
  });

  Future<Either<Failure, List<FriendRequestModel>>> getOutgoingRequests({
    int page = 1,
    int limit = 20,
  });

  Future<Either<Failure, FriendshipStatusResponse>> getFriendshipStatus(String userId);
}import 'package:dio/dio.dart';
import 'package:unitalk/features/friendship/data/model/friendship_model.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

class FriendshipRemoteDataSource {
  final Dio dio;

  FriendshipRemoteDataSource({required this.dio});

  // Отправить запрос в друзья
  Future<FriendshipModel> sendFriendRequest(String userId) async {
    try {
      final response = await dio.post('/friends/request/$userId');
      return FriendshipModel.fromJson(response.data['friendship']);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Принять запрос
  Future<FriendshipModel> acceptFriendRequest(String friendshipId) async {
    try {
      final response = await dio.put('/friends/accept/$friendshipId');
      return FriendshipModel.fromJson(response.data['friendship']);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Отклонить запрос
  Future<FriendshipModel> rejectFriendRequest(String friendshipId) async {
    try {
      final response = await dio.put('/friends/reject/$friendshipId');
      return FriendshipModel.fromJson(response.data['friendship']);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Удалить дружбу или отменить запрос
  Future<void> removeFriendship(String friendshipId) async {
    try {
      await dio.delete('/friends/$friendshipId');
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Получить список друзей с пагинацией
  Future<Map<String, dynamic>> getFriendsList({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await dio.get(
        '/friends/list',
        queryParameters: {
          'page': page,
          'limit': limit,
        },
      );
      return response.data as Map<String, dynamic>;
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Получить входящие запросы
  Future<Map<String, dynamic>> getIncomingRequests({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await dio.get(
        '/friends/requests/incoming',
        queryParameters: {
          'page': page,
          'limit': limit,
        },
      );
      return response.data as Map<String, dynamic>;
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Получить исходящие запросы
  Future<Map<String, dynamic>> getOutgoingRequests({
    int page = 1,
    int limit = 20,
  }) async {
    try {
      final response = await dio.get(
        '/friends/requests/outgoing',
        queryParameters: {
          'page': page,
          'limit': limit,
        },
      );
      return response.data as Map<String, dynamic>;
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  // Получить статус дружбы с конкретным пользователем
  Future<FriendshipStatusResponse> getFriendshipStatus(String userId) async {
    try {
      final response = await dio.get('/friends/status/$userId');
      return FriendshipStatusResponse.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  String _handleError(DioException error) {
    if (error.response?.data != null && error.response!.data['error'] != null) {
      return error.response!.data['error'] as String;
    }

    switch (error.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        return 'Connection timeout. Please try again.';

      case DioExceptionType.connectionError:
        return 'No internet connection.';

      case DioExceptionType.badResponse:
        final statusCode = error.response?.statusCode;
        if (statusCode == 404) return 'User not found.';
        if (statusCode == 403) return 'Access denied.';
        return 'Request failed. Please try again.';

      default:
        return 'An unexpected error occurred.';
    }
  }
}// lib/features/friendship/data/models/friendship_model.dart
import 'package:json_annotation/json_annotation.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';

part 'friendship_model.g.dart';

enum FriendshipStatus {
  @JsonValue('none')
  none,
  @JsonValue('pending')
  pending,
  @JsonValue('accepted')
  accepted,
  @JsonValue('rejected')
  rejected,
}

@JsonSerializable()
class FriendshipModel {
  @JsonKey(name: '_id')
  final String? id;
  final FriendshipStatus status;
  final String? friendshipId;
  final bool? isRequester;
  final DateTime? createdAt;
  final DateTime? acceptedAt;

  FriendshipModel({
    this.id,
    required this.status,
    this.friendshipId,
    this.isRequester,
    this.createdAt,
    this.acceptedAt,
  });

  factory FriendshipModel.fromJson(Map<String, dynamic> json) =>
      _$FriendshipModelFromJson(json);

  Map<String, dynamic> toJson() => _$FriendshipModelToJson(this);

  bool get isPending => status == FriendshipStatus.pending;
  bool get isAccepted => status == FriendshipStatus.accepted;
  bool get isNone => status == FriendshipStatus.none;
}

@JsonSerializable()
class FriendshipStatusResponse {
  final FriendshipStatus status;
  final bool isFriend;
  final String? friendshipId;
  final bool? isRequester;
  final DateTime? createdAt;
  final DateTime? acceptedAt;

  FriendshipStatusResponse({
    required this.status,
    required this.isFriend,
    this.friendshipId,
    this.isRequester,
    this.createdAt,
    this.acceptedAt,
  });

  factory FriendshipStatusResponse.fromJson(Map<String, dynamic> json) =>
      _$FriendshipStatusResponseFromJson(json);

  Map<String, dynamic> toJson() => _$FriendshipStatusResponseToJson(this);
}

@JsonSerializable()
class FriendRequestModel {
  final String friendshipId;
  final UserModel user;
  final DateTime requestedAt;

  FriendRequestModel({
    required this.friendshipId,
    required this.user,
    required this.requestedAt,
  });

  factory FriendRequestModel.fromJson(Map<String, dynamic> json) =>
      _$FriendRequestModelFromJson(json);

  Map<String, dynamic> toJson() => _$FriendRequestModelToJson(this);
}import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:unitalk/core/ui/common/fullscreen_image_viewer.dart';
import 'package:unitalk/core/ui/widgets/default_avatar.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';
import 'package:unitalk/features/auth/presentation/widget/card_info_row.dart';
import 'package:unitalk/features/friendship/presentation/widgets/friends_count_button.dart';
import 'package:unitalk/l10n/app_localizations.dart';

class StudentIdCardWidget extends StatelessWidget {
  final UserModel user;
  final bool showFriendsCount; // ✅ НОВЫЙ параметр

  const StudentIdCardWidget({
    super.key,
    required this.user,
    this.showFriendsCount = true, // ✅ По умолчанию показываем
  });

  void _showImageFullscreen(BuildContext context, String imageUrl) {
    FullscreenImageViewer.showAvatar(
      context,
      imageUrl,
      userId: user.id,
      heroTag: 'avatar_${user.id}',
    );
  }

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final locale = Localizations.localeOf(context).languageCode;
    final l10n = AppLocalizations.of(context)!;

    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: isDark
              ? [const Color(0xFF1a237e), const Color(0xFF0d47a1)]
              : [const Color(0xFF1976d2), const Color(0xFF42a5f5)],
        ),
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Theme.of(context).shadowColor.withValues(alpha: .3),
            blurRadius: 20,
            offset: const Offset(0, 10),
          ),
        ],
      ),
      child: Stack(
        children: [
          // Background Pattern
          Positioned.fill(
            child: Opacity(
              opacity: 0.1,
              child: CustomPaint(
                painter: _CardPatternPainter(),
              ),
            ),
          ),

          // Content
          Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Header
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            l10n.studentIdCard.toUpperCase(),
                            style: TextStyle(
                              fontSize: 10,
                              fontWeight: FontWeight.w600,
                              letterSpacing: 2,
                              color: Colors.white.withOpacity(0.9),
                            ),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            user.university?.getLocalizedName(locale) ?? '',
                            style: TextStyle(
                              fontSize: 12,
                              fontWeight: FontWeight.w500,
                              color: Colors.white.withOpacity(0.85),
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(width: 20),
                    if (user.university?.logoUrl != null)
                      ClipRRect(
                        borderRadius: BorderRadius.circular(8),
                        child: Container(
                          width: 55,
                          height: 55,
                          decoration: const BoxDecoration(color: Colors.white),
                          child: CachedNetworkImage(
                            imageUrl: user.university!.logoUrl!,
                            fit: BoxFit.cover,
                            errorWidget: (_, __, ___) => Icon(
                              Icons.school,
                              color: Theme.of(context).primaryColor,
                              size: 20,
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
                const SizedBox(height: 20),

                // Student Info
                Row(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    // Avatar with fullscreen tap
                    GestureDetector(
                      onTap: user.photoUrl != null
                          ? () => _showImageFullscreen(context, user.photoUrl!)
                          : null,
                      child: Hero(
                        tag: 'avatar_${user.id}',
                        child: Container(
                          width: 75,
                          height: 95,
                          decoration: BoxDecoration(
                            color: Colors.white,
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(color: Colors.white, width: 2),
                          ),
                          child: ClipRRect(
                            borderRadius: BorderRadius.circular(6),
                            child: user.photoUrl != null
                                ? CachedNetworkImage(
                              imageUrl: user.photoUrl!,
                              fit: BoxFit.cover,
                              errorWidget: (_, __, ___) =>  DefaultAvatar(),
                            )
                                :  DefaultAvatar(),
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 16),

                    // Details
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.max,
                        mainAxisAlignment: MainAxisAlignment.start,
                        children: [
                          Text(
                            '${user.firstName ?? ''} ${user.lastName ?? ''}'
                                .toUpperCase(),
                            style: const TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                              letterSpacing: 0.5,
                            ),
                            maxLines: 2,
                          ),
                          const SizedBox(height: 6),
                          CardInfoRow(
                            label: l10n.idLabel,
                            value: user.id?.substring(0, 8).toUpperCase() ?? '',
                          ),
                          const SizedBox(height: 3),
                          CardInfoRow(
                            label: l10n.faculty,
                            value: user.faculty?.getLocalizedName(locale) ??
                                l10n.notAvailable,
                          ),
                          const SizedBox(height: 3),
                          CardInfoRow(
                            label: l10n.sector,
                            value: user.sector?.displayName ?? l10n.notAvailable,
                          ),
                        ],
                      ),
                    ),
                  ],
                ),

                // ✅ НОВОЕ: Счетчик друзей
                if (showFriendsCount && user.friendsCount != null) ...[
                  const SizedBox(height: 16),
                  FriendsCountButton(
                    friendsCount: user.friendsCount!,
                    userId: user.id,
                    isDark: isDark,
                  ),
                ],
              ],
            ),
          ),

          // Verified Badge
          if (user.isVerified == true)
            Positioned(
              top: 16,
              right: 16,
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: Colors.green,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const Icon(Icons.verified, size: 12, color: Colors.white),
                    const SizedBox(width: 4),
                    Text(
                      l10n.verified.toUpperCase(),
                      style: const TextStyle(
                        fontSize: 9,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                        letterSpacing: 1,
                      ),
                    ),
                  ],
                ),
              ),
            ),
        ],
      ),
    );
  }
}

/// Painter for background pattern
class _CardPatternPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1;

    for (int i = 0; i < 10; i++) {
      canvas.drawCircle(
        Offset(size.width * 0.8, size.height * 0.2 + i * 20),
        30 + i * 5,
        paint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:unitalk/core/di/service_locator.dart';
import 'package:unitalk/core/ui/common/report_dialog.dart';
import 'package:unitalk/features/auth/data/model/user_model.dart';
import 'package:unitalk/features/auth/presentation/bloc/auth_bloc.dart';
import 'package:unitalk/features/auth/presentation/bloc/auth_state.dart';
import 'package:unitalk/features/block/presentation/bloc/block_bloc.dart';
import 'package:unitalk/features/block/presentation/bloc/block_event.dart';
import 'package:unitalk/features/block/presentation/bloc/block_state.dart';
import 'package:unitalk/features/feed/presentation/bloc/post/post_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/post/post_event.dart';
import 'package:unitalk/features/feed/presentation/bloc/post/post_state.dart';
import 'package:unitalk/features/feed/presentation/bloc/user_profile/user_profile_bloc.dart';
import 'package:unitalk/features/feed/presentation/bloc/user_profile/user_profile_event.dart';
import 'package:unitalk/features/feed/presentation/bloc/user_profile/user_profile_state.dart';
import 'package:unitalk/features/feed/presentation/widget/post_item.dart';
import 'package:unitalk/features/auth/presentation/widget/student_id_card_widget.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_bloc.dart';
import 'package:unitalk/features/friendship/presentation/bloc/friendship_event.dart';
import 'package:unitalk/features/friendship/presentation/widgets/friendship_button.dart';
import 'package:unitalk/features/report/data/model/report_model.dart';
import 'package:unitalk/l10n/app_localizations.dart';

class OtherUserProfileScreen extends StatefulWidget {
  final String userId;

  const OtherUserProfileScreen({
    Key? key,
    required this.userId,
  }) : super(key: key);

  @override
  State<OtherUserProfileScreen> createState() => _OtherUserProfileScreenState();
}

class _OtherUserProfileScreenState extends State<OtherUserProfileScreen> {
  late ScrollController _scrollController;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
    _scrollController.addListener(_onScroll);

    context.read<UserProfileBloc>().add(GetUserProfileEvent(widget.userId));
    context.read<PostBloc>().add(GetPostsEvent(
      authorId: widget.userId,
      page: 1,
      limit: 20,
    ));
    context.read<BlockBloc>().add(CheckBlockStatusEvent(widget.userId));
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  Future<void> _onRefresh() async {
    context.read<UserProfileBloc>().add(GetUserProfileEvent(widget.userId));
    context.read<BlockBloc>().add(CheckBlockStatusEvent(widget.userId));
    context.read<PostBloc>().add(GetPostsEvent(
      authorId: widget.userId,
      page: 1,
      limit: 20,
    ));

    await context.read<UserProfileBloc>().stream.firstWhere(
          (state) => !state.isLoading,
    );
  }

  void _onScroll() {
    if (_scrollController.position.pixels ==
        _scrollController.position.maxScrollExtent) {
      final postState = context.read<PostBloc>().state;

      if (!postState.postsLastPage && !postState.isLoadingMore) {
        context.read<PostBloc>().add(GetPostsEvent(
          authorId: widget.userId,
          page: postState.postsPage + 1,
          limit: 20,
        ));
      }
    }
  }

  // ✅ НОВОЕ: Показать меню модерации
  void _showModerationMenu(BuildContext context, UserModel user) {
    final l10n = AppLocalizations.of(context)!;
    final blockStatus = user.blockStatus;

    showModalBottomSheet(
      context: context,
      backgroundColor: Theme.of(context).scaffoldBackgroundColor,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (sheetContext) => SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Handle
            Container(
              margin: const EdgeInsets.only(top: 12, bottom: 20),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: Theme.of(context).dividerColor,
                borderRadius: BorderRadius.circular(2),
              ),
            ),

            // Заблокирован/Разблокировать
            if (blockStatus?.isBlocked == true)
              ListTile(
                leading: const Icon(Icons.block, color: Colors.red),
                title: Text(l10n.unblockUser),
                onTap: () {
                  Navigator.pop(sheetContext);
                  _showUnblockDialog(context, widget.userId, user);
                },
              )
            else if (blockStatus?.isBlockedBy != true)
              ListTile(
                leading: const Icon(Icons.block, color: Colors.red),
                title: Text(l10n.blockUser),
                onTap: () {
                  Navigator.pop(sheetContext);
                  _showBlockDialog(context, widget.userId, user);
                },
              ),

            // Пожаловаться
            if (blockStatus?.isBlockedBy != true)
              ListTile(
                leading: const Icon(Icons.flag_outlined),
                title: Text(l10n.report),
                onTap: () {
                  Navigator.pop(sheetContext);
                  ReportDialog.show(
                    context,
                    targetType: ReportTargetType.user,
                    targetId: widget.userId,
                  );
                },
              ),

            const SizedBox(height: 12),
          ],
        ),
      ),
    );
  }

  void _showBlockDialog(BuildContext context, String userId, UserModel user) {
    final l10n = AppLocalizations.of(context)!;

    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text(l10n.blockUser),
        content: Text(l10n.blockUserConfirmation(
            '${user.firstName} ${user.lastName}')),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: Text(l10n.cancel),
          ),
          FilledButton(
            onPressed: () {
              context.read<BlockBloc>().add(BlockUserEvent(userId));
              Navigator.pop(dialogContext);
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text(l10n.userBlocked)),
              );
            },
            style: FilledButton.styleFrom(backgroundColor: Colors.red),
            child: Text(l10n.block),
          ),
        ],
      ),
    );
  }

  void _showUnblockDialog(
      BuildContext context, String userId, UserModel user) {
    final l10n = AppLocalizations.of(context)!;

    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text(l10n.unblockUser),
        content: Text(l10n.unblockUserConfirmation(
            '${user.firstName} ${user.lastName}')),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: Text(l10n.cancel),
          ),
          FilledButton(
            onPressed: () {
              context.read<BlockBloc>().add(UnblockUserEvent(userId));
              Navigator.pop(dialogContext);
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text(l10n.userUnblocked)),
              );
            },
            child: Text(l10n.unblock),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return BlocProvider(
      create: (context) => sl<FriendshipBloc>()
        ..add(LoadFriendshipStatusEvent(widget.userId)),
      child: Scaffold(
        backgroundColor: Theme.of(context).scaffoldBackgroundColor,
        body: BlocBuilder<UserProfileBloc, UserProfileState>(
          builder: (context, profileState) {
            if (profileState.isLoading && profileState.user == null) {
              return const Center(child: CircularProgressIndicator());
            }

            if (profileState.errorMessage != null && profileState.user == null) {
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.error_outline,
                      size: 64,
                      color: Theme.of(context)
                          .textTheme
                          .bodySmall
                          ?.color
                          ?.withOpacity(0.3),
                    ),
                    const SizedBox(height: 16),
                    Text(
                      l10n.errorMessage(profileState.errorMessage ?? ''),
                      style: TextStyle(
                        fontSize: 16,
                        color: Theme.of(context)
                            .textTheme
                            .bodySmall
                            ?.color
                            ?.withOpacity(0.6),
                      ),
                    ),
                    const SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: () {
                        context
                            .read<UserProfileBloc>()
                            .add(GetUserProfileEvent(widget.userId));
                      },
                      child: Text(l10n.tryAgain),
                    ),
                  ],
                ),
              );
            }

            final user = profileState.user;
            if (user == null) {
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.person_off_outlined,
                      size: 64,
                      color: Theme.of(context)
                          .textTheme
                          .bodySmall
                          ?.color
                          ?.withOpacity(0.3),
                    ),
                    const SizedBox(height: 16),
                    Text(
                      l10n.userNotFound,
                      style: TextStyle(
                        fontSize: 16,
                        color: Theme.of(context)
                            .textTheme
                            .bodySmall
                            ?.color
                            ?.withOpacity(0.6),
                      ),
                    ),
                  ],
                ),
              );
            }

            return BlocBuilder<PostBloc, PostState>(
              builder: (context, postState) {
                return RefreshIndicator(
                  onRefresh: _onRefresh,
                  color: Theme.of(context).colorScheme.primary,
                  backgroundColor: Theme.of(context).colorScheme.surface,
                  child: CustomScrollView(
                    controller: _scrollController,
                    physics: const AlwaysScrollableScrollPhysics(),
                    slivers: [
                      // ✅ ОБНОВЛЕНО: App Bar с меню
                      SliverAppBar(
                        expandedHeight: 0,
                        pinned: false,
                        backgroundColor: Colors.transparent,
                        elevation: 0,
                        title: Text(l10n.profile),
                        leading: IconButton(
                          icon: const Icon(Icons.arrow_back),
                          onPressed: () => context.pop(),
                        ),
                        actions: [
                          // ✅ НОВОЕ: Меню с 3 точками
                          BlocBuilder<AuthBloc, AuthState>(
                            builder: (context, authState) {
                              final isOwnProfile =
                                  authState.user?.id == widget.userId;

                              if (isOwnProfile) {
                                return const SizedBox.shrink();
                              }

                              return IconButton(
                                icon: const Icon(Icons.more_vert),
                                onPressed: () =>
                                    _showModerationMenu(context, user),
                              );
                            },
                          ),
                        ],
                      ),

                      // Profile Content
                      SliverPadding(
                        padding: const EdgeInsets.all(20),
                        sliver: SliverList(
                          delegate: SliverChildListDelegate([
                            // Student Card with Friends Count
                            StudentIdCardWidget(user: user),
                            const SizedBox(height: 16),

                            // ✅ НОВОЕ: Кнопка дружбы
                            FriendshipButton(userId: widget.userId),
                            const SizedBox(height: 24),

                            // Posts Section Header
                            Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                Text(
                                  l10n.posts,
                                  style: const TextStyle(
                                    fontSize: 20,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                                Text(
                                  l10n.postsCount(postState.posts.length),
                                  style: TextStyle(
                                    fontSize: 14,
                                    color: Theme.of(context)
                                        .textTheme
                                        .bodySmall
                                        ?.color
                                        ?.withOpacity(0.6),
                                  ),
                                ),
                              ],
                            ),
                          ]),
                        ),
                      ),

                      // Posts List
                      if (postState.posts.isEmpty && !postState.isLoading)
                        SliverFillRemaining(
                          child: Center(
                            child: Column(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                Icon(
                                  Icons.article_outlined,
                                  size: 64,
                                  color: Theme.of(context)
                                      .textTheme
                                      .bodySmall
                                      ?.color
                                      ?.withOpacity(0.3),
                                ),
                                const SizedBox(height: 16),
                                Text(
                                  l10n.userHasNoPosts,
                                  textAlign: TextAlign.center,
                                  style: TextStyle(
                                    fontSize: 16,
                                    color: Theme.of(context)
                                        .textTheme
                                        .bodySmall
                                        ?.color
                                        ?.withOpacity(0.6),
                                  ),
                                ),
                              ],
                            ),
                          ),
                        )
                      else
                        SliverList(
                          delegate: SliverChildBuilderDelegate(
                                (context, index) {
                              final post = postState.posts[index];
                              return PostItem(post: post);
                            },
                            childCount: postState.posts.length,
                          ),
                        ),

                      // Loading More Indicator
                      if (postState.isLoadingMore)
                        const SliverToBoxAdapter(
                          child: Padding(
                            padding: EdgeInsets.all(16),
                            child: Center(
                              child: CircularProgressIndicator(),
                            ),
                          ),
                        ),

                      const SliverPadding(
                          padding: EdgeInsets.only(bottom: 40)),
                    ],
                  ),
                );
              },
            );
          },
        ),
      ),
    );
  }
}import 'dart:math';

import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:unitalk/features/notifications/domain/notifcation_repository.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_event.dart';
import 'package:unitalk/features/notifications/presentation/bloc/notification_state.dart';


class NotificationBloc extends Bloc<NotificationEvent, NotificationState> {
  final NotificationRepository notificationRepository;

  NotificationBloc({required this.notificationRepository})
      : super(NotificationState.initial()) {
    on<GetNotificationSettingsEvent>(_onGetSettings);
    on<UpdateNotificationSettingsEvent>(_onUpdateSettings);
    on<SaveFcmTokenEvent>(_onSaveFcmToken);
    on<RemoveFcmTokenEvent>(_onRemoveFcmToken);
    on<GetNotificationsEvent>(_onGetNotifications);
    on<MarkNotificationAsReadEvent>(_onMarkAsRead);
    on<MarkAllNotificationsAsReadEvent>(_onMarkAllAsRead);
    on<DeleteNotificationEvent>(_onDeleteNotification);
    on<DeleteAllNotificationsEvent>(_onDeleteAllNotifications);
    on<RefreshNotificationsEvent>(_onRefreshNotifications);
    on<GetUnreadCountEvent>(_onGetUnreadCount);
    on<HandleIncomingNotificationEvent>(_onHandleIncomingNotification);
  }

  Future<void> _onGetSettings(
      GetNotificationSettingsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    emit(state.copyWith(status: NotificationStatus.loading));

    final result = await notificationRepository.getSettings();

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (settings) => emit(state.copyWith(
        status: NotificationStatus.success,
        settings: settings,
      )),
    );
  }

  Future<void> _onUpdateSettings(
      UpdateNotificationSettingsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    emit(state.copyWith(status: NotificationStatus.loading));

    final result = await notificationRepository.updateSettings(
      enabled: event.enabled,
      newPosts: event.newPosts,
      newComments: event.newComments,
      newLikes: event.newLikes,
      commentReplies: event.commentReplies,
      mentions: event.mentions,
      chatMessages: event.chatMessages,
      chatMentions: event.chatMentions,
    );

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (settings) => emit(state.copyWith(
        status: NotificationStatus.success,
        settings: settings,
      )),
    );
  }

  Future<void> _onSaveFcmToken(
      SaveFcmTokenEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result = await notificationRepository.saveFcmToken(event.fcmToken);

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) => null,
    );
  }

  Future<void> _onRemoveFcmToken(
      RemoveFcmTokenEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result = await notificationRepository.removeFcmToken();

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) => null,
    );
  }

  Future<void> _onGetNotifications(
      GetNotificationsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    if (event.loadMore) {
      if (!state.hasMore) return;
      emit(state.copyWith(status: NotificationStatus.loadingMore));
    } else {
      emit(state.copyWith(status: NotificationStatus.loading));
    }

    final result = await notificationRepository.getNotifications(
      page: event.page,
      limit: 20,
      unreadOnly: event.unreadOnly,
    );

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (response) {
        final newNotifications = event.loadMore
            ? [...state.notifications, ...response.notifications]
            : response.notifications;

        emit(state.copyWith(
          status: NotificationStatus.success,
          notifications: newNotifications,
          unreadCount: response.unreadCount,
          currentPage: state.currentPage + 1,
          hasMore: response.notifications.length >= 20
        ));
      },
    );
  }

  Future<void> _onMarkAsRead(
      MarkNotificationAsReadEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result =
    await notificationRepository.markAsRead(event.notificationId);

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (updatedNotification) {
        final updatedList = state.notifications.map((n) {
          if (n.id == updatedNotification.id) {
            return updatedNotification;
          }
          return n;
        }).toList();

        final newUnreadCount = state.unreadCount > 0 ? state.unreadCount - 1 : 0;

        emit(state.copyWith(
          notifications: updatedList,
          unreadCount: newUnreadCount,
        ));
      },
    );
  }

  Future<void> _onMarkAllAsRead(
      MarkAllNotificationsAsReadEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result = await notificationRepository.markAllAsRead();

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) {
        final updatedList = state.notifications
            .map((n) => n.copyWith(isRead: true))
            .toList();

        emit(state.copyWith(
          notifications: updatedList,
          unreadCount: 0,
        ));
      },
    );
  }

  Future<void> _onDeleteNotification(
      DeleteNotificationEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result =
    await notificationRepository.deleteNotification(event.notificationId);

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) {
        final notification = state.notifications
            .firstWhere((n) => n.id == event.notificationId);

        final updatedList = state.notifications
            .where((n) => n.id != event.notificationId)
            .toList();

        final newUnreadCount = !notification.isRead && state.unreadCount > 0
            ? state.unreadCount - 1
            : state.unreadCount;

        emit(state.copyWith(
          notifications: updatedList,
          unreadCount: newUnreadCount,
        ));
      },
    );
  }

  Future<void> _onDeleteAllNotifications(
      DeleteAllNotificationsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    emit(state.copyWith(status: NotificationStatus.loading));

    final result = await notificationRepository.deleteAllNotifications();

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (_) => emit(state.copyWith(
        status: NotificationStatus.success,
        notifications: [],
        unreadCount: 0,
      )),
    );
  }

  Future<void> _onRefreshNotifications(
      RefreshNotificationsEvent event,
      Emitter<NotificationState> emit,
      ) async {
    print('sdfasfasf');
    final result = await notificationRepository.getNotifications(
      page: 1,
      unreadOnly: false,
    );

    result.fold(
          (failure) => emit(state.copyWith(
        status: NotificationStatus.failure,
        errorMessage: failure.message,
      )),
          (response) {
        emit(state.copyWith(
          status: NotificationStatus.success,
          notifications: response.notifications,
          unreadCount: response.unreadCount,
          currentPage: 1,
          hasMore: response.notifications.length < 20,
        ));
      },
    );
  }

  Future<void> _onGetUnreadCount(
      GetUnreadCountEvent event,
      Emitter<NotificationState> emit,
      ) async {
    final result = await notificationRepository.getUnreadCount();

    result.fold(
          (failure) => null,
          (count) => emit(state.copyWith(unreadCount: count)),
    );
  }

  Future<void> _onHandleIncomingNotification(
      HandleIncomingNotificationEvent event,
      Emitter<NotificationState> emit,
      ) async {
    // Increment unread count when new notification arrives
    emit(state.copyWith(unreadCount: state.unreadCount + 1));

    // Optionally refresh notifications list
    add(RefreshNotificationsEvent());
  }
}abstract class NotificationEvent {}

// Settings Events
class GetNotificationSettingsEvent extends NotificationEvent {}

class UpdateNotificationSettingsEvent extends NotificationEvent {
  final bool? enabled;
  final bool? newPosts;
  final bool? newComments;
  final bool? newLikes;
  final bool? commentReplies;
  final bool? mentions;
  final bool? chatMessages;
  final bool? chatMentions;

  UpdateNotificationSettingsEvent({
    this.enabled,
    this.newPosts,
    this.newComments,
    this.newLikes,
    this.commentReplies,
    this.mentions,
    this.chatMessages,
    this.chatMentions,
  });
}

class SaveFcmTokenEvent extends NotificationEvent {
  final String fcmToken;

  SaveFcmTokenEvent(this.fcmToken);
}

class RemoveFcmTokenEvent extends NotificationEvent {}

// Notification List Events
class GetNotificationsEvent extends NotificationEvent {
  final int page;
  final bool unreadOnly;
  final bool loadMore;

  GetNotificationsEvent({
    this.page = 1,
    this.unreadOnly = false,
    this.loadMore = false,
  });
}

class MarkNotificationAsReadEvent extends NotificationEvent {
  final String notificationId;

  MarkNotificationAsReadEvent(this.notificationId);
}

class MarkAllNotificationsAsReadEvent extends NotificationEvent {}

class DeleteNotificationEvent extends NotificationEvent {
  final String notificationId;

  DeleteNotificationEvent(this.notificationId);
}

class DeleteAllNotificationsEvent extends NotificationEvent {}

class RefreshNotificationsEvent extends NotificationEvent {}

class GetUnreadCountEvent extends NotificationEvent {}

// Handle incoming notification from FCM
class HandleIncomingNotificationEvent extends NotificationEvent {
  final Map<String, dynamic> data;

  HandleIncomingNotificationEvent(this.data);
}import 'package:unitalk/features/notifications/model/notification_model.dart';
import 'package:unitalk/features/notifications/model/notification_settings_model.dart';

enum NotificationStatus {
  initial,
  loading,
  loadingMore,
  success,
  failure,
}

class NotificationState {
  final NotificationStatus status;
  final List<NotificationModel> notifications;
  final NotificationSettingsModel? settings;
  final int unreadCount;
  final int currentPage;
  final bool hasMore;
  final String? errorMessage;

  NotificationState({
    required this.status,
    required this.notifications,
    this.settings,
    required this.unreadCount,
    required this.currentPage,
    required this.hasMore,
    this.errorMessage,
  });

  factory NotificationState.initial() {
    return NotificationState(
      status: NotificationStatus.initial,
      notifications: [],
      settings: null,
      unreadCount: 0,
      currentPage: 1,
      hasMore: true,
      errorMessage: null,
    );
  }

  NotificationState copyWith({
    NotificationStatus? status,
    List<NotificationModel>? notifications,
    NotificationSettingsModel? settings,
    int? unreadCount,
    int? currentPage,
    bool? hasMore,
    String? errorMessage,
  }) {
    return NotificationState(
      status: status ?? this.status,
      notifications: notifications ?? this.notifications,
      settings: settings ?? this.settings,
      unreadCount: unreadCount ?? this.unreadCount,
      currentPage: currentPage ?? this.currentPage,
      hasMore: hasMore ?? this.hasMore,
      errorMessage: errorMessage,
    );
  }
}import 'package:dio/dio.dart';
import 'package:unitalk/features/notifications/model/notification_model.dart';
import 'package:unitalk/features/notifications/model/notification_response_model.dart';
import 'package:unitalk/features/notifications/model/notification_settings_model.dart';

class NotificationRemoteDataSource {
  final Dio dio;

  NotificationRemoteDataSource({required this.dio});

  // ============== SETTINGS ==============

  Future<NotificationSettingsModel> getSettings() async {
    final response = await dio.get('/notifications/settings');
    return NotificationSettingsModel.fromJson(response.data);
  }

  Future<NotificationSettingsModel> updateSettings({
    bool? enabled,
    bool? newPosts,
    bool? newComments,
    bool? newLikes,
    bool? commentReplies,
    bool? mentions,
    bool? chatMessages,
    bool? chatMentions,
  }) async {
    final data = <String, dynamic>{};

    if (enabled != null) data['enabled'] = enabled;
    if (newPosts != null) data['newPosts'] = newPosts;
    if (newComments != null) data['newComments'] = newComments;
    if (newLikes != null) data['newLikes'] = newLikes;
    if (commentReplies != null) data['commentReplies'] = commentReplies;
    if (mentions != null) data['mentions'] = mentions;
    if (chatMessages != null) data['chatMessages'] = chatMessages;
    if (chatMentions != null) data['chatMentions'] = chatMentions;

    final response = await dio.put('/notifications/settings', data: data);
    return NotificationSettingsModel.fromJson(response.data);
  }

  Future<void> saveFcmToken(String fcmToken) async {
    await dio.post('/notifications/fcm-token', data: {'fcmToken': fcmToken});
  }

  Future<void> removeFcmToken() async {
    await dio.delete('/notifications/fcm-token');
  }

  // ============== NOTIFICATIONS ==============

  Future<NotificationsResponseModel> getNotifications({
    int page = 1,
    int limit = 20,
    bool unreadOnly = false,
  }) async {
    final response = await dio.get(
      '/notifications',
      queryParameters: {
        'page': page,
        'limit': limit,
        'unreadOnly': unreadOnly,
      },
    );
    return NotificationsResponseModel.fromJson(response.data);
  }

  Future<NotificationModel> markAsRead(String notificationId) async {
    final response = await dio.put('/notifications/$notificationId/read');
    return NotificationModel.fromJson(response.data);
  }

  Future<void> markAllAsRead() async {
    await dio.put('/notifications/read-all');
  }

  Future<void> deleteNotification(String notificationId) async {
    await dio.delete('/notifications/$notificationId');
  }

  Future<void> deleteAllNotifications() async {
    await dio.delete('/notifications');
  }

  Future<int> getUnreadCount() async {
    final response = await dio.get('/notifications/unread-count');
    return response.data['unreadCount'] as int;
  }
}